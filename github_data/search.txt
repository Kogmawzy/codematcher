convert int to string
private static QName convertString(String str) {        if (str != null) {            return QName.valueOf(str);        } else {            return null;        }    }
public String convertString(String string)    {                int start;        int end = 0;        while ((start = string.indexOf("k", end)) > 0)        {            end = start + 1;            char ch = string.charAt(start - 1);            if ((ch != '.') && (ch != ' '))                continue;            ch = string.charAt(start + 1);            if (!Character.isUpperCase(ch))                continue;            boolean isUpper = false;            for (; end < string.length(); end++)            {                 ch = string.charAt(end);                if (!Character.isJavaIdentifierPart(ch))                    break;                if (!Character.isUpperCase(ch))                    isUpper = true;            }            if (!isUpper) if ((end - start) >= 3)                continue;            if (end >= string.length())                break;            String newName = convertNameToConstant(string.substring(start+1, end));                        string = string.substring(0, start) + newName + string.substring(end);        }        return string;    }
public String convertString(String string)    {        if (string.indexOf("package") == 0)        {            String strPkg = m_strPkg;            if (string.indexOf(".impl") != -1)                strPkg = strPkg + ".impl";            if (m_bCurrentShared)                string = "package " + strPkg + ";";            else                string += "\n" + "import " + strPkg + ".*;";        }        else        {            return super.convertString(string);        }        return string;    }
public String convertString(String string)    {        if (string.indexOf("<referral") != -1)        {            int iStart = string.indexOf("url=\"") + 5;            int iEnd = string.indexOf('\"', iStart);            if ((iStart != 4) && (iEnd != -1))            {                String filename = string.substring(iStart, iEnd);                if (filename.indexOf(":/") == -1)                {                    String stringFile = readFile(filename);                                        if (stringFile != null)                        string = "<!-- " + "Repository inlined from: " + filename  + " -->"                            + "\n" + stringFile + "\n";                }                    }        }        return string;    }
public String convertString(String string)    {    /**   if (string.indexOf("package") == 0)            string = this.replaceString(string, m_strSourcePackage, m_strDestPackage);        if (string.indexOf("import") == 0)        {            string = this.replaceString(string, m_strSourcePackage + ".", m_strDestPackage + ".");            string = this.replaceString(string, "com.sun.java.swing.", "javax.swing.");        }    */        if (m_strChange != null)        {            for (int i = 0; i < m_strChange.length; i++)            {                if (string.indexOf(m_strChange[i][0]) != -1)                {                    string = this.replaceString(string, m_strChange[i][0], m_strChange[i][1]);                }            }        }        return string;//        return this.tabsToSpaces(string);    }
public String convertString(String string)    {        if (string != null)        {            int startTag = string.indexOf('<');            int endTag = string.indexOf('>');            if (startTag > -1)                if (endTag > startTag)            {                String tag = string.substring(startTag + 1, endTag);                boolean bDateField = tag.toUpperCase().contains("DATE");                if (eomFields != null)                {                    for (String token : eomFields)                    {                        if (tag.equals(token))                            bDateField = true;                    }                }                if (bDateField)                {                    int endData = string.indexOf('<', endTag);                    if (endData != -1)                    {                        String dateString = string.substring(endTag + 1, endData);                        Date date = new Date();                        int type = this.parseDate(dateString, date);                        if (type != 0)                        {                            Calendar calendar = Calendar.getInstance();                            calendar.setTime(date);                            if (yearOffset != 0)                            {                                calendar.add(Calendar.YEAR, yearOffset);                                                            }                            int day = 0;                            if (monthOffset != 0)                            {                                calendar.add(Calendar.DAY_OF_MONTH, 1);                                day = calendar.get(Calendar.DAY_OF_MONTH);  // Just want to see if this was the end of the month                                calendar.add(Calendar.DAY_OF_MONTH, -1);     // Restore original date                                calendar.add(Calendar.MONTH, monthOffset);  // Add the month offset                                if (eomFields != null)                                {                                    for (String token : eomFields)                                    {                                        if (tag.equals(token))                                        {                                            if (day == 1)                                            {   // end of (next) month                                                calendar.add(Calendar.DAY_OF_MONTH, 5);     // next month                                                calendar.set(Calendar.DAY_OF_MONTH, 1);     // First of next month                                                calendar.add(Calendar.DAY_OF_MONTH, -1);    // End of month                                            }                                        }                                    }                                }                            }                            if (dayOffset != 0)                            {                                calendar.add(Calendar.DAY_OF_MONTH, dayOffset);                                                            }                            date = calendar.getTime();                                                        String newDateString = this.formatDate(date, type);                            if (newDateString != null)                                string = string.substring(0, endTag + 1) + newDateString + string.substring(endData);                        }                    }                }            }        }        return super.convertString(string);    }
public String convertString(String string)    {        if (string.indexOf("<xsl:import") != -1)        {            int iStart = string.indexOf("href=\"") + 6;            int iEnd = string.indexOf('\"', iStart);            if (iStart != 5)                if (iEnd != -1)                {                    String strFilename = string.substring(iStart, iEnd);                                        m_writer.write("<!-- " + "Import inlined from: " + strFilename + " - Do not modify this generated file." + "-->");                    m_writer.println();                            this.writeImport(strFilename);                }            return null;        }        if (Boolean.FALSE.toString().equals(this.getProperty(ROOT_FILE)))        {            if (string.indexOf("xsl:stylesheet") != -1)                m_bSkipTag = true;            if (string.indexOf("<?xml version=") != -1)                m_bSkipTag = true;        //          if (string.indexOf("<xsl:output method=") != -1)        //              m_bSkipTag = true;        }        if (m_bSkipTag)        {            if (string.indexOf('>') != -1)                m_bSkipTag = false;            return null;        }        if (string.indexOf("<xsl:template ") != -1)        {            int iStart = string.indexOf("match=\"") + 7;            int iEnd = string.indexOf('\"', iStart);            if (iStart != 6)                if (iEnd != -1)                {                    String strMatch = string.substring(iStart, iEnd);                    if (m_parent instanceof XslImportScanListener)                        m_bSkipTemplate = ((XslImportScanListener)m_parent).isMatch(strMatch);                    if (!m_bSkipTemplate)                        if (m_parent instanceof XslImportScanListener)                            ((XslImportScanListener)m_parent).addMatch(strMatch, true);   // Make sure no one else adds it                    if (m_bSkipTemplate)                        System.out.println("Skip match " + strMatch);                        }                           iStart = string.indexOf("name=\"") + 6;            iEnd = string.indexOf('\"', iStart);            if (iStart != 5)                if (iEnd != -1)                {                    String strName = string.substring(iStart, iEnd);                    if (m_parent instanceof XslImportScanListener)                        m_bSkipTemplate = ((XslImportScanListener)m_parent).isName(strName);                    if (!m_bSkipTemplate)                        if (m_parent instanceof XslImportScanListener)                            ((XslImportScanListener)m_parent).addName(strName, true); // Make sure no one else adds it                    if (m_bSkipTemplate)                        System.out.println("Skip name " + strName);                }                       }        if (m_bSkipTemplate)        {            if (string.indexOf("</xsl:template>") != -1)                m_bSkipTemplate = false;            return null;        }        return string;    }
public String convertToString(Class<?> cls, Object object) {        if (object == null) {            return null;        }        StringConverter<Object> conv = findConverterNoGenerics(cls);        return conv.convertToString(object);    }
public String convertToString(Object object,Class<? extends Annotation> qualifier) {return BINDING.convertToString(object, qualifier);}
public <S> String convertToString(Class<S> input, Object object) {return binder.convertTo(input, String.class, object);}

priority queue
@Override    public boolean queue(IQueueMessage<ID, DATA> _msg) {        IQueueMessage<ID, DATA> msg = _msg.clone();        Date now = new Date();        msg.setNumRequeues(0).setQueueTimestamp(now).setTimestamp(now);        return putToQueue(msg);    }
@Override    public boolean queue(IQueueMessage<ID, DATA> _msg) {        IQueueMessage<ID, DATA> msg = _msg.clone();        Date now = new Date();        msg.setNumRequeues(0).setQueueTimestamp(now).setTimestamp(now);        try {            return putToQueue(msg, false);        } catch (RocksDBException e) {            throw new QueueException(e);        }    }
@SuppressWarnings("unchecked")  public T queue(Function... funcs) {    for (Element e : elements()) {      for (Function f : funcs) {        queue(e, DEFAULT_NAME, f);      }    }    return (T) this;  }
@SuppressWarnings("unchecked")  public T queue(String name, Queue<?> queue) {    for (Element e : elements()) {      replacequeue(e, name, queue);    }    return (T) this;  }
@SuppressWarnings("unchecked")  public T queue(final String name, Function... funcs) {    for (final Function f : funcs) {      for (Element e : elements()) {        queue(e, name, f);      }    }    return (T) this;  }
public int queue(String name) {    Queue<?> q = isEmpty() ? null : queue(get(0), name, null);    return q == null ? 0 : q.size();  }
public final void queue(BatchRequest batchRequest, BatchCallback<T, Void> callback)      throws IOException {    super.queue(batchRequest, Void.class, callback);  }
public void queue(final AsyncEvent<K> _event) {    final K key = _event.getKey();    synchronized (getLockObject(key)) {      Queue<AsyncEvent<K>> q = keyQueue.get(key);      if (q != null) {        q.add(_event);        return;      }      q = new LinkedList<AsyncEvent<K>>();      keyQueue.put(key, q);    }    Runnable r = new Runnable() {      @Override      public void run() {        runMoreOrStop(_event);      }    };    executor.execute(r);  }
public <T> void queue(StorageRequest<T> req, JsonBatchCallback<T> callback) throws IOException {    checkState(        !requestsExecutor.isShutdown() && !requestsExecutor.isTerminated(),        "requestsExecutor should not be terminated to queue batch requests");    if (maxRequestsPerBatch == 1) {      responseFutures.add(          requestsExecutor.submit(              () -> {                execute(req, callback);                return null;              }));    } else {      pendingRequests.add(batch -> req.queue(batch, callback));      flushIfPossibleAndRequired();    }  }
@Override    public boolean queue(IQueueMessage<ID, DATA> msg) {        if (msg == null) {            return false;        }        try {            try (Connection conn = jdbcHelper.getConnection()) {                return _queueWithRetries(conn, msg.clone(), 0, this.maxRetries);            }        } catch (Exception e) {            final String logMsg = "(queue) Exception [" + e.getClass().getName() + "]: "                    + e.getMessage();            LOGGER.error(logMsg, e);            throw e instanceof QueueException ? (QueueException) e : new QueueException(e);        }    }

string to date
public static Date stringToDate(String source, String format) throws ParseException {        if (StringUtils.isEmpty(source))            return null;        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(format);        return simpleDateFormat.parse(source);    }
public static Date stringTodate(String dateString, String format) throws ParseException {        final DateFormat dateFormat = new SimpleDateFormat(format, Locale.US);        return dateFormat.parse(dateString);    }
public static Date stringToDate(String strString, int ibScale) throws Exception    {        Date objData;        Exception except = null;        initGlobals();      // Make sure you have the utilities        if ((strString == null) || (strString.equals(Constant.BLANK)))            return null;        for (int i = 1; i <= 6; i++)        {            DateFormat df = null;            switch (i)            {            case 1:                df = gDateTimeFormat;break;            case 2:                df = gDateShortTimeFormat;break;            case 3:                df = gDateFormat;break;            case 4:                df = gDateShortFormat;break;            case 5:            default:                df = gTimeFormat;break;            case 6:                df= gGMTDateTimeFormat;break;            }            try   {                synchronized (gCalendar)                {                    objData = df.parse(strString);                    if (ibScale != -1)                    {                        DataConverters.gCalendar.setTime(objData);                        if (ibScale == Constant.DATE_ONLY)                        {                            DataConverters.gCalendar.set(Calendar.HOUR_OF_DAY, 0);                            DataConverters.gCalendar.set(Calendar.MINUTE, 0);                            DataConverters.gCalendar.set(Calendar.SECOND, 0);                            DataConverters.gCalendar.set(Calendar.MILLISECOND, 0);                        }                        if (ibScale == Constant.TIME_ONLY)                        {                            DataConverters.gCalendar.set(Calendar.YEAR, Constant.FIRST_YEAR);                            DataConverters.gCalendar.set(Calendar.MONTH, Calendar.JANUARY);                            DataConverters.gCalendar.set(Calendar.DATE, 1);                        }                        DataConverters.gCalendar.set(Calendar.MILLISECOND, 0);                        objData = DataConverters.gCalendar.getTime();                    }                }                return objData;            } catch (ParseException ex)   {                except = ex;                // continue with the next parse            }        }        if (except != null)            throw except;        return null;    }
public static Date stringToDate(String dateString) {        if (!"".equals(dateString) && dateString != null) {            // ISO_DATE_FORMAT = "yyyyMMdd";            if (dateString.trim().length() == 8) {                return stringToDate(dateString, ISO_DATE_FORMAT, LENIENT_DATE);            } else if (dateString.trim().length() == 10) {                // ISO_EXPANDED_DATE_FORMAT = "yyyy-MM-dd";                return stringToDate(dateString, ISO_EXPANDED_DATE_FORMAT,                        LENIENT_DATE);            } else if (dateString.trim().length() == 19) {                // DATETIME_PATTERN = "yyyy-MM-dd hh:mm:ss";                return stringToDate(dateString, DATETIME_PATTERN, LENIENT_DATE);            } else if (dateString.trim().length() == 11) {                // CHINESE_EXPANDED_DATE_FORMAT = "yyyy年MM月dd日";                return stringToDate(dateString, CHINESE_EXPANDED_DATE_FORMAT,                        LENIENT_DATE);            }        }        return null;    }
public static Date stringToDate(String dateString, String format) {        return stringToDate(dateString, format, LENIENT_DATE);    }
public static Date stringToDate(String dateText, String format,                                    boolean lenient) {        if (dateText == null) {            return null;        }        DateFormat df = null;        try {            if (format == null) {                df = new SimpleDateFormat();            } else {                df = new SimpleDateFormat(format);            }            // setLenient avoids allowing dates like 9/32/2001            // which would otherwise parse to 10/2/2001            df.setLenient(false);            return df.parse(dateText);        } catch (ParseException e) {            return null;        }    }
public static Date stringToDate(String strDate){Date dateLastBackup = null;if ((strDate != null) && (strDate.length() > 0)){try{dateLastBackup = DateFormat.getInstance().parse(strDate);} catch (ParseException ex){dateLastBackup = null;}}return dateLastBackup;    }
static public Date isoStringToDate(String iso) throws IllegalArgumentException {    CalendarDate dt = isoStringToCalendarDate(null, iso);  return dt.toDate();  }
public static Date dateStringToDate(String dateString){SimpleDateFormat sdf=new SimpleDateFormat(DateTimeKit.FULL_DATE_24HR_STYLE);Date date = null;try {date = sdf.parse(dateString);} catch (ParseException e) {}  return date;}
public static Date stringToCustomDateTime(SimpleDateFormat sdf, String datetime) throws ParseException {        return sdf.parse(datetime.trim());    }

sort string list
public static List<String> getSortedStringList(            Collection<String> stringCollection) {        return unmodifiableList(sort(new ArrayList<>(stringCollection)));    }
@Action(name = "List Sort",            outputs = {                    @Output(RESULT_TEXT),                    @Output(RESPONSE),                    @Output(RETURN_RESULT),                    @Output(RETURN_CODE)            },            responses = {                    @Response(text = SUCCESS, field = RETURN_CODE, value = RETURN_CODE_SUCCESS, matchType = MatchType.COMPARE_EQUAL),                    @Response(text = FAILURE, field = RETURN_CODE, value = RETURN_CODE_FAILURE, matchType = MatchType.COMPARE_EQUAL, isOnFail = true, isDefault = true)            })    public Map<String, String> sortList(@Param(value = LIST, required = true) String list,                                        @Param(value = DELIMITER, required = true) String delimiter,                                        @Param(value = REVERSE) String reverse) {        Map<String, String> result = new HashMap<>();        try {            String sortedList = sort(list, Boolean.parseBoolean(reverse), delimiter);            result.put(RESULT_TEXT, sortedList);            result.put(RESPONSE, SUCCESS);            result.put(RETURN_RESULT, sortedList);            result.put(RETURN_CODE, RETURN_CODE_SUCCESS);        } catch (Exception e) {            result.put(RESULT_TEXT, e.getMessage());            result.put(RESPONSE, FAILURE);            result.put(RETURN_RESULT, e.getMessage());            result.put(RETURN_CODE, RETURN_CODE_FAILURE);        }        return result;    }
private void sortList(ArrayList candidateList) {    java.util.Collections.sort(candidateList, new java.util.Comparator() {      public int compare(Object o1, Object o2) {        double scoreT = ( (TagLink.Candidates) o1).getScore();        double scoreU = ( (TagLink.Candidates) o2).getScore();        if(scoreU > scoreT){return 1;}        if(scoreU > scoreT){return -1;}return 0;      }    }    );  }
protected LinkedHashMap<String, String> getSortList() {        LinkedHashMap<String, String> list = new LinkedHashMap<String, String>();        list.put(SortParams.tree.name(), Messages.get().key(Messages.GUI_SORT_LABEL_HIERARCHIC_0));        list.put(SortParams.title_asc.name(), Messages.get().key(Messages.GUI_SORT_LABEL_TITLE_ASC_0));        list.put(SortParams.title_desc.name(), Messages.get().key(Messages.GUI_SORT_LABEL_TITLE_DECS_0));        list.put(SortParams.path_asc.name(), Messages.get().key(Messages.GUI_SORT_LABEL_PATH_ASC_0));        list.put(SortParams.path_desc.name(), Messages.get().key(Messages.GUI_SORT_LABEL_PATH_DESC_0));        return list;    }
public LinkedHashMap<String, String> getSortList() {        if (!m_controller.isShowSiteSelector() || !(m_controller.getVfsSiteSelectorOptions().size() > 1)) {            return null;        }        LinkedHashMap<String, String> options = new LinkedHashMap<String, String>();        for (CmsSiteSelectorOption option : m_controller.getVfsSiteSelectorOptions()) {            options.put(option.getSiteRoot(), option.getMessage());        }        return options;    }
private LinkedHashMap<String, String> getSortList(boolean includeType) {        LinkedHashMap<String, String> list = new LinkedHashMap<String, String>();        list.put(SortParams.title_asc.name(), Messages.get().key(Messages.GUI_SORT_LABEL_TITLE_ASC_0));        list.put(SortParams.title_desc.name(), Messages.get().key(Messages.GUI_SORT_LABEL_TITLE_DECS_0));        list.put(            SortParams.dateLastModified_asc.name(),            Messages.get().key(Messages.GUI_SORT_LABEL_DATELASTMODIFIED_ASC_0));        list.put(            SortParams.dateLastModified_desc.name(),            Messages.get().key(Messages.GUI_SORT_LABEL_DATELASTMODIFIED_DESC_0));        list.put(SortParams.path_asc.name(), Messages.get().key(Messages.GUI_SORT_LABEL_PATH_ASC_0));        list.put(SortParams.path_desc.name(), Messages.get().key(Messages.GUI_SORT_LABEL_PATH_DESC_0));        if (includeType) {            list.put(SortParams.type_asc.name(), Messages.get().key(Messages.GUI_SORT_LABEL_TYPE_ASC_0));            list.put(SortParams.type_desc.name(), Messages.get().key(Messages.GUI_SORT_LABEL_TYPE_DESC_0));        }        return list;    }
private boolean sortAceList(List<CmsAccessControlEntry> aces) {        // sort the list of entries        Collections.sort(aces, CmsAccessControlEntry.COMPARATOR_ACE);        // after sorting just the first 2 positions come in question        for (int i = 0; i < Math.min(aces.size(), 2); i++) {            CmsAccessControlEntry acEntry = aces.get(i);            if (acEntry.getPrincipal().equals(CmsAccessControlEntry.PRINCIPAL_OVERWRITE_ALL_ID)) {                return true;            }        }        return false;    }
public final List<T> toSortedList(final Class<? extends Comparable<?>> type,            final boolean lenient, final Object... path) {        return Ordering.from(new PathComparator(type, lenient, path)).immutableSortedCopy(                toCollection(Lists.<T>newArrayListWithCapacity(256)));    }
public final List<T> toSortedList(final Comparator<? super T> comparator) {        return Ordering.from(comparator).immutableSortedCopy(                toCollection(Lists.<T>newArrayListWithCapacity(256)));    }
@CheckReturnValue    @NonNull    public final Flowable<List<T>> toSortedList(@NonNull Comparator<? super T> comparator) {        return toSortedList(comparator, 16);    }

save list to file
public static File[] listFile(File director) {        String basePath = director.getAbsolutePath() + ValueConsts.SEPARATOR;        String[] filePath = director.list();        File[] files = null;        if (Checker.isNotNull(filePath)) {            files = new File[filePath.length];            int i = 0;            for (String s : filePath) {                files[i++] = new File(basePath + s);            }        }        return files;    }
public SmbFile[] listFiles( SmbFilenameFilter filter ) throws SmbException {        return listFiles( "*", ATTR_DIRECTORY | ATTR_HIDDEN | ATTR_SYSTEM, filter, null );    }
public SmbFile[] listFiles( String wildcard ) throws SmbException {        return listFiles( wildcard, ATTR_DIRECTORY | ATTR_HIDDEN | ATTR_SYSTEM, null, null );    }
public static ImmutableList<Path> listFiles(Path dir) throws IOException {    try (DirectoryStream<Path> stream = Files.newDirectoryStream(dir)) {      return ImmutableList.copyOf(stream);    } catch (DirectoryIteratorException e) {      throw e.getCause();    }  }
public List<F> listFiles(NfsFileFilter filter) throws IOException {        List<F> childFiles = listFiles();        if ((childFiles == null) || (childFiles.size() == 0) || (filter == null)) {            return childFiles;        }        List<F> filteredFiles = new ArrayList<F>();        for (F childFile : childFiles) {            if (filter.accept(childFile)) {                filteredFiles.add(childFile);            }        }        return filteredFiles;    }
public static List<File> listFiles(File[] directories, IOFileFilter fileFilter, IOFileFilter dirFilter) {        List<File> files = new ArrayList<>();        for (File directory : directories) {            if (!directory.isDirectory()) {                continue;            }            Collection<File> filesInDirectory = FileUtils.listFiles(directory,                    fileFilter,                    dirFilter);            files.addAll(filesInDirectory);        }        return files;    }
public File[] listFiles(FileFilter filter) {        File[] files = listFiles();        if (filter == null || files == null) {            return files;        }        List<File> result = new ArrayList<File>(files.length);        for (File file : files) {            if (filter.accept(file)) {                result.add(file);            }        }        return result.toArray(new File[result.size()]);    }
@NullSafe  public static File[] listFiles(File directory, FileFilter fileFilter) {    List<File> files = new ArrayList<>();    for (File file : safeListFiles(directory, fileFilter)) {      files.addAll(isDirectory(file) ? Arrays.asList(listFiles(file, fileFilter)) : Collections.singletonList(file));    }    return (files.isEmpty() ? NO_FILES : files.toArray(new File[files.size()]));  }
public static List<File> listFiles(File srcPath) throws IOException   {      List<File> result = new ArrayList<File>();      if (!srcPath.isDirectory())      {         throw new IOException(srcPath.getAbsolutePath() + " is a directory");      }      for (File subFile : srcPath.listFiles())      {         result.add(subFile);         if (subFile.isDirectory())         {            result.addAll(listFiles(subFile));         }      }      return result;   }
public File[] listFiles(FileFilter filter) {        List ret = new LinkedList();        Iterator it = this.childs.iterator();        File next;        while (it.hasNext()) {            next = (File)it.next();            if (filter.accept(next)) {                ret.add(next);            }        }        return (File[])ret.toArray(new File[ret.size()]);    }

postgresql connection # 遗漏关键词
public Link connect(int id, int bandwidth, Switch sw, PhysicalElement pe) {        // Create a new link with a specific id        Link link = lnBuilder.newLink(id, bandwidth, sw, pe);        links.add(link);        return link;    }
public List<Link> connect(int bandwidth, Switch sw, List<? extends PhysicalElement> pelts) {        return pelts.stream().map(pe -> connect(bandwidth, sw, pe)).collect(Collectors.toList());    }
public List<Link> connect(int bandwidth, Switch sw, Node... nodes) {        List<Link> l = new ArrayList<>();        for (Node n : nodes) {            l.add(connect(bandwidth, sw, n));        }        return l;    }
public List<Link> connect(int bandwidth, Switch sw, PhysicalElement... pelts) {        List<Link> l = new ArrayList<>();        for (PhysicalElement pe : pelts) {            l.add(connect(bandwidth, sw, pe));        }        return l;    }
public void connect(IConnection conn) {        if (conn instanceof RTMPConnection) {            if (!isConnected()) {                source = conn;                SharedObjectMessage msg = new SharedObjectMessage(name, 0, isPersistent());                msg.addEvent(new SharedObjectEvent(Type.SERVER_CONNECT, null, null));                Channel c = ((RTMPConnection) conn).getChannel(3);                c.write(msg);            } else {                throw new UnsupportedOperationException("Already connected");            }        } else {            throw new UnsupportedOperationException("Only RTMP connections are supported");        }    }
private void connect(CompletableFuture<Connection> future) {    if (!selector.hasNext()) {      LOGGER.debug("{} - Failed to connect to the cluster", id);      future.complete(null);    } else {      Address address = selector.next();      LOGGER.debug("{} - Connecting to {}", id, address);      client.connect(address).whenComplete((c, e) -> handleConnection(address, c, e, future));    }  }
private CompletableFuture<Connection> connect() {    // If the address selector has been reset then reset the connection.    if (selector.state() == AddressSelector.State.RESET && connection != null) {      if (connectFuture != null) {        return connectFuture;      }      CompletableFuture<Connection> future = new OrderedCompletableFuture<>();      future.whenComplete((r, e) -> this.connectFuture = null);      this.connectFuture = future;      Connection oldConnection = this.connection;      this.connection = null;      oldConnection.close();      connect(future);      return future;    }    // If a connection was already established then use that connection.    if (connection != null) {      return CompletableFuture.completedFuture(connection);    }    // If a connection is currently being established then piggyback on the connect future.    if (connectFuture != null) {      return connectFuture;    }    // Create a new connect future and connect to the first server in the cluster.    CompletableFuture<Connection> future = new OrderedCompletableFuture<>();    future.whenComplete((r, e) -> this.connectFuture = null);    this.connectFuture = future;    reset().connect(future);    return future;  }
@Given("^I( securely)? connect to '(Cassandra|Mongo|Elasticsearch)' cluster at '(.+)'$")    public void connect(String secured, String clusterType, String url) throws DBException, UnknownHostException {        switch (clusterType) {            case "Cassandra":                commonspec.getCassandraClient().setHost(url);                commonspec.getCassandraClient().connect(secured);                break;            case "Mongo":                commonspec.getMongoDBClient().connect();                break;            case "Elasticsearch":                LinkedHashMap<String, Object> settings_map = new LinkedHashMap<String, Object>();                settings_map.put("cluster.name", System.getProperty("ES_CLUSTER", ES_DEFAULT_CLUSTER_NAME));                commonspec.getElasticSearchClient().setSettings(settings_map);                commonspec.getElasticSearchClient().connect();                break;            default:                throw new DBException("Unknown cluster type");        }    }
public void connect (int timeout, InetAddress host, int tcpPort) throws IOException {connect(timeout, host, tcpPort, -1);}
public void connect (int timeout, InetAddress host, int tcpPort, int udpPort) throws IOException {if (host == null) throw new IllegalArgumentException("host cannot be null.");if (Thread.currentThread() == getUpdateThread())throw new IllegalStateException("Cannot connect on the connection's update thread.");this.connectTimeout = timeout;this.connectHost = host;this.connectTcpPort = tcpPort;this.connectUdpPort = udpPort;close();if (INFO) {if (udpPort != -1)info("kryonet", "Connecting: " + host + ":" + tcpPort + "/" + udpPort);elseinfo("kryonet", "Connecting: " + host + ":" + tcpPort);}id = -1;try {if (udpPort != -1) udp = new UdpConnection(serialization, tcp.readBuffer.capacity());long endTime;synchronized (updateLock) {tcpRegistered = false;selector.wakeup();endTime = System.currentTimeMillis() + timeout;tcp.connect(selector, new InetSocketAddress(host, tcpPort), 5000);}// Wait for RegisterTCP.synchronized (tcpRegistrationLock) {while (!tcpRegistered && System.currentTimeMillis() < endTime) {try {tcpRegistrationLock.wait(100);} catch (InterruptedException ignored) {}}if (!tcpRegistered) {throw new SocketTimeoutException("Connected, but timed out during TCP registration.\n"+ "Note: Client#update must be called in a separate thread during connect.");}}if (udpPort != -1) {InetSocketAddress udpAddress = new InetSocketAddress(host, udpPort);synchronized (updateLock) {udpRegistered = false;selector.wakeup();udp.connect(selector, udpAddress);}// Wait for RegisterUDP reply.synchronized (udpRegistrationLock) {while (!udpRegistered && System.currentTimeMillis() < endTime) {RegisterUDP registerUDP = new RegisterUDP();registerUDP.connectionID = id;udp.send(this, registerUDP, udpAddress);try {udpRegistrationLock.wait(100);} catch (InterruptedException ignored) {}}if (!udpRegistered)throw new SocketTimeoutException("Connected, but timed out during UDP registration: " + host + ":" + udpPort);}}} catch (IOException ex) {close();throw ex;}}

confusion matrix
public String confusionMatrix(){        int nClasses = numClasses();        if(confusion == null){            return "Confusion matrix: <no data>";        }        //First: work out the maximum count        List<Integer> classes = confusion.getClasses();        int maxCount = 1;        for (Integer i : classes) {            for (Integer j : classes) {                int count = confusion().getCount(i, j);                maxCount = Math.max(maxCount, count);            }        }        maxCount = Math.max(maxCount, nClasses);    //Include this as header might be bigger than actual values        int numDigits = (int)Math.ceil(Math.log10(maxCount));        if(numDigits < 1)            numDigits = 1;        String digitFormat = "%" + (numDigits+1) + "d";        StringBuilder sb = new StringBuilder();        //Build header:        for( int i=0; i<nClasses; i++ ){            sb.append(String.format(digitFormat, i));        }        sb.append("\n");        int numDividerChars = (numDigits+1) * nClasses + 1;        for( int i=0; i<numDividerChars; i++ ){            sb.append("-");        }        sb.append("\n");        //Build each row:        for( int actual=0; actual<nClasses; actual++){            String actualName = resolveLabelForClass(actual);            for( int predicted=0; predicted<nClasses; predicted++){                int count = confusion.getCount(actual, predicted);                sb.append(String.format(digitFormat, count));            }            sb.append(" | ").append(actual).append(" = ").append(actualName).append("\n");        }        sb.append("\nConfusion matrix format: Actual (rowClass) predicted as (columnClass) N times");        return sb.toString();    }
public SDVariable confusionMatrix(String name, SDVariable labels, SDVariable pred, DataType dataType) {        validateInteger("confusionMatrix", "labels", labels);        validateInteger("confusionMatrix", "prediction", pred);        SDVariable result = f().confusionMatrix(labels, pred, dataType);        return updateVariableNameAndReference(result, name);    }
public SDVariable confusionMatrix(String name, SDVariable labels, SDVariable pred, Integer numClasses) {        validateInteger("confusionMatrix", "labels", labels);        validateInteger("confusionMatrix", "prediction", pred);        SDVariable result = f().confusionMatrix(labels, pred, numClasses);        return updateVariableNameAndReference(result, name);    }
public float[] matrix() {float[] matrix = new float[8];float cosX = (float) Math.cos(rotationRadians);float sinX = (float) Math.sin(rotationRadians);matrix[AX] = plainWidth * cosX;matrix[AY] = plainWidth * sinX;matrix[BX] = (-plainHeight) * sinX;matrix[BY] = plainHeight * cosX;if (rotationRadians < Math.PI / 2f) {matrix[CX] = matrix[BX];matrix[CY] = 0;matrix[DX] = matrix[AX];matrix[DY] = matrix[AY] + matrix[BY];} else if (rotationRadians < Math.PI) {matrix[CX] = matrix[AX] + matrix[BX];matrix[CY] = matrix[BY];matrix[DX] = 0;matrix[DY] = matrix[AY];} else if (rotationRadians < Math.PI * 1.5f) {matrix[CX] = matrix[AX];matrix[CY] = matrix[AY] + matrix[BY];matrix[DX] = matrix[BX];matrix[DY] = 0;} else {matrix[CX] = 0;matrix[CY] = matrix[AY];matrix[DX] = matrix[AX] + matrix[BX];matrix[DY] = matrix[BY];}return matrix;}
public static DenseMatrix matrix(double[] A) {        if (nlmatrixZeros != null) {            try {                return (DenseMatrix) nlmatrixArray.newInstance(A);            } catch (Exception e) {                logger.error("Failed to call NLMatrix(double[]): {}", e);            }        }        return new JMatrix(A);    }
public static DenseMatrix matrix(double[][] A) {        if (nlmatrixZeros != null) {            try {                return (DenseMatrix) nlmatrixArray2D.newInstance((Object) A);            } catch (Exception e) {                logger.error("Failed to call NLMatrix(double[][]): {}", e);            }        }        return new JMatrix(A);    }
public static DenseMatrix matrix(int nrows, int ncols, double value) {        if (nlmatrixOnes != null) {            try {                return (DenseMatrix) nlmatrixOnes.newInstance(nrows, ncols, value);            } catch (Exception e) {                logger.error("Failed to call NLMatrix(int, int, double): {}", e);            }        }        return new JMatrix(nrows, ncols, value);    }
public static DenseMatrix matrix(int nrows, int ncols) {        if (nlmatrixZeros != null) {            try {                return (DenseMatrix) nlmatrixZeros.newInstance(nrows, ncols);            } catch (Exception e) {                logger.error("Failed to call NLMatrix(int, int): {}", e);            }        }        return new JMatrix(nrows, ncols);    }
@GET  @Path("search/matrix")  @Produces("text/plain")  public StreamingOutput matrix(    final @QueryParam("q") String query,    final @QueryParam("corpora") String rawCorpusNames,    @QueryParam("metakeys") String rawMetaKeys,    @DefaultValue("false") @QueryParam("csv") String rawCsv)  {    requiredParameter(query, "q", "AnnisQL query");    requiredParameter(rawCorpusNames, "corpora",      "comma separated list of corpus names");    final boolean outputCsv = Boolean.parseBoolean(rawCsv);        Subject user = SecurityUtils.getSubject();    List<String> corpusNames = splitCorpusNamesFromRaw(rawCorpusNames);    for (String c : corpusNames)    {      user.checkPermission("query:matrix:" + c);    }    final QueryData data = queryDataFromParameters(query, rawCorpusNames);    MatrixQueryData ext = new MatrixQueryData();    if(rawMetaKeys != null)    {      ext.setMetaKeys(splitMatrixKeysFromRaw(rawMetaKeys));    }    if(ext.getMetaKeys() != null && ext.getMetaKeys().isEmpty())    {      ext.setMetaKeys(null);    }    data.addExtension(ext);    StreamingOutput result = new StreamingOutput()    {      @Override      public void write(OutputStream output) throws IOException, WebApplicationException      {        long start = new Date().getTime();        queryDao.matrix(data, outputCsv, output);        long end = new Date().getTime();        logQuery("MATRIX", query, splitCorpusNamesFromRaw(rawCorpusNames),          end - start);      }    };    return result;  }
public Confusion getConfusionMatrixAtThreshold(double threshold) {        Point p = getPointAtThreshold(threshold);        int idx = p.idx;        int tn = totalCount - (tpCount[idx] + fpCount[idx] + fnCount[idx]);        return new Confusion(p, tpCount[idx], fpCount[idx], fnCount[idx], tn);    }

set working directory
public static String setDirectories(String content, String[] rules) {        // get translation rules        for (int i = 0; i < rules.length; i++) {            String actRule = rules[i];            // cut String "/default/vfs/" from rule            actRule = CmsStringUtil.substitute(actRule, "/default/vfs", "");            // divide rule into search and replace parts and delete regular expressions            StringTokenizer ruleT = new StringTokenizer(actRule, "#");            ruleT.nextToken();            String search = ruleT.nextToken();            int pos = search.lastIndexOf("(.*)");            if (pos >= 0) {                search = search.substring(0, pos);            }            String replace = ruleT.nextToken();            if (pos >= 0) {                replace = replace.substring(0, replace.lastIndexOf("$1"));            }            // scan content for paths if the replace String is not present            if ((content.indexOf(replace) == -1) && (content.indexOf(search) != -1)) {                // ensure subdirectories of the same name are not replaced                search = "([}>\"'\\[]\\s*)" + search;                replace = "$1" + replace;                content = CmsStringUtil.substitutePerl(content, search, replace, "g");            }        }        return content;    }
public void setDirectories(java.util.Collection<Directory> directories) {        if (directories == null) {            this.directories = null;            return;        }        this.directories = new java.util.ArrayList<Directory>(directories);    }
@Nonnullpublic static String[] parseTempDirectories(Configuration configuration) {return splitPaths(configuration.getString(CoreOptions.TMP_DIRS));}
public synchronized void setStorageDirectories(Collection<URI> fsNameDirs,                                          Collection<URI> fsEditsDirs,                                          Map<URI, NNStorageLocation> locationMap)      throws IOException {        this.storageDirs.clear();    this.removedStorageDirs.clear();    for (URI dirName : fsNameDirs) {      boolean isAlsoEdits = false;      for (URI editsDirName : fsEditsDirs) {        if (editsDirName.compareTo(dirName) == 0) {          isAlsoEdits = true;          fsEditsDirs.remove(editsDirName);          break;        }      }      NameNodeDirType dirType = (isAlsoEdits) ?                          NameNodeDirType.IMAGE_AND_EDITS :                          NameNodeDirType.IMAGE;      // Add to the list of storage directories, only if the      // URI is of type file://      if (dirName.getScheme().compareTo(JournalType.FILE.name().toLowerCase()) == 0) {        this.addStorageDir(new NNStorageDirectory(new File(dirName.getPath()),            dirType, locationMap == null ? null : locationMap.get(dirName)));      }    }        // Add edits dirs if they are different from name dirs    for (URI dirName : fsEditsDirs) {      checkSchemeConsistency(dirName);      // Add to the list of storage directories, only if the      // URI is of type file://      if (dirName.getScheme().compareTo(JournalType.FILE.name().toLowerCase()) == 0)        this.addStorageDir(new NNStorageDirectory(new File(dirName.getPath()),            NameNodeDirType.EDITS, locationMap == null ? null : locationMap.get(dirName)));    }  }
public static <A> Set<A> set(A... elements) {        final Set<A> set = new HashSet<A>(elements.length);        for (A element : elements) {            set.add(element);        }        return set;    }
public DataSetBuilder set(String column, ColumnFiller<?> filler) {    ensureArgNotNull(column);    ensureArgNotNull(filler);    if (! data.getSource().getDB().isEnabled(DB.Option.CASE_SENSITIVE_COLUMN_NAMES)) {      column = column.toUpperCase();    }    Integer idx = columnIdx.get(column);    if (idx == null) {      throw new InvalidOperationException("Invalid column name: '" + column + "'.");    }    if (fillers[idx] == null) {      fillerCount ++;    }    fillers[idx] = filler;    return this;  }
public Object set(String key, Object value) {        int idx = keys.indexOf(key);        if (idx == -1) {            keys.add(key);            values.add(value);            return null;        }        return values.set(idx, value);    }
public SqlKit set(Object... columnsValues) {int len = columnsValues.length;if (len % 2 != 0) {throw new IllegalArgumentException("wrong number of arguments for set, columnsValues length can not be odd");}sql.append(SqlKit.set).append(SqlKit.sapce);StringBuilder column = null;for (int index = 0; index < len; index++) {column = new StringBuilder();if (index % 2 == 0) {column.append(columnsValues[index]).append(SqlKit.sapce).append("=");} else {column.append(columnsValues[index]);if (index != len - 1) {column.append(",");}}sql.append(column).append(SqlKit.sapce);}return this;}
@Override    public void set(String key, Object entry, long expireAfterWrite, long expireAfterAccess) {        long ttl = TTL_NO_CHANGE;        if (!(entry instanceof CacheEntry)) {            CacheEntry ce = new CacheEntry(key, entry, expireAfterWrite, expireAfterAccess);            entry = ce;            ttl = expireAfterAccess > 0 ? expireAfterAccess                    : (expireAfterWrite > 0 ? expireAfterWrite                            : (timeToLiveSeconds > 0 ? timeToLiveSeconds : 0));        } else {            CacheEntry ce = (CacheEntry) entry;            ttl = ce.getExpireAfterAccess();        }        byte[] _data = serializeCacheEntry((CacheEntry) entry);        String data = Base64.encodeBase64String(_data);        final int TTL = (int) ttl;        switch (keyMode) {        case MONOPOLISTIC:        case NAMESPACE: {            final String KEY = keyMode == KeyMode.MONOPOLISTIC ? key : calcCacheKeyNamespace(key);            try {                getMemcachedClient().set(KEY, TTL, data);            } catch (Exception e) {                throw e instanceof CacheException ? (CacheException) e : new CacheException(e);            }            break;        }        case XNAMESPACE: {            try {                getMemcachedClient().withNamespace(getName(), new MemcachedClientCallable<Void>() {                    @Override                    public Void call(MemcachedClient client)                            throws MemcachedException, InterruptedException, TimeoutException {                        client.set(key, TTL, data);                        return null;                    }                });            } catch (Exception e) {                throw e instanceof CacheException ? (CacheException) e : new CacheException(e);            }            break;        }        default:            throw new IllegalStateException("Invalid key mode: " + keyMode);        }    }
@Override    public void set(String key, Object entry) {        if (entry instanceof CacheEntry) {            CacheEntry ce = (CacheEntry) entry;            set(key, ce, ce.getExpireAfterWrite(), ce.getExpireAfterAccess());        } else {            set(key, entry, getExpireAfterWrite(), getExpireAfterAccess());        }    }

group by count
public int activeGroupCount() {        int ngroupsSnapshot;        ThreadGroup[] groupsSnapshot;        synchronized (this) {            if (destroyed) {                return 0;            }            ngroupsSnapshot = ngroups;            if (groups != null) {                groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);            } else {                groupsSnapshot = null;            }        }        int n = ngroupsSnapshot;        for (int i = 0 ; i < ngroupsSnapshot ; i++) {            n += groupsSnapshot[i].activeGroupCount();        }        return n;    }
public void populateGroupsLegendByTargetCounts(final List<Long> listOfTargetCountPerGroup) {        loadingLabel.setVisible(false);        for (int i = 0; i < getGroupsWithoutToBeContinuedLabel(listOfTargetCountPerGroup.size()); i++) {            final Component component = groupsLegend.getComponent(i);            final Label label = (Label) component;            if (listOfTargetCountPerGroup.size() > i) {                final Long targetCount = listOfTargetCountPerGroup.get(i);                label.setValue(getTargetsInGroupMessage(targetCount,                        i18n.getMessage("textfield.rollout.group.default.name", i + 1)));                label.setVisible(true);            } else {                label.setValue("");                label.setVisible(false);            }        }        showOrHideToBeContinueLabel(listOfTargetCountPerGroup);        unassignedTargetsLabel.setValue("");        unassignedTargetsLabel.setVisible(false);    }
public GroupResult group(List<UUID> faceIds) {        return groupWithServiceResponseAsync(faceIds).toBlocking().single().body();    }
public static <E> Stream<Stream<E>> group(Stream<E> stream, Predicate<? super E> open, Predicate<? super E> close) {        Objects.requireNonNull(stream);        Objects.requireNonNull(open);        Objects.requireNonNull(close);        return group(stream, open, true, close, true);    }
public static <E> Stream<Stream<E>> group(Stream<E> stream, Predicate<? super E> splitter) {        Objects.requireNonNull(stream);        Objects.requireNonNull(splitter);        return group(stream, splitter, true);    }
public static <E> Stream<Stream<E>> group(Stream<E> stream, Predicate<? super E> splitter, boolean included) {        Objects.requireNonNull(stream);        Objects.requireNonNull(splitter);        GroupingOnSplittingSpliterator<E> spliterator = GroupingOnSplittingSpliterator.of(stream.spliterator(), splitter, included);        return StreamSupport.stream(spliterator, stream.isParallel()).onClose(stream::close);    }
public static <E> Stream<Stream<E>> group(            Stream<E> stream,            Predicate<? super E> open, boolean openingElementIncluded,            Predicate<? super E> close, boolean closingElementIncluded) {        Objects.requireNonNull(stream);        Objects.requireNonNull(open);        Objects.requireNonNull(close);        GroupingOnGatingSpliterator<E> spliterator = GroupingOnGatingSpliterator.of(stream.spliterator(), open, openingElementIncluded, close, closingElementIncluded);        return StreamSupport.stream(spliterator, stream.isParallel()).onClose(stream::close);    }
public static <E> Stream<Stream<E>> group(Stream<E> stream, int groupingFactor) {        Objects.requireNonNull(stream);        GroupingSpliterator<E> spliterator = GroupingSpliterator.of(stream.spliterator(), groupingFactor);        return StreamSupport.stream(spliterator, stream.isParallel()).onClose(stream::close);    }
public static Resource.Provider group(Resource.Provider... providers) {        return group(() -> Arrays.stream(providers));    }
@Override    public GroupDef group(String name) {        return new GroupDefImpl(getDescriptorName(), model, model.getOrCreate("group@qualifier=" + name));    }

binomial distribution
public void setBinomialDistribution(BinomialDistributionType newBinomialDistribution) {((FeatureMap.Internal)getMixed()).set(BpsimPackage.Literals.DOCUMENT_ROOT__BINOMIAL_DISTRIBUTION, newBinomialDistribution);}
public NotificationChain basicSetBinomialDistribution(BinomialDistributionType newBinomialDistribution, NotificationChain msgs) {return ((FeatureMap.Internal)getMixed()).basicAdd(BpsimPackage.Literals.DOCUMENT_ROOT__BINOMIAL_DISTRIBUTION, newBinomialDistribution, msgs);}
public static void distribute(Object obj, String fileName, Configuration conf) throws FileNotFoundException,      IOException, URISyntaxException {    FileSystem fS = FileSystem.get(conf);    // set the temporary folder for Pangool instances to the temporary of the    // user that is running the Job    // This folder will be used across the cluster for location the instances.    // The default value can be changed by a user-provided one.    String tmpHdfsFolder = getInstancesFolder(fS, conf);    Path toHdfs = new Path(tmpHdfsFolder, fileName);    if (fS.exists(toHdfs)) { // Optionally, copy to DFS if      fS.delete(toHdfs, false);    }    ObjectOutput out = new ObjectOutputStream(fS.create(toHdfs));    out.writeObject(obj);    out.close();    DistributedCache.addCacheFile(toHdfs.toUri(), conf);  }
public boolean distribute(@NonNull File reportFile) {        ACRA.log.i(LOG_TAG, "Sending report " + reportFile);        try {            final CrashReportPersister persister = new CrashReportPersister();            final CrashReportData previousCrashReport = persister.load(reportFile);            sendCrashReport(previousCrashReport);            IOUtils.deleteFile(reportFile);            return true;        } catch (RuntimeException e) {            ACRA.log.e(LOG_TAG, "Failed to send crash reports for " + reportFile, e);            IOUtils.deleteFile(reportFile);        } catch (IOException e) {            ACRA.log.e(LOG_TAG, "Failed to load crash report for " + reportFile, e);            IOUtils.deleteFile(reportFile);        } catch (JSONException e) {            ACRA.log.e(LOG_TAG, "Failed to load crash report for " + reportFile, e);            IOUtils.deleteFile(reportFile);        } catch (ReportSenderException e) {            ACRA.log.e(LOG_TAG, "Failed to send crash report for " + reportFile, e);            // An issue occurred while sending this report but we can still try to            // send other reports. Report sending is limited by ACRAConstants.MAX_SEND_REPORTS            // so there's not much to fear about overloading a failing server.        }        return false;    }
public void distribute(CmsObject cms, List<I_CmsNewsletterRecipient> recipients, I_CmsNewsletter newsletter) {        Iterator<I_CmsNewsletterRecipient> recipientsIterator = recipients.iterator();        while (recipientsIterator.hasNext()) {            I_CmsNewsletterRecipient recipient = recipientsIterator.next();            try {                Email mail = newsletter.getEmail(cms, recipient);                mail.addTo(recipient.getEmail(), recipient.getFullName());                mail.send();            } catch (Exception e) {                LOG.error(e.getMessage(), e);            }        }    }
public void distribute(ProcessorListener.Notification<ApiType> obj, boolean isSync) {    lock.readLock().lock();    try {      if (isSync) {        for (ProcessorListener<ApiType> listener : syncingListeners) {          listener.add(obj);        }      } else {        for (ProcessorListener<ApiType> listener : listeners) {          listener.add(obj);        }      }    } finally {      lock.readLock().unlock();    }  }
void distributeOr() {        if (opType != OpTypes.OR) {            return;        }        if (nodes[LEFT].opType == OpTypes.AND) {            opType = OpTypes.AND;            Expression temp = new ExpressionLogical(OpTypes.OR,                nodes[LEFT].nodes[RIGHT], nodes[RIGHT]);            nodes[LEFT].opType       = OpTypes.OR;            nodes[LEFT].nodes[RIGHT] = nodes[RIGHT];            nodes[RIGHT]             = temp;        } else if (nodes[RIGHT].opType == OpTypes.AND) {            Expression temp = nodes[LEFT];            nodes[LEFT]  = nodes[RIGHT];            nodes[RIGHT] = temp;            distributeOr();            return;        }        ((ExpressionLogical) nodes[LEFT]).distributeOr();        ((ExpressionLogical) nodes[RIGHT]).distributeOr();    }
protected boolean distributeEnd() throws SystemException {        if (tc.isEntryEnabled())            Tr.entry(tc, "distributeEnd");        if (!getResources().distributeEnd(XAResource.TMSUCCESS)) {            setRBO();        }        if (_rollbackOnly) {            try {                _status.setState(TransactionState.STATE_ROLLING_BACK);            } catch (SystemException se) {                FFDCFilter.processException(se, "com.ibm.tx.jta.TransactionImpl.distributeEnd", "1731", this);                if (tc.isEntryEnabled())                    Tr.exit(tc, "distributeEnd", se);                throw se;            }        }        if (tc.isEntryEnabled())            Tr.exit(tc, "distributeEnd", !_rollbackOnly);        return !_rollbackOnly;    }
public boolean distributeEnd(int flags) {        if (tc.isEntryEnabled())            Tr.entry(tc, "distributeEnd", Util.printFlag(flags));        boolean result = true;        for (int i = _resourceObjects.size(); --i >= 0;) {            final JTAResource resource = _resourceObjects.get(i);            if (!sendEnd(resource, flags)) {                result = false;            }        }        if (_sameRMResource != null) {            if (!sendEnd(_sameRMResource, flags)) {                result = false;            }        }        if (tc.isEntryEnabled())            Tr.exit(tc, "distributeEnd", result);        return result;    }
public static void distributeShare(      double total, final Collection<? extends Schedulable> schedulables,      ScheduleComparator comparator) {    switch (comparator) {    case FIFO:    case DEADLINE:      Schedulable.distributeShareSorted(total, schedulables, comparator);      break;    case FAIR:      Schedulable.distributeShareFair(total, schedulables);      break;    case PRIORITY:      Schedulable.distributeSharePriority(total, schedulables);      break;    default:      throw new IllegalArgumentException("Unknown comparator");    }  }

aes encryption
private static String aesEncrypt(String content, String aesKey, String charset)                                                                                   throws AlipayApiException {        try {            Cipher cipher = Cipher.getInstance(AES_CBC_PCK_ALG);            IvParameterSpec iv = new IvParameterSpec(AES_IV);            cipher.init(Cipher.ENCRYPT_MODE,                new SecretKeySpec(Base64.decodeBase64(aesKey.getBytes()), AES_ALG), iv);            byte[] encryptBytes = cipher.doFinal(content.getBytes(charset));            return new String(Base64.encodeBase64(encryptBytes));        } catch (Exception e) {            throw new AlipayApiException("AES加密失败：Aescontent = " + content + "; charset = "                                         + charset, e);        }    }
public void doAESEncryption() throws Exception{if(!initAESDone)initAES();cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");//System.out.println(secretKey.getEncoded());cipher.init(Cipher.ENCRYPT_MODE, secretKey);AlgorithmParameters params = cipher.getParameters();iv = params.getParameterSpec(IvParameterSpec.class).getIV();secretCipher = cipher.doFinal(secretPlain);clearPlain();}
public static byte[] AesEncryptToBytes(byte[] content,byte[] encryptKey) throws Exception {KeyGenerator kgen = KeyGenerator.getInstance("AES");SecureRandom secureRandom = SecureRandom.getInstance("SHA1PRNG");secureRandom.setSeed(encryptKey);kgen.init(128,secureRandom);Cipher cipher = Cipher.getInstance("AES");cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(kgen.generateKey().getEncoded(), "AES"));return cipher.doFinal(content);}
public static String encrypt(String key, String content)    {        try        {            return ByteUtilities.encode(createAesEncryptionCipher(key).doFinal(content.getBytes(StandardCharsets.UTF_8)));        }        catch (Exception e)        {            throw new IllegalStateException("Error occurred encrypting data", e);        }    }
@Override    public String encrypt(String keyId, String str) throws EncryptException {        if (str == null) {            return null;        }        try {            initCiphers();            byte[] cleartext = str.getBytes("UTF-8");            byte[] ciphertext = this.encryptCipher.doFinal(cleartext);            return Base64.encodeBase64String(ciphertext);        } catch (InvalidKeyException ex) {            throw new AssertionError(ex);        } catch (BadPaddingException | NoSuchPaddingException | IllegalBlockSizeException | NoSuchAlgorithmException ex) {            throw new EncryptException("Could not encrypt string", ex);        } catch (UnsupportedEncodingException ex) {            throw new AssertionError("UTF-8 should be supported but is not");        }    }
@SuppressWarnings("PMD.LawOfDemeter")    public byte[] encrypt(final byte[] payload, final IvParameterSpec initializationVector) {        final SecretKeySpec encryptionKeySpec = getEncryptionKeySpec();        try {            final Cipher cipher = Cipher.getInstance(cipherTransformation);            cipher.init(ENCRYPT_MODE, encryptionKeySpec, initializationVector);            return cipher.doFinal(payload);        } catch (final NoSuchAlgorithmException | NoSuchPaddingException e) {            // these should not happen as we use an algorithm (AES) and padding (PKCS5) that are guaranteed to exist            throw new IllegalStateException("Unable to access cipher " + cipherTransformation + ": " + e.getMessage(), e);        } catch (final InvalidKeyException | InvalidAlgorithmParameterException e) {            // this should not happen as the key is validated ahead of time and            // we use an algorithm guaranteed to exist            throw new IllegalStateException(                    "Unable to initialise encryption cipher with algorithm " + encryptionKeySpec.getAlgorithm()                            + " and format " + encryptionKeySpec.getFormat() + ": " + e.getMessage(),                    e);        } catch (final IllegalBlockSizeException | BadPaddingException e) {            // these should not happen as we control the block size and padding            throw new IllegalStateException("Unable to encrypt data: " + e.getMessage(), e);        }    }
public static void encrypt(Path path, InputStream publicKeyStream, OutputStream targetStream) throws Exception {        PGPPublicKey publicKey = getPublicKey(publicKeyStream);        try(ByteArrayOutputStream compressed = new ByteArrayOutputStream();            ArmoredOutputStream armOut = new ArmoredOutputStream(targetStream)) {            PGPCompressedDataGenerator compressedGenerator = new PGPCompressedDataGenerator(PGPCompressedData.ZIP);            PGPUtil.writeFileToLiteralData(compressedGenerator.open(compressed), PGPLiteralData.BINARY, path.toFile());            compressedGenerator.close();            JcePGPDataEncryptorBuilder encryptorBuilder = new JcePGPDataEncryptorBuilder(PGPEncryptedData.CAST5)                .setWithIntegrityPacket(true).setSecureRandom(new SecureRandom()).setProvider(PROVIDER);            PGPEncryptedDataGenerator dataGenerator = new PGPEncryptedDataGenerator(encryptorBuilder);            JcePublicKeyKeyEncryptionMethodGenerator methodGenerator = new JcePublicKeyKeyEncryptionMethodGenerator                (publicKey).setProvider(PROVIDER).setSecureRandom(new SecureRandom());            dataGenerator.addMethod(methodGenerator);            byte[] compressedData = compressed.toByteArray();            OutputStream encryptedOut = dataGenerator.open(armOut, compressedData.length);            encryptedOut.write(compressedData);            encryptedOut.close();        }    }
public static String encrypt(String apiKey, Map<String, Object> options)            throws ScopedKeyException {        if (apiKey.length() == 64) {            return encrypt(KeenClient.client(), apiKey, options);        } else {            return encrypt32CharacterKey(KeenClient.client(), apiKey, options);        }    }
public static String encrypt(KeenClient client, String apiKey, Map<String, Object> options)            throws ScopedKeyException {        try {            // if the user doesn't give an options, just use an empty one            if (options == null) {                options = new HashMap<String, Object>();            }            // convert the api key from hex string to byte array            final byte[] apiKeyBytes = KeenUtils.hexStringToByteArray(apiKey);            // json encode the options            StringWriter writer = new StringWriter();            client.getJsonHandler().writeJson(writer, options);            final String jsonOptions = writer.toString();            // setup the API key as the secret            final SecretKey secret = new SecretKeySpec(apiKeyBytes, "AES");            // get the right AES cipher            final Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");            cipher.init(Cipher.ENCRYPT_MODE, secret);            final AlgorithmParameters params = cipher.getParameters();            // get a random IV for each encryption            final byte[] iv = params.getParameterSpec(IvParameterSpec.class).getIV();            // do the actual encryption (this also pads jsonOptions)            final byte[] cipherText = cipher.doFinal(jsonOptions.getBytes("UTF-8"));            // now return the hexed iv + the hexed cipher text            return KeenUtils.byteArrayToHexString(iv) + KeenUtils.byteArrayToHexString(cipherText);        } catch (Exception e) {            throw new ScopedKeyException("An error occurred while attempting to encrypt a Scoped Key", e);        }    }
public static @Nullable byte[] encrypt(EncryptionKey encryptionKey, @Nullable String value) throws NoSuchPaddingException,                                                                                                   InvalidKeyException,                                                                                                   NoSuchAlgorithmException,                                                                                                   IllegalBlockSizeException,                                                                                                   BadPaddingException,                                                                                                   InvalidAlgorithmParameterException,                                                                                                   EncryptionException {return value != null ? encrypt(encryptionKey, value.getBytes()) : null;}

linear regression
public double regress(DataPoint dp)    {        TreeNodeVisitor node = this;        while(!node.isLeaf())        {            int path = node.getPath(dp);            if(path < 0 )//missing value case            {                double sum = 0;                double resultSum = 0;                for(int child = 0; child < childrenCount(); child++)                {                    if(node.isPathDisabled(child))                        continue;                    double child_result = node.getChild(child).regress(dp);                    sum += node.getPathWeight(child);                    resultSum += node.getPathWeight(child)*child_result;                }                                if(sum == 0)//all paths disabled?                    break;//break out and do local classify                if(sum < 1.0-1e-5)//re-normalize our result                    resultSum /= (sum+1e-6);                                return resultSum;            }            if(node.isPathDisabled(path))//if missing value makes path < 0, return local regression dec                break;            node = node.getChild(path);        }        return node.localRegress(dp);    }
public double[] getLinearRegressionParameters(RandomVariable dependents) {RandomVariable localizerWeights = dependents.squared().sub(Math.pow(dependents.getStandardDeviation()*standardDeviations,2.0)).choose(new Scalar(0.0), new Scalar(1.0));// Localize basis functionsRandomVariable[] basisFunctionsNonLocalized = getBasisFunctionsEstimator().getBasisFunctions();RandomVariable[] basisFunctions = new RandomVariable[basisFunctionsNonLocalized.length];for(int i=0; i<basisFunctions.length; i++) {basisFunctions[i] = basisFunctionsNonLocalized[i].mult(localizerWeights);}// Localize dependentsdependents = dependents.mult(localizerWeights);// Build XTX - the symmetric matrix consisting of the scalar products of the basis functions.double[][] XTX = new double[basisFunctions.length][basisFunctions.length];for(int i=0; i<basisFunctions.length; i++) {for(int j=i; j<basisFunctions.length; j++) {XTX[i][j] = basisFunctions[i].mult(basisFunctions[j]).getAverage();// Scalar productXTX[j][i] = XTX[i][j];// Symmetric matrix}}DecompositionSolver solver = new SingularValueDecomposition(new Array2DRowRealMatrix(XTX, false)).getSolver();// Build XTy - the projection of the dependents random variable on the basis functions.double[] XTy = new double[basisFunctions.length];for(int i=0; i<basisFunctions.length; i++) {XTy[i] = dependents.mult(basisFunctions[i]).getAverage();// Scalar product}// Solve X^T X x = X^T y - which gives us the regression coefficients x = linearRegressionParametersdouble[] linearRegressionParameters = solver.solve(new ArrayRealVector(XTy)).toArray();return linearRegressionParameters;}
public double[] getLinearRegressionParameters(RandomVariable dependents) {RandomVariable[] basisFunctions = basisFunctionsEstimator.getBasisFunctions();synchronized (solverLock) {if(solver == null) {// Build XTX - the symmetric matrix consisting of the scalar products of the basis functions.double[][] XTX = new double[basisFunctions.length][basisFunctions.length];for(int i=0; i<basisFunctions.length; i++) {for(int j=i; j<basisFunctions.length; j++) {XTX[i][j] = basisFunctions[i].mult(basisFunctions[j]).getAverage();// Scalar productXTX[j][i] = XTX[i][j];// Symmetric matrix}}solver = new SingularValueDecomposition(new Array2DRowRealMatrix(XTX, false)).getSolver();}}// Build XTy - the projection of the dependents random variable on the basis functions.double[] XTy = new double[basisFunctions.length];for(int i=0; i<basisFunctions.length; i++) {XTy[i] = dependents.mult(basisFunctions[i]).getAverage();// Scalar product}// Solve X^T X x = X^T y - which gives us the regression coefficients x = linearRegressionParametersdouble[] linearRegressionParameters = solver.solve(new ArrayRealVector(XTy)).toArray();return linearRegressionParameters;}
public static RegressionDataSet loadRegression(InputStream inRaw, DataStore backingStore) throws IOException    {        return (RegressionDataSet) load(inRaw, backingStore);    }
public RunList<R> regressionOnly() {        return filter(new Predicate<R>() {            public boolean apply(R r) {                return r.getBuildStatusSummary().isWorse;            }        });    }
public RegressionModelPrediction predictRegression(RowData data, double offset) throws PredictException {    double[] preds = preamble(ModelCategory.Regression, data, offset);    RegressionModelPrediction p = new RegressionModelPrediction();    if (enableLeafAssignment) { // only get leaf node assignment if enabled      SharedTreeMojoModel.LeafNodeAssignments assignments = leafNodeAssignmentExtended(data);      p.leafNodeAssignments = assignments._paths;      p.leafNodeAssignmentIds = assignments._nodeIds;    }    p.value = preds[0];    if (enableStagedProbabilities) {        double[] rawData = nanArray(m.nfeatures());        rawData = fillRawData(data, rawData);        p.stageProbabilities = ((SharedTreeMojoModel) m).scoreStagedPredictions(rawData, preds.length);    }    if (enableContributions) {      double[] rawData = nanArray(m.nfeatures());      rawData = fillRawData(data, rawData);      p.contributions = predictContributions.calculateContributions(rawData);    }    return p;  }
public <T extends RegressionEvaluation> T evaluateRegression(DataSetIterator iterator, List<String> columnNames) {        return (T)doEvaluation(iterator, new org.deeplearning4j.eval.RegressionEvaluation(columnNames))[0];    }
public <T extends RegressionEvaluation> T evaluateRegression(JavaRDD<DataSet> data) {        return evaluateRegression(data, DEFAULT_EVAL_SCORE_BATCH_SIZE);    }
public <T extends RegressionEvaluation> T evaluateRegression(JavaRDD<DataSet> data, int minibatchSize) {        long nOut = ((FeedForwardLayer) network.getOutputLayer().conf().getLayer()).getNOut();        return (T)doEvaluation(data, new org.deeplearning4j.eval.RegressionEvaluation(nOut), minibatchSize);    }
public <T extends RegressionEvaluation> T evaluateRegression(DataSetIterator iterator) {        return (T)doEvaluation(iterator, new RegressionEvaluation(iterator.totalOutcomes()))[0];    }

socket recv timeout
@Override  public BeadledomResteasyClientBuilder setSocketTimeout(int socketTimeout, TimeUnit timeUnit) {    long millis = timeUnit.toMillis(socketTimeout);    if (millis > Integer.MAX_VALUE || millis < 0) {      throw new IllegalArgumentException(          "Socket timeout must be smaller than Integer.MAX_VALUE when converted to milliseconds"      );    }    return readTimeout((int) millis, TimeUnit.MILLISECONDS);  }
public int getSocketTimeout() {        int timeoutInt = -1;  // -1 indicates it hasn't been set yet        String timeoutStr = System.getProperty(SOCKET_TIMEOUT);        if (timeoutStr != null && timeoutStr.length() > 0) {            int parsedTimeoutInt = Integer.parseInt(timeoutStr);            if (parsedTimeoutInt >= 0) {                timeoutInt = parsedTimeoutInt;            }        }        if (timeoutInt == -1) { // Didn't find a system property            timeoutStr = getProperty(SOCKET_TIMEOUT);            if (timeoutStr != null && timeoutStr.length() > 0) {                int parsedTimeoutInt = Integer.parseInt(timeoutStr);                if (parsedTimeoutInt >= 0) {                    timeoutInt = parsedTimeoutInt;                }            }        }        if (timeoutInt == -1) { // Didn't find any property at all            timeoutInt = 120 * 1000;        }        return timeoutInt;    }
public Socket newSocket(String host, int port) {    try {      Socket socket = newSocket();      socket.setReuseAddress(DEFAULT_REUSE_ADDRESS);      socket.setSoTimeout(intValue(DEFAULT_SO_TIMEOUT));      socket.connect(newSocketAddress(host, port));      return socket;    }    catch (IOException cause) {      throw newRuntimeException(cause, "Failed to create a client Socket on host [%s] and port [%d]", host, port);    }  }
@Nullable  public InternalInstrumented<SocketStats> getSocket(long id) {    InternalInstrumented<SocketStats> clientSocket = otherSockets.get(id);    if (clientSocket != null) {      return clientSocket;    }    return getServerSocket(id);  }
protected void addSocket(final S newSocket) {if(isClosed()) throw new IllegalStateException("SocketContext is closed");Future<?> future;synchronized(sockets) {Identifier id = newSocket.getId();if(sockets.containsKey(id)) throw new IllegalStateException("Socket with the same ID has already been added");sockets.put(id, newSocket);future = listenerManager.enqueueEvent(new ConcurrentListenerManager.Event<SocketContextListener>() {@Overridepublic Runnable createCall(final SocketContextListener listener) {return new Runnable() {@Overridepublic void run() {listener.onNewSocket(AbstractSocketContext.this, newSocket);}};}});}try {future.get();} catch(ExecutionException e) {logger.log(Level.SEVERE, null, e);} catch(InterruptedException e) {logger.log(Level.SEVERE, null, e);// Restore the interrupted statusThread.currentThread().interrupt();}}
public static SSLSocket getSocket(EncryptionOptions options, InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException    {        SSLContext ctx = createSSLContext(options, true);        SSLSocket socket = (SSLSocket) ctx.getSocketFactory().createSocket(address, port, localAddress, localPort);        String[] suits = filterCipherSuites(socket.getSupportedCipherSuites(), options.cipher_suites);        socket.setEnabledCipherSuites(suits);        socket.setEnabledProtocols(ACCEPTED_PROTOCOLS);        return socket;    }
private Socket getSocket( WebSocket conn ) {WebSocketImpl impl = (WebSocketImpl) conn;return ( (SocketChannel) impl.getSelectionKey().channel() ).socket();}
protected Socket getSocket(){        if (mSocketFactoryRef != null && mSocketFactoryRef.get() != null) {            return ((SSLSocketFactoryWrapper)mSocketFactoryRef.get()).getSocket();        }        return null;    }
public void setSocket(Socket socket) {    if (socket != null)    {      m_remoteAddress = socket.getInetAddress();      this.port = socket.getPort();      m_controlThread = new DebugControlConnectionThread(socket, this);      m_controlThread.start();      executeStartupCommands();      m_controlThread.sendMessage("getsettings");      m_controlThread.sendMessage("[out-network");      //m_controlThread.sendMessage("[out-network-true");      String networkTracePortStr = m_controlThread.getMessage();      int networkTracePort = Integer.parseInt(networkTracePortStr);      if (LOG.isDebugEnabled()) LOG.debug("Received network trace port [" + networkTracePort + "]");            try      {        INetworkOutputConfig config = new INetworkOutputConfig()        {          @Override          public boolean isNetOutputEnabled()          {            return m_settingsData.netOutEnabled;          }@Overridepublic boolean isGzipEnabled() {return m_settingsData.gzipEnabled;}        };                        m_networkTraceThread2 = new NetworkDataReceiverThread2(        m_remoteAddress,        networkTracePort,         config        );        m_networkTraceThread2.start();      setConnectState(ConnectState.CONNECTED);      setConnectionStatusMsg(DefaultFactory.getFactory().getMessages().getConnected());              } catch (IOException ex)      {      m_traceEvents.add(      TraceFactory.createExceptionTraceEvent(      org.headlessintrace.rcp.ClientStrings.TRACE_CREATION_ERROR,       ex,       m_remoteAddress,       networkTracePortStr));      }          } else    {      setConnectState(ConnectState.DISCONNECTED_ERR);    }}
@Override  public void getSocket(      GetSocketRequest request, StreamObserver<GetSocketResponse> responseObserver) {    InternalInstrumented<SocketStats> s = channelz.getSocket(request.getSocketId());    if (s == null) {      responseObserver.onError(          Status.NOT_FOUND.withDescription("Can't find socket " + request.getSocketId())              .asRuntimeException());      return;    }    GetSocketResponse resp;    try {      resp =          GetSocketResponse.newBuilder().setSocket(ChannelzProtoUtil.toSocket(s)).build();    } catch (StatusRuntimeException e) {      responseObserver.onError(e);      return;    }    responseObserver.onNext(resp);    responseObserver.onCompleted();  }

write csv
private static byte[] writeCsv(String[] columnHeaders, List<String[]> rows) throws IOException {    return writeCsv(columnHeaders, rows.stream().toArray(String[][]::new));  }
private static byte[] writeCsv(String[] columnHeaders, String[][] rows) throws IOException {    try (ByteArrayOutputStream csvStream = new ByteArrayOutputStream(); OutputStreamWriter streamWriter = new OutputStreamWriter(csvStream, Charset.forName("UTF-8"))) {      CSVWriter csvWriter = new CSVWriter(streamWriter, ',');      csvWriter.writeNext(columnHeaders);            for (String[] row : rows) {        csvWriter.writeNext(row);      }      csvWriter.close();            return csvStream.toByteArray();    }  }
public static void writeCsv(List<String[]> csvData, String fileName) throws IOException {    Preconditions.checkNotNull(csvData, "Null CSV data");    Preconditions.checkNotNull(fileName, "Null file name");    CSVWriter writer = null;    try {      writer = new CSVWriter(Files.newWriter(new File(fileName), StandardCharsets.UTF_8));      for (String[] line : csvData) {        writer.writeNext(line);      }    } finally {      if (writer != null) {        writer.close();      }    }  }
protected void writeCsv(final MBasicTable table, final OutputStream outputStream)throws IOException {writeCsv(table, outputStream, DateFormat.getDateInstance(DateFormat.SHORT, Locale.US));}
protected void writeCsv(final MBasicTable table, final OutputStream outputStream,final DateFormat dateFormat) throws IOException {// récupération des informations utilesfinal int columnCount = table.getColumnModel().getColumnCount();final int rowCount = table.getRowCount();final String charset = System.getProperty("file.encoding");final Writer out = new OutputStreamWriter(outputStream, charset);final char csvSeparator = CSV_SEPARATOR;// le séparateur des .csv (',' à l'américaine)final NumberFormat decimalFormat = NumberFormat.getInstance(Locale.US);decimalFormat.setGroupingUsed(false);final String eol = System.getProperty("line.separator");// titres des colonneswriteCsvHeader(table, out, csvSeparator);// les données proprement dites (ligne par ligne puis colonne par colonne)Object value;String text;for (int k = 0; k < rowCount; k++) {for (int i = 0; i < columnCount; i++) {value = getValueAt(table, k, i);if (value instanceof Number) {text = decimalFormat.format(value);} else if (value instanceof Date) {text = dateFormat.format(value);} else if (value instanceof Boolean) {text = value.toString();} else {text = getTextAt(table, k, i);text = formatCsv(text, csvSeparator);}out.write(text);if (i < columnCount - 1) {out.write(csvSeparator);}}if (k < rowCount - 1) {out.write(eol);}}out.flush();}
public DataSink<T> writeAsCsv(String filePath) {return writeAsCsv(filePath, CsvOutputFormat.DEFAULT_LINE_DELIMITER, CsvOutputFormat.DEFAULT_FIELD_DELIMITER);}
public DataSink<T> writeAsCsv(String filePath, String rowDelimiter, String fieldDelimiter, WriteMode writeMode) {return internalWriteAsCsv(new Path(filePath), rowDelimiter, fieldDelimiter, writeMode);}
public DataSink<T> writeAsCsv(String filePath, WriteMode writeMode) {return internalWriteAsCsv(new Path(filePath), CsvOutputFormat.DEFAULT_LINE_DELIMITER, CsvOutputFormat.DEFAULT_FIELD_DELIMITER, writeMode);}
public DataSink<T> writeAsCsv(String filePath, String rowDelimiter, String fieldDelimiter) {return internalWriteAsCsv(new Path(filePath), rowDelimiter, fieldDelimiter, null);}
@PublicEvolvingpublic DataStreamSink<T> writeAsCsv(String path) {return writeAsCsv(path, null, CsvOutputFormat.DEFAULT_LINE_DELIMITER, CsvOutputFormat.DEFAULT_FIELD_DELIMITER);}

convert decimal to hex
public static String convertToHex(long value) {StringBuilder SB = new StringBuilder(16);try {convertToHex(value, SB);} catch(IOException e) {throw new AssertionError(e);}return SB.toString();}
public static void convertToHex(int value, Appendable out) throws IOException {out.append(getHexChar(value >>> 28));out.append(getHexChar(value >>> 24));out.append(getHexChar(value >>> 20));out.append(getHexChar(value >>> 16));out.append(getHexChar(value >>> 12));out.append(getHexChar(value >>> 8));out.append(getHexChar(value >>> 4));out.append(getHexChar(value));}
public static void convertToHex(long value, Appendable out) throws IOException {convertToHex((int)(value >>> 32), out);convertToHex((int)value, out);}
private static String convertToHex(byte[] data) {        final StringBuffer buffer = new StringBuffer();        for (int i = 0; i < data.length; i++) {            int halfByte = (data[i] >>> 4) & 0x0F;            int twoHalves = 0;            do {                if ((0 <= halfByte) && (halfByte <= 9)) {                    buffer.append((char) ('0' + halfByte));                } else {                    buffer.append((char) ('a' + (halfByte - 10)));                }                halfByte = data[i] & 0x0F;            } while(twoHalves++ < 1);        }        return buffer.toString();    }
protected String convertToHex(int i) {        String hexString = Integer.toHexString(i);        while (hexString.length() < 2) {            hexString = "0" + hexString;        }        return hexString;    }
private static void convertHexToUnicode(String str) {        try {            display("Hex to Unicode: " + Utils.toString(Utils.base64ToBinary(Utils.base64FromHex(str))));        } catch (Exception e) {        }    }
private static void convertUnicodeToHex(String str) {        try {            display("Unicode to hex: " + Utils.toHexBytes(Utils.toBytes(str)));        } catch (Exception e) {        }    }
public RTHtml<RTImage, RTAudio, RTVideo> convert(final Spanned text, RTFormat.Html rtFormat) {        mText = text;        mRTFormat = rtFormat;        mOut = new StringBuilder();        mImages = new ArrayList<>();        mParagraphStyles.clear();        // convert paragraphs        convertParagraphs();        return new RTHtml<>(rtFormat, mOut.toString(), mImages);    }
public Object convert( String value, TypeLiteral<?> toType )    {        Exception firstEx = null;        for ( String pattern : this.patterns )        {            try            {                DateFormat format;                if ( this.locale != null )                {                    format = new SimpleDateFormat( pattern, this.locale );                }                else                {                    format = new SimpleDateFormat( pattern );                }                if ( this.timeZone != null )                {                    format.setTimeZone( this.timeZone );                }                format.setLenient( false );                Date date = this.parse( value, format );                if ( Calendar.class == toType.getType() )                {                    Calendar calendar = null;                    if ( this.locale == null && this.timeZone == null )                    {                        calendar = Calendar.getInstance();                    }                    else if ( this.locale == null )                    {                        calendar = Calendar.getInstance( this.timeZone );                    }                    else if ( this.timeZone == null )                    {                        calendar = Calendar.getInstance( this.locale );                    }                    else                    {                        calendar = Calendar.getInstance( this.timeZone, this.locale );                    }                    calendar.setTime( date );                    calendar.setLenient( false );                    return calendar;                }                return date;            }            catch ( Exception ex )            {                if ( firstEx == null )                {                    firstEx = ex;                }            }        }        throw new IllegalArgumentException( "Error converting '" + value + "' using  patterns " + this.patterns,                                            firstEx );    }
private static Object convert(Object x) throws JSONException {    if (x instanceof JSONObject) {      JSONObject jsonObject = (JSONObject) x;      String[] names = JSONObject.getNames(jsonObject);      if (names == null || names.length == 0) {        return new HashMap<>(0);      }      HashMap<String, Object> map = new HashMap<>(names.length);      for (String name : names) {        Object value = jsonObject.get(name);        map.put(name, convert(value));      }      return map;    } else if (x instanceof JSONArray) {      JSONArray jsonArray = (JSONArray) x;      int length = jsonArray.length();      List<Object> list = new ArrayList<>(length);      for (int i = 0; i < length; i++) {        list.add(convert(jsonArray.get(i)));      }      return list;    } else {      return x;    }  }

export to excel
public void exportMap2Excel(String templatePath, Map<String, List<?>> data,                                Map<String, String> extendMap, Class clazz, OutputStream os)            throws Excel4JException {        try (SheetTemplate sheetTemplate = exportExcelByMapHandler(templatePath, 0, data, extendMap, clazz, true)) {            sheetTemplate.write2Stream(os);        } catch (IOException e) {            throw new Excel4JException(e);        }    }
public void exportMap2Excel(String templatePath, Map<String, List<?>> data,                                Map<String, String> extendMap, Class clazz, String targetPath)            throws Excel4JException {        try (SheetTemplate sheetTemplate = exportExcelByMapHandler(templatePath, 0, data, extendMap, clazz, true)) {            sheetTemplate.write2File(targetPath);        } catch (IOException e) {            throw new Excel4JException(e);        }    }
public void exportDataSetExcel(final DataSetLookup request,                                   final DataSetExportReadyCallback listener) throws Exception {        if (dataSetLookupServices != null) {            // Look always into the client data set manager.            if (clientDataSetManager.getDataSet(request.getDataSetUUID()) != null) {                DataSet dataSet = clientDataSetManager.lookupDataSet(request);                try {                    dataSetExportServices.call(                            new RemoteCallback<Path>() {                                public void callback(Path excelFilePath) {                                    listener.exportReady(excelFilePath);                                }                            }).exportDataSetExcel(dataSet);                } catch (Exception e) {                    throw new RuntimeException(e);                }            }            // Data set not found on client.            else {                // If the data set is not in client, then look up remotely (only if the remote access is available).                try {                    dataSetExportServices.call(                            new RemoteCallback<Path>() {                                public void callback(Path excelFilePath) {                                    listener.exportReady(excelFilePath);                                }                            }                            ,                            new ErrorCallback<Message>() {                                public boolean error(Message message,                                                     Throwable throwable) {                                    listener.onError(new ClientRuntimeError(throwable));                                    return true;                                }                            }).exportDataSetExcel(request);                } catch (Exception e) {                    listener.onError(new ClientRuntimeError(e));                }            }        } else {            listener.onError(new ClientRuntimeError(CommonConstants.INSTANCE.exc_no_client_side_data_export()));        }    }
public void exportObjects2Excel(List<?> data, Class clazz, boolean isWriteHeader, OutputStream os)            throws Excel4JException, IOException {        try (Workbook workbook = exportExcelNoTemplateHandler(data, clazz, isWriteHeader, null, true)) {            workbook.write(os);        }    }
public void exportObjects2Excel(List<?> data, Class clazz, boolean isWriteHeader,                                    String sheetName, boolean isXSSF, OutputStream os)            throws Excel4JException, IOException {        try (Workbook workbook = exportExcelNoTemplateHandler(data, clazz, isWriteHeader, sheetName, isXSSF)) {            workbook.write(os);        }    }
public void exportObjects2Excel(List<?> data, Class clazz, boolean isWriteHeader,                                    String sheetName, boolean isXSSF, String targetPath)            throws Excel4JException, IOException {        try (FileOutputStream fos = new FileOutputStream(targetPath);             Workbook workbook = exportExcelNoTemplateHandler(data, clazz, isWriteHeader, sheetName, isXSSF)) {            workbook.write(fos);        }    }
public void exportObjects2Excel(List<?> data, List<String> header, OutputStream os)            throws IOException {        try (Workbook workbook = exportExcelBySimpleHandler(data, header, null, true)) {            workbook.write(os);        }    }
public void exportObjects2Excel(List<?> data, List<String> header, String sheetName,                                    boolean isXSSF, OutputStream os)            throws IOException {        try (Workbook workbook = exportExcelBySimpleHandler(data, header, sheetName, isXSSF)) {            workbook.write(os);        }    }
public void exportObjects2Excel(List<?> data, List<String> header, String sheetName,                                    boolean isXSSF, String targetPath)            throws IOException {        try (OutputStream fos = new FileOutputStream(targetPath);             Workbook workbook = exportExcelBySimpleHandler(data, header, sheetName, isXSSF)) {            workbook.write(fos);        }    }
public void exportObjects2Excel(List<?> data, List<String> header, String targetPath)            throws IOException {        try (OutputStream fos = new FileOutputStream(targetPath);             Workbook workbook = exportExcelBySimpleHandler(data, header, null, true)) {            workbook.write(fos);        }    }

scatter plot
public void addScatterPlot(String scatterID, String xAxisLabel,            String yAxisLabel) throws ShanksException {        Scenario3DPortrayal scenarioPortrayal = (Scenario3DPortrayal) this                .getSimulation().getScenarioPortrayal();        scenarioPortrayal.addScatterPlot(scatterID, xAxisLabel, yAxisLabel);    }
public void addScatterPlot(String scatterID, String xAxisLabel, String yAxisLabel) throws ShanksException {        if (!this.timeCharts.containsKey(scatterID)) {            ScatterPlotGenerator scatter = new ScatterPlotGenerator();            scatter.setTitle(scatterID);            scatter.setXAxisLabel(xAxisLabel);            scatter.setYAxisLabel(yAxisLabel);            this.scatterPlots.put(scatterID, scatter);        } else {            throw new DuplicatedChartIDException(scatterID);        }    }
public void removeScatterPlot(String scatterID) throws ShanksException {        Scenario2DPortrayal scenarioPortrayal = (Scenario2DPortrayal) this                .getSimulation().getScenarioPortrayal();        scenarioPortrayal.removeScatterPlot(scatterID);    }
public void removeScatterPlot(String scatterID) throws ShanksException {        Scenario3DPortrayal scenarioPortrayal = (Scenario3DPortrayal) this                .getSimulation().getScenarioPortrayal();        scenarioPortrayal.removeScatterPlot(scatterID);    }
public static PlotCanvas plot(String id, double[][] data, int[] y, char[] legend, Color[] palette) {        if (data[0].length != 2 && data[0].length != 3) {            throw new IllegalArgumentException("Invalid data dimension: " + data[0].length);        }        double[] lowerBound = Math.colMin(data);        double[] upperBound = Math.colMax(data);        PlotCanvas canvas = new PlotCanvas(lowerBound, upperBound);        ScatterPlot plot = new ScatterPlot(data, y, legend, palette);        plot.setID(id);        canvas.add(plot);        return canvas;    }
public static PlotCanvas plot(double[][] data, char legend, Color color) {        return plot(null, data, legend, color);    }
public static PlotCanvas plot(double[][] data, int[] y, char legend, Color[] palette) {        return plot(null, data, y, legend, palette);    }
public static PlotCanvas plot(double[][] z, Color[] palette) {        double[] lowerBound = {0, 0, Math.min(z)};        double[] upperBound = {z.length, z[0].length, Math.max(z)};        PlotCanvas canvas = new PlotCanvas(lowerBound, upperBound);        Surface surface = new Surface(z, palette);        canvas.add(surface);        return canvas;    }
public static PlotCanvas plot(double[][][] data) {        double[] lowerBound = {data[0][0][0], data[0][0][1], data[0][0][2]};        double[] upperBound = {data[0][0][0], data[0][0][1], data[0][0][2]};        for (int i = 0; i < data.length; i++) {            for (int j = 0; j < data[i].length; j++) {                if (data[i][j][0] < lowerBound[0]) {                    lowerBound[0] = data[i][j][0];                }                if (data[i][j][0] > upperBound[0]) {                    upperBound[0] = data[i][j][0];                }                if (data[i][j][1] < lowerBound[1]) {                    lowerBound[1] = data[i][j][1];                }                if (data[i][j][1] > upperBound[1]) {                    upperBound[1] = data[i][j][1];                }                if (data[i][j][2] < lowerBound[2]) {                    lowerBound[2] = data[i][j][2];                }                if (data[i][j][2] > upperBound[2]) {                    upperBound[2] = data[i][j][2];                }            }        }        PlotCanvas canvas = new PlotCanvas(lowerBound, upperBound);        Surface surface = new Surface(data);        canvas.add(surface);        return canvas;    }
public static PlotCanvas plot(double[] x, double[] y, double[][] z) {        double[] lowerBound = {Math.min(x), Math.min(y), Math.min(z)};        double[] upperBound = {Math.max(x), Math.max(y), Math.max(z)};        PlotCanvas canvas = new PlotCanvas(lowerBound, upperBound);        Surface surface = new Surface(x, y, z);        canvas.add(surface);        return canvas;    }

convert json to csv
static List<String> convertToJson(String appName, Collection<SpanData> spanDataList) {    List<String> spanJson = new ArrayList<String>();    if (spanDataList == null) {      return spanJson;    }    StringBuilder sb = new StringBuilder();    for (final SpanData span : spanDataList) {      final SpanContext spanContext = span.getContext();      final SpanId parentSpanId = span.getParentSpanId();      final Timestamp startTimestamp = span.getStartTimestamp();      final Timestamp endTimestamp = span.getEndTimestamp();      final Status status = span.getStatus();      if (endTimestamp == null) {        continue;      }      sb.append('{');      sb.append("\"appName\":\"").append(appName).append("\",");      sb.append("\"spanId\":\"").append(encodeSpanId(spanContext.getSpanId())).append("\",");      sb.append("\"traceId\":\"").append(encodeTraceId(spanContext.getTraceId())).append("\",");      if (parentSpanId != null) {        sb.append("\"parentId\":\"").append(encodeSpanId(parentSpanId)).append("\",");      }      sb.append("\"timestamp\":").append(toMillis(startTimestamp)).append(',');      sb.append("\"duration\":").append(toMillis(startTimestamp, endTimestamp)).append(',');      sb.append("\"name\":\"").append(toSpanName(span)).append("\",");      sb.append("\"kind\":\"").append(toSpanKind(span)).append("\",");      sb.append("\"dateStarted\":\"").append(formatDate(startTimestamp)).append("\",");      sb.append("\"dateEnded\":\"").append(formatDate(endTimestamp)).append('"');      if (status == null) {        sb.append(",\"status\":").append("\"ok\"");      } else if (!status.isOk()) {        sb.append(",\"error\":").append("true");      }      Map<String, AttributeValue> attributeMap = span.getAttributes().getAttributeMap();      if (attributeMap.size() > 0) {        StringBuilder builder = new StringBuilder();        builder.append('{');        for (Entry<String, AttributeValue> entry : attributeMap.entrySet()) {          if (builder.length() > 1) {            builder.append(',');          }          builder              .append("\"")              .append(entry.getKey())              .append("\":\"")              .append(attributeValueToString(entry.getValue()))              .append("\"");        }        builder.append('}');        sb.append(",\"data\":").append(builder);      }      sb.append('}');      spanJson.add(sb.toString());    }    return spanJson;  }
public JSONObject convertToJson() {        JSONObject buoJsonModel = new JSONObject();        try {            // Add all keys in plane format  initially. All known keys will be replaced with corresponding data type in the following section            JSONObject metadataJsonObject = metadata_.convertToJson();            Iterator<String> keys = metadataJsonObject.keys();            while (keys.hasNext()) {                String key = keys.next();                buoJsonModel.put(key, metadataJsonObject.get(key));            }            if (!TextUtils.isEmpty(title_)) {                buoJsonModel.put(Defines.Jsonkey.ContentTitle.getKey(), title_);            }            if (!TextUtils.isEmpty(canonicalIdentifier_)) {                buoJsonModel.put(Defines.Jsonkey.CanonicalIdentifier.getKey(), canonicalIdentifier_);            }            if (!TextUtils.isEmpty(canonicalUrl_)) {                buoJsonModel.put(Defines.Jsonkey.CanonicalUrl.getKey(), canonicalUrl_);            }            if (keywords_.size() > 0) {                JSONArray keyWordJsonArray = new JSONArray();                for (String keyword : keywords_) {                    keyWordJsonArray.put(keyword);                }                buoJsonModel.put(Defines.Jsonkey.ContentKeyWords.getKey(), keyWordJsonArray);            }            if (!TextUtils.isEmpty(description_)) {                buoJsonModel.put(Defines.Jsonkey.ContentDesc.getKey(), description_);            }            if (!TextUtils.isEmpty(imageUrl_)) {                buoJsonModel.put(Defines.Jsonkey.ContentImgUrl.getKey(), imageUrl_);            }            if (expirationInMilliSec_ > 0) {                buoJsonModel.put(Defines.Jsonkey.ContentExpiryTime.getKey(), expirationInMilliSec_);            }            buoJsonModel.put(Defines.Jsonkey.PublicallyIndexable.getKey(), isPublicallyIndexable());            buoJsonModel.put(Defines.Jsonkey.LocallyIndexable.getKey(), isLocallyIndexable());            buoJsonModel.put(Defines.Jsonkey.CreationTimestamp.getKey(), creationTimeStamp_);                    } catch (JSONException ignore) {        }        return buoJsonModel;    }
public JSONObject convertToJson() {        JSONObject metadataJson = new JSONObject();        try {            if (contentSchema != null) {                metadataJson.put(Defines.Jsonkey.ContentSchema.getKey(), contentSchema.name());            }            if (quantity != null) {                metadataJson.put(Defines.Jsonkey.Quantity.getKey(), quantity);            }            if (price != null) {                metadataJson.put(Defines.Jsonkey.Price.getKey(), price);            }            if (currencyType != null) {                metadataJson.put(Defines.Jsonkey.PriceCurrency.getKey(), currencyType.toString());            }            if (!TextUtils.isEmpty(sku)) {                metadataJson.put(Defines.Jsonkey.SKU.getKey(), sku);            }            if (!TextUtils.isEmpty(productName)) {                metadataJson.put(Defines.Jsonkey.ProductName.getKey(), productName);            }            if (!TextUtils.isEmpty(productBrand)) {                metadataJson.put(Defines.Jsonkey.ProductBrand.getKey(), productBrand);            }            if (productCategory != null) {                metadataJson.put(Defines.Jsonkey.ProductCategory.getKey(), productCategory.getName());            }            if (condition != null) {                metadataJson.put(Defines.Jsonkey.Condition.getKey(), condition.name());            }            if (!TextUtils.isEmpty(productVariant)) {                metadataJson.put(Defines.Jsonkey.ProductVariant.getKey(), productVariant);            }            if (rating != null) {                metadataJson.put(Defines.Jsonkey.Rating.getKey(), rating);            }            if (ratingAverage != null) {                metadataJson.put(Defines.Jsonkey.RatingAverage.getKey(), ratingAverage);            }            if (ratingCount != null) {                metadataJson.put(Defines.Jsonkey.RatingCount.getKey(), ratingCount);            }            if (ratingMax != null) {                metadataJson.put(Defines.Jsonkey.RatingMax.getKey(), ratingMax);            }            if (!TextUtils.isEmpty(addressStreet)) {                metadataJson.put(Defines.Jsonkey.AddressStreet.getKey(), addressStreet);            }            if (!TextUtils.isEmpty(addressCity)) {                metadataJson.put(Defines.Jsonkey.AddressCity.getKey(), addressCity);            }            if (!TextUtils.isEmpty(addressRegion)) {                metadataJson.put(Defines.Jsonkey.AddressRegion.getKey(), addressRegion);            }            if (!TextUtils.isEmpty(addressCountry)) {                metadataJson.put(Defines.Jsonkey.AddressCountry.getKey(), addressCountry);            }            if (!TextUtils.isEmpty(addressPostalCode)) {                metadataJson.put(Defines.Jsonkey.AddressPostalCode.getKey(), addressPostalCode);            }            if (latitude != null) {                metadataJson.put(Defines.Jsonkey.Latitude.getKey(), latitude);            }            if (longitude != null) {                metadataJson.put(Defines.Jsonkey.Longitude.getKey(), longitude);            }            if (imageCaptions.size() > 0) {                JSONArray imageCaptionsArray = new JSONArray();                metadataJson.put(Defines.Jsonkey.ImageCaptions.getKey(), imageCaptionsArray);                for (String caption : imageCaptions) {                    imageCaptionsArray.put(caption);                }            }            if (customMetadata.size() > 0) {                for (String customDataKey : customMetadata.keySet()) {                    metadataJson.put(customDataKey, customMetadata.get(customDataKey));                }            }        } catch (JSONException ex) {            ex.printStackTrace();        }        return metadataJson;    }
private String convertToJson(Map<String, ?> map) throws MovieDbException {        try {            return MAPPER.writeValueAsString(map);        } catch (JsonProcessingException ex) {            throw new MovieDbException(ApiExceptionType.MAPPING_FAILED, "JSON conversion failed", "", ex);        }    }
public void convertToJsonld(InputStream in, OutputStream os)throws IOException {File inputProcessedFile = preProcessFile(in);LOG.info("OWl File processed successfully ");// print current timeSimpleDateFormat sdf = new SimpleDateFormat("HH:mm:ss");LOG.info("Conversion RDF to JSONLD started "+ sdf.format(Calendar.getInstance().getTime()));// create an empty modelModel modelJena = ModelFactory.createDefaultModel();InputStream internalInputStream = new FileInputStream(inputProcessedFile);// read the RDF/XML fileRDFDataMgr.read(modelJena, internalInputStream, Lang.RDFXML);LOG.info("Read into Model finished " + sdf.format(Calendar.getInstance().getTime()));try { //close quietly and delete the temp. input fileinternalInputStream.close();inputProcessedFile.delete();} catch(Exception e) {}RDFDataMgr.write(os, modelJena, Lang.JSONLD);LOG.info("Conversion RDF to JSONLD finished " + sdf.format(Calendar.getInstance().getTime()));LOG.info(" JSONLD file " + " is written successfully.");try { //close, flush quietlyos.close();} catch(Exception e) {}}
public void convertFromJsonld(InputStream in, OutputStream out) {Model modelJena = ModelFactory.createDefaultModel();if (in == null) {throw new IllegalArgumentException("Input File: " + " not found");}if (out == null) {throw new IllegalArgumentException("Output File: " + " not found");}// read the JSONLD filemodelJena.read(in, null, "JSONLD");RDFDataMgr.write(out, modelJena, Lang.RDFXML);LOG.info(" RDF file " + " is written successfully.");}
@When("^I convert the json file '(.+?)' to yaml file '(.+?)'$")    public void convertJsonToYaml(String fileToConvert, String fileName) throws Exception {        // Retrieve data        String retrievedData = commonspec.asYaml(fileToConvert);        // Create file (temporary) and set path to be accessible within test        File tempDirectory = new File(String.valueOf(System.getProperty("user.dir") + "/target/test-classes/"));        String absolutePathFile = tempDirectory.getAbsolutePath() + "/" + fileName;        commonspec.getLogger().debug("Creating file {} in 'target/test-classes'", absolutePathFile);        // Note that this Writer will delete the file if it exists        Writer out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(absolutePathFile), "UTF-8"));        try {            out.write(retrievedData);        } catch (Exception e) {            commonspec.getLogger().error("Custom file {} hasn't been created:\n{}", absolutePathFile, e.toString());            throw new RuntimeException("Custom file {} hasn't been created");        } finally {            out.close();        }        Assertions.assertThat(new File(absolutePathFile).isFile());    }
public static String convertJsonToYaml(Reader jsonReader) {        try (Reader reader = jsonReader) {            JsonNode json = new ObjectMapper().readTree(reader);            return new YAMLMapper().writeValueAsString(json);        } catch (IOException e) {            throw new YamlRuntimeException(e);        }    }
public static String convertYamlToJson(Reader yamlReader) {        try (Reader reader = yamlReader) {            Object yaml = new ObjectMapper(new YAMLFactory()).readValue(reader, Object.class);            return new ObjectMapper().writeValueAsString(yaml);        } catch (IOException e) {            throw new YamlRuntimeException(e);        }    }
public static Object convertFromJsonValue(JsonValue value) {        if (value == null) {            return null;        } else if (value.isNumber()) {            if (value.toString().contains(".")) {                return value.asDouble();            } else {                return value.asLong();            }        } else if (value.isBoolean()) {            return value.asBoolean();        } else if (value.isNull()) {            return null;        } else if (value.isString()) {            return value.asString();        } else if (value == NonTerminalJsonValue.INSTANCE) {            return value;        }        throw new IllegalArgumentException("Unknown Json type: " + value);    }

pretty print json
public static void prettyPrintJson(Object o) {        FSTConfiguration conf = constructJsonConf(true, true, null);        System.out.println(conf.asJsonString(o));    }
public final void printJsonString(CharSequence text)        throws IOException    {        if (text == null)        {            appendAscii("null");        }        else        {            appendAscii('"');            printCodePoints(text, JSON_ESCAPE_CODES);            appendAscii('"');        }    }
public static void printJsonString(Appendable out, CharSequence text)        throws IOException    {        if (text == null)        {            out.append("null");        }        else        {            out.append('"');            printCodePoints(out, text, EscapeMode.JSON);            out.append('"');        }    }
public static boolean printJsonObject( Object output, Boolean uglyPrint, boolean suppressOutput ) {        try {            if ( uglyPrint ) {                printToStandardOut( JsonUtils.toJsonString( output ), suppressOutput );            } else {                printToStandardOut( JsonUtils.toPrettyJsonString( output ), suppressOutput );            }        } catch ( Exception e ) {            printToStandardOut( "An error occured while attempting to print the output.", suppressOutput );            return false;        }        return true;    }
public String print(ReadableInstant instant) {        StringBuilder buf = new StringBuilder(requirePrinter().estimatePrintedLength());        try {            printTo((Appendable) buf, instant);        } catch (IOException ex) {            // StringBuilder does not throw IOException        }        return buf.toString();    }
public String print(ReadablePartial partial) {        StringBuilder buf = new StringBuilder(requirePrinter().estimatePrintedLength());        try {            printTo((Appendable) buf, partial);        } catch (IOException ex) {            // StringBuilder does not throw IOException        }        return buf.toString();    }
public static void print(CSTable table, PrintWriter out) {        out.println(TABLE + "," + CSVParser.printLine(table.getName()));        for (String key : table.getInfo().keySet()) {            out.println(CSVParser.printLine(key, table.getInfo().get(key)));        }        if (table.getColumnCount() < 1) {            out.flush();            return;        }        out.print(HEADER);        for (int i = 1; i <= table.getColumnCount(); i++) {            out.print("," + table.getColumnName(i));        }        out.println();        Map<String, String> m = table.getColumnInfo(1);        for (String key : m.keySet()) {            out.print(key);            for (int i = 1; i <= table.getColumnCount(); i++) {                out.print("," + table.getColumnInfo(i).get(key));            }            out.println();        }        for (String[] row : table.rows()) {            for (int i = 1; i < row.length; i++) {                out.print("," + row[i]);            }            out.println();        }        out.println();        out.flush();    }
public static void print(CSProperties props, PrintWriter out) {        out.println(PROPERTIES + "," + CSVParser.printLine(props.getName()));        for (String key : props.getInfo().keySet()) {            out.println(" " + CSVParser.printLine(key, props.getInfo().get(key)));        }        out.println();        for (String key : props.keySet()) {            out.println(PROPERTY + "," + CSVParser.printLine(key, props.get(key).toString()));            for (String key1 : props.getInfo(key).keySet()) {                out.println(" " + CSVParser.printLine(key1, props.getInfo(key).get(key1)));            }            out.println();        }        out.println();        out.flush();    }
public void print(        TimeSpan<? super U> duration,        Appendable buffer    ) throws IOException {        for (FormatItem<U> item : this.items) {            if (item == OrItem.INSTANCE) {                break;            }            item.print(duration, buffer);        }    }
public String print(ReadablePeriod period) {        checkPrinter();        checkPeriod(period);                PeriodPrinter printer = getPrinter();        StringBuffer buf = new StringBuffer(printer.calculatePrintedLength(period, iLocale));        printer.printTo(buf, period, iLocale);        return buf.toString();    }

replace in file
private void replaceInFile(String oldText, String newText) {        StringBuilder oldContent = new StringBuilder();        try (FileReader fr = new FileReader(file); BufferedReader reader = new BufferedReader(fr)) {            String line;            while ((line = reader.readLine()) != null) {                oldContent.append(line);                oldContent.append("\r\n");            }        } catch (IOException e) {            log.error(e);        }        // replace a word in a file        String newContent = oldContent.toString().replaceAll(oldText, newText);        try (FileWriter writer = new FileWriter(file)) {            writer.write(newContent);        } catch (IOException ioe) {            log.error(ioe);        }    }
@SuppressWarnings({"resource", "checkstyle:cyclomaticcomplexity", "checkstyle:npathcomplexity"})protected synchronized void replaceInFile(File sourceFile, File targetFile, ReplacementType replacementType,File[] classpath, boolean detectEncoding) throws MojoExecutionException {final File outputFile;final File inputFile;assert targetFile != null;if (sourceFile == null) {inputFile = targetFile;outputFile = new File(targetFile.getAbsolutePath() + ".maven.tmp"); //$NON-NLS-1$} else {inputFile = sourceFile;outputFile = targetFile;}final BuildContext buildContext = getBuildContext();buildContext.removeMessages(sourceFile);buildContext.removeMessages(targetFile);final ExtendedArtifact artifact = searchArtifact(inputFile);final String filename = removePathPrefix(getBaseDirectory(), inputFile);String shortFilename = null;for (int i = 0; shortFilename == null && i < classpath.length; ++i) {if (inputFile.getAbsolutePath().startsWith(classpath[i].getAbsolutePath())) {shortFilename = removePathPrefix(classpath[i], inputFile);}}if (artifact != null) {getLog().debug("Replacing in " + filename + " with artifact " + //$NON-NLS-1$ //$NON-NLS-2$ArtifactUtils.key(artifact));} else {getLog().debug("Replacing in " + filename + " without artifact"); //$NON-NLS-1$ //$NON-NLS-2$}try {outputFile.getParentFile().mkdirs();Reader reader = null;Charset charset = null;if (detectEncoding) {charset = detectEncoding(inputFile);}if (charset == null) {charset = Charset.defaultCharset();}getLog().debug("Copying file '" //$NON-NLS-1$+ inputFile.getName() + "' with '" //$NON-NLS-1$+ charset.displayName() + "' encoding"); //$NON-NLS-1$try (FileInputStream fis = new FileInputStream(inputFile)) {try (ReadableByteChannel channel = Channels.newChannel(fis)) {reader = Channels.newReader(channel, charset.newDecoder(), -1);if (reader == null) {reader = new FileReader(inputFile);}final BufferedReader br = new BufferedReader(reader);try (FileOutputStream fos = new FileOutputStream(outputFile)) {final WritableByteChannel wChannel = Channels.newChannel(fos);final Writer writer = Channels.newWriter(wChannel, charset.newEncoder(), -1);String line;int nline = 1;while ((line = br.readLine()) != null) {line = replaceInString(inputFile, nline, shortFilename, artifact, line, replacementType);writer.write(line);writer.write("\n"); //$NON-NLS-1$++nline;}writer.flush();}}}if (sourceFile == null) {fileCopy(outputFile, targetFile);outputFile.delete();buildContext.refresh(outputFile.getParentFile());}} catch (IOException e) {throw new MojoExecutionException(e.getLocalizedMessage(), e);} finally {if (sourceFile == null && outputFile.exists()) {outputFile.delete();buildContext.refresh(outputFile.getParentFile());} else if (outputFile.exists()) {buildContext.refresh(outputFile);}}}
public void replaceStringInFile(File folder, File file, String template, String[] replacement)            throws IOException {        System.out.println("Patching file: "+file.getCanonicalPath());        String name = file.getName();        File origFile = new File(folder, name+".orig");        file.renameTo(origFile);        File temporaryFile = new File(folder, name+".tmp");        if (temporaryFile.exists()) {            temporaryFile.delete();        }        temporaryFile.createNewFile();        String line;        FileInputStream fis = new FileInputStream(origFile);        PrintWriter pw = new PrintWriter(temporaryFile);        BufferedReader br = new BufferedReader(new InputStreamReader(fis));        while ((line = br.readLine()) != null) {            if (line.trim().equals(template)) {                for (String s : replacement) {                    pw.println(s);                }            } else {                pw.println(line);            }        }        pw.flush();        pw.close();        if (!temporaryFile.renameTo(new File(folder, name))) {            throw new IOException("Unable to rename file in folder "+folder.getName()+                    " from \""+temporaryFile.getName()+"\" into \""+name +                    "\n Original file saved as "+origFile.getName());        }        origFile.delete();    }
public static void replaceFile(String fileName, final Map<String, List<Replacer>> profiles, Charset charset)      throws Exception, FileNotFoundException {    File file = new File(fileName);    if (file.isFile() && !file.isHidden()) {      List<Replacer> replacers = profiles.get(Strings.substringAfterLast(fileName, "."));      if (null == replacers) { return; }      logger.info("processing {}", fileName);      String filecontent = Files.readFileToString(file, charset);      filecontent = Replacer.process(filecontent, replacers);      writeToFile(filecontent, fileName, charset);    } else {      String[] subFiles = file.list(new FilenameFilter() {        public boolean accept(File dir, String name) {          if (dir.isDirectory()) return true;          boolean matched = false;          for (String key : profiles.keySet()) {            matched = name.endsWith(key);            if (matched) return true;          }          return false;        }      });      if (null != subFiles) {        for (int i = 0; i < subFiles.length; i++) {          replaceFile(fileName + '/' + subFiles[i], profiles, charset);        }      }    }  }
protected synchronized void replaceInFileBuffered(File sourceFile, File targetFile, ReplacementType replacementType,File[] classpath, boolean detectEncoding) throws MojoExecutionException {if (this.replacementTreatedFiles.contains(targetFile)&& targetFile.exists()) {getLog().debug("Skiping " + targetFile //$NON-NLS-1$+ " because is was already treated for replacements"); //$NON-NLS-1$return;}replaceInFile(sourceFile, targetFile, replacementType, classpath, detectEncoding);}
public static Action moveAndReplaceFile(String srcPath, String destPath, String tempDir) {        Action seq = new Action();        seq.add(deleteFile(destPath, tempDir));        seq.add(moveFileToEmptyPath(srcPath, destPath));        return seq;    }
public String replaceFileTemplate(String filespec, int timeIndex) {        GradsTimeStruct ts = makeTimeStruct(timeIndex);        //System.out.println(ts);        String retString = filespec;        String format;        while (hasTimeTemplate(retString)) {            // initial time            if (retString.indexOf("%ix1") >= 0) {                retString = retString.replaceAll("%ix1",                        String.format("%d", initialTime.year / 10));            }            if (retString.indexOf("%ix3") >= 0) {                retString = retString.replaceAll("%ix3",                        String.format("%03d", initialTime.year / 10));            }            if (retString.indexOf("%iy2") >= 0) {                int cent = initialTime.year / 100;                int val  = initialTime.year - cent * 100;                retString = retString.replaceAll("%iy2",                        String.format("%02d", val));            }            if (retString.indexOf("%iy4") >= 0) {                retString = retString.replaceAll("%iy4",                        String.format("%d", initialTime.year));            }            if (retString.indexOf("%im1") >= 0) {                retString = retString.replaceAll("%im1",                        String.format("%d", initialTime.month));            }            if (retString.indexOf("%im2") >= 0) {                retString = retString.replaceAll("%im2",                        String.format("%02d", initialTime.month));            }            if (retString.indexOf("%imc") >= 0) {                retString = retString.replaceAll("%imc",                        GradsTimeStruct.months[initialTime.month - 1]);            }            if (retString.indexOf("%id1") >= 0) {                retString = retString.replaceAll("%id1",                        String.format("%d", initialTime.day));            }            if (retString.indexOf("%id2") >= 0) {                retString = retString.replaceAll("%id2",                        String.format("%02d", initialTime.day));            }            if (retString.indexOf("%ih1") >= 0) {                retString = retString.replaceAll("%ih1",                        String.format("%d", initialTime.hour));            }            if (retString.indexOf("%ih2") >= 0) {                retString = retString.replaceAll("%ih2",                        String.format("%02d", initialTime.hour));            }            if (retString.indexOf("%ih3") >= 0) {                retString = retString.replaceAll("%ih3",                        String.format("%03d", initialTime.hour));            }            if (retString.indexOf("%in2") >= 0) {                retString = retString.replaceAll("%in2",                        String.format("%02d", initialTime.minute));            }            // any time            // decade            if (retString.indexOf("%x1") >= 0) {                retString = retString.replaceAll("%x1",                        String.format("%d", ts.year / 10));            }            if (retString.indexOf("%x3") >= 0) {                retString = retString.replaceAll("%x3",                        String.format("%03d", ts.year / 10));            }            // year            if (retString.indexOf("%y2") >= 0) {                int cent = ts.year / 100;                int val  = ts.year - cent * 100;                retString = retString.replaceAll("%y2",                        String.format("%02d", val));            }            if (retString.indexOf("%y4") >= 0) {                retString = retString.replaceAll("%y4",                        String.format("%d", ts.year));            }            // month            if (retString.indexOf("%m1") >= 0) {                retString = retString.replaceAll("%m1",                        String.format("%d", ts.month));            }            if (retString.indexOf("%m2") >= 0) {                retString = retString.replaceAll("%m2",                        String.format("%02d", ts.month));            }            if (retString.indexOf("%mc") >= 0) {                retString = retString.replaceAll("%mc",                        GradsTimeStruct.months[ts.month - 1]);            }            // day            if (retString.indexOf("%d1") >= 0) {                retString = retString.replaceAll("%d1",                        String.format("%d", ts.day));            }            if (retString.indexOf("%d2") >= 0) {                retString = retString.replaceAll("%d2",                        String.format("%02d", ts.day));            }            // hour            if (retString.indexOf("%h1") >= 0) {                retString = retString.replaceAll("%h1",                        String.format("%d", ts.hour));            }            if (retString.indexOf("%h2") >= 0) {                retString = retString.replaceAll("%h2",                        String.format("%02d", ts.hour));            }            if (retString.indexOf("%h3") >= 0) {                retString = retString.replaceAll("%h3",                        String.format("%03d", ts.hour));            }            // minute            if (retString.indexOf("%n2") >= 0) {                retString = retString.replaceAll("%n2",                        String.format("%02d", ts.minute));            }            // julian day            if (retString.indexOf("%j3") >= 0) {                retString = retString.replaceAll("%j3",                        String.format("%03d", ts.jday));            }            // time index (1 based)            if (retString.indexOf("%t1") >= 0) {                retString = retString.replaceAll("%t1",                        String.format("%d", timeIndex + 1));            }            if (retString.indexOf("%t2") >= 0) {                retString = retString.replaceAll("%t2",                        String.format("%02d", timeIndex + 1));            }            if (retString.indexOf("%t3") >= 0) {                retString = retString.replaceAll("%t3",                        String.format("%03d", timeIndex + 1));            }            if (retString.indexOf("%t4") >= 0) {                retString = retString.replaceAll("%t4",                        String.format("%04d", timeIndex + 1));            }            if (retString.indexOf("%t5") >= 0) {                retString = retString.replaceAll("%t5",                        String.format("%05d", timeIndex + 1));            }            if (retString.indexOf("%t6") >= 0) {                retString = retString.replaceAll("%t6",                        String.format("%06d", timeIndex + 1));            }            // time index (0 based)            if (retString.indexOf("%tm1") >= 0) {                retString = retString.replaceAll("%tm1",                        String.format("%d", timeIndex));            }            if (retString.indexOf("%tm2") >= 0) {                retString = retString.replaceAll("%tm2",                        String.format("%02d", timeIndex));            }            if (retString.indexOf("%tm3") >= 0) {                retString = retString.replaceAll("%tm3",                        String.format("%03d", timeIndex));            }            if (retString.indexOf("%tm4") >= 0) {                retString = retString.replaceAll("%tm4",                        String.format("%04d", timeIndex));            }            if (retString.indexOf("%tm5") >= 0) {                retString = retString.replaceAll("%tm5",                        String.format("%05d", timeIndex));            }            if (retString.indexOf("%tm6") >= 0) {                retString = retString.replaceAll("%tm6",                        String.format("%06d", timeIndex));            }            // forecast hours            if (retString.indexOf("%f") >= 0) {                int mins = (int) getValues()[timeIndex] * 60;                int tdif;                if (retString.indexOf("%f2") >= 0) {                    format = "%02d";                    tdif   = mins / 60;                    if (tdif > 99) {                        format = "%d";                    }                    retString = retString.replaceAll("%f2",                            String.format(format, tdif));                }                if (retString.indexOf("%f3") >= 0) {                    format = "%03d";                    tdif   = mins / 60;                    if (tdif > 999) {                        format = "%d";                    }                    retString = retString.replaceAll("%f3",                            String.format(format, tdif));                }                if (retString.indexOf("%fn2") >= 0) {                    format = "%02d";                    if (mins > 99) {                        format = "%d";                    }                    retString = retString.replaceAll("%fn2",                            String.format(format, mins));                }                if (retString.indexOf("%fhn2") >= 0) {                    tdif = mins;                    int hrs = tdif / 60;                    int mns = tdif - (hrs * 60);                    format = "%02d%02d";                    if (hrs > 99) {                        format = "%d%02d";                    }                    retString = retString.replaceAll("%fhn2",                            String.format(format, hrs, mns));                }                if (retString.indexOf("%fdhn2") >= 0) {                    tdif = mins;                    int dys = tdif / 1440;                    int hrs = (tdif - (dys * 1440)) / 60;                    int mns = tdif - (dys * 1440) - (hrs * 60);                    format = "%02d%02d%02d";                    if (dys > 99) {                        format = "%d%02d%02d";                    }                    retString = retString.replaceAll("%fdhn2",                            String.format(format, dys, hrs, mns));                }            }        }        return retString;    }
public String replaceFileTemplate(String filespec, int ensIndex) {        return filespec.replaceAll(ENS_TEMPLATE_ID,                                   getEnsembleNames().get(ensIndex));    }
public Table file(File file) throws IOException {String extension = Files.getFileExtension(file.getCanonicalPath());DataReader<?> reader = registry.getReaderForExtension(extension);return reader.read(new Source(file));    }
@Deprecated    public WaitFileConditionBuilder file(String filePath) {        FileCondition condition = new FileCondition();        condition.setFilePath(filePath);        container.setCondition(condition);        this.buildAndRun();        return new WaitFileConditionBuilder(condition, this);    }

k means clustering
public void cluster (ArrayList<Instance> insts) {System.out.println("Initial centers");for(int i=0;i<k;i++){assignedClusters[i] = new ArrayList<Instance>();}for(int i=0;i<insts.size();i++){assignedClusters[i%k].add(insts.get(i));}for(int i=0;i<k;i++){centroids[i] = calculateCentroid(assignedClusters[i]);clusterQualities[i] = calculateClusterQuality(assignedClusters[i], centroids[i]);}for (int numChanged = 0, itr = 0; (numChanged > 0) || (itr == 0); ++itr) {numChanged = 0;while (true) {int numReassigned = doBatchKmeans();System.out.println("After an iteration of Batch K-Means, " +numReassigned + " documents were moved.");double oldQuality = 0.0;double newQuality = 0.0;for (int b = 0; b < this.centroids.length; ++b) {oldQuality += this.clusterQualities[b];newQuality += this.newQualities[b];}double qualityDelta = oldQuality - newQuality;System.out.println("Change in quality is: " + qualityDelta);if (qualityDelta < this.TOL) {System.out.println("Benefit of change is below tolerance... Switching to incremental...\n");break;}if (numReassigned == 0) {System.out.println("Batch K-Means has made no changes! Switching to incremental...\n");break;}// We like the new results. Let's make them authoritativefor (int kk = 0; kk < this.assignedClusters.length; ++kk) {this.assignedClusters[kk] = this.newClusters[kk];this.centroids[kk] = this.newCentroids[kk];this.clusterQualities[kk] = this.newQualities[kk];}numChanged = numReassigned;    // Record the fact we made a change!}double qual = 0.0;for (int i = 0; i < this.clusterQualities.length; ++i) {qual += this.clusterQualities[i];}System.out.println("Quality of partition generated by Batch K-Means: " +qual);}System.out.println("Batch K-Means Complete!\n");}
public static ClusteringServiceConfigurationBuilder cluster(URI clusterUri) {    return new ClusteringServiceConfigurationBuilder(new ConnectionSource.ClusterUri(clusterUri), TimeoutsBuilder.timeouts().build(), DEFAULT_AUTOCREATE);  }
public static ClusteringServiceConfigurationBuilder cluster(Iterable<InetSocketAddress> servers, String clusterTierManager) {    return new ClusteringServiceConfigurationBuilder(new ConnectionSource.ServerList(servers, clusterTierManager), TimeoutsBuilder.timeouts().build(), DEFAULT_AUTOCREATE);  }
public List<Cluster> cluster(final Collection<Point2D> points) {    final List<Cluster> clusters = new ArrayList<Cluster>();        final Map<Point2D, PointStatus> visited = new HashMap<Point2D, DBScan.PointStatus>();        KDTree<Point2D> tree = new KDTree<Point2D>(2);                // Populate the kdTree        for (final Point2D point : points) {        double[] key = {point.x, point.y};        tree.insert(key, point);        }                        for (final Point2D point : points) {            if (visited.get(point) != null) {                continue;            }            final List<Point2D> neighbors = getNeighbors(point, tree);            if (neighbors.size() >= minPoints) {                // DBSCAN does not care about center points                final Cluster cluster = new Cluster(clusters.size());                clusters.add(expandCluster(cluster, point, neighbors, tree, visited));            } else {                visited.put(point, PointStatus.NOISE);            }        }        for (Cluster cluster : clusters) {        cluster.calculateCentroid();        }                return clusters;    }
public Assignments cluster(Matrix matrix, int numClusters,                                int kappa, double beta,                               SimilarityFunction simFunc) {        int rows = matrix.rows();        int cols = matrix.columns();        // f is the facility cost;        double f = 1d / (numClusters * (1 + Math.log(rows)));                // This list contains at most kappa facilities.        List<CandidateCluster> facilities =             new ArrayList<CandidateCluster>(kappa);        for (int r = 0; r < rows; /* no auto-increment */) {                        for ( ; facilities.size() <= kappa && r < rows; ++r) {                DoubleVector x = matrix.getRowVector(r);                                CandidateCluster closest = null;                // Delta is ultimately assigned the lowest inverse-similarity                // (distance) to any of the current facilities' center of mass                double delta = Double.MAX_VALUE;                for (CandidateCluster y : facilities) {                    double similarity =                         simFunc.sim(x, y.centerOfMass());                    double invSim = invertSim(similarity);                    if (invSim < delta) {                        delta = invSim;                        closest = y;                    }                }                                // Base case: If this is the first data point and there are no                // other facilities                //                // Or if we surpass the probability of a new event occurring                // (line 6)                if (closest == null || Math.random() < delta / f) {                    CandidateCluster fac = new CandidateCluster();                    fac.add(r, x);                    facilities.add(fac);                }                // Otherwise, add this data point to an existing facility                else {                    closest.add(r, x);                }            }            // If we still have data points left to process (line 10:)            if (r < rows) {                // Check whether we have more than kappa clusters (line 11).                // Kappa provides the upper bound on the clusters (facilities)                // that are kept at any given time.  If there are more, then we                // need to consolidate facilities                while (facilities.size() > kappa) {                    f *= beta;                    int curNumFacilities = facilities.size();                    List<CandidateCluster> consolidated =                         new ArrayList<CandidateCluster>(kappa);                    consolidated.add(facilities.get(0));                    for (int j = 1; j < curNumFacilities; ++j) {                        CandidateCluster x = facilities.get(j);                        int pointsAssigned = x.size();                        // Compute the similarity of this facility to all other                        // consolidated facilities.  Delta represents the lowest                        // inverse-similarity (distance) to another facility.                        // See line 17 of the algorithm.                        double delta = Double.MAX_VALUE;                                                CandidateCluster closest = null;                        for (CandidateCluster y : consolidated) {                            double similarity =                                 simFunc.sim(x.centerOfMass(), y.centerOfMass());                            double invSim = invertSim(similarity);                            if (invSim < delta) {                                delta = invSim;                                closest = y;                            }                        }                                                 // Use (pointsAssigned * delta / f) as a threshold for                        // whether this facility could constitute a new event.                        // If a random check is less than it, then we nominate                        // this facilty to continue.                        if (Math.random() < (pointsAssigned * delta) / f) {                            consolidated.add(x);                        }                        // Otherwise, we consolidate the points in this                        // community to the closest facility                        else {                            assert closest != null : "no closest facility";                            closest.merge(x);                        }                    }                    verbose(LOGGER, "Consolidated %d facilities down to %d",                            facilities.size(), consolidated.size());                    facilities = consolidated;                }            }            // Once we have processed all of the items in the stream (line 23 of            // algorithm), reduce the kappa clusters into k clusters.            else {                // Edge case for when we already have fewer facilities than we                // need                if (facilities.size() <= numClusters) {                    verbose(LOGGER, "Had fewer facilities, %d, than the " +                            "requested number of clusters %d",                            facilities.size(), numClusters);                    // There's no point in reducing the number of facilities                    // further since we're under the desired amount, nor can we                    // go back and increase the number of facilities since all                    // the data has been seen at this point.  Therefore, just                    // loop through the candidates and report their assignemnts.                    Assignment[] assignments = new Assignment[rows];                    int numFacilities = facilities.size();                    for (int j = 0; j < numFacilities; ++j) {                        CandidateCluster fac = facilities.get(j);                        veryVerbose(LOGGER, "Facility %d had a center of mass at %s",                                    j, fac.centerOfMass());                                                int clusterId = j;                        IntIterator iter = fac.indices().iterator();                        while (iter.hasNext()) {                            int row = iter.nextInt();                            assignments[row] =                                 new HardAssignment(clusterId);                        }                    }                    return new Assignments(numClusters, assignments, matrix);                                    }                else {                    verbose(LOGGER, "Had more than %d facilities, " +                            "consolidating to %d", facilities.size(),                             numClusters);                                        List<DoubleVector> facilityCentroids =                         new ArrayList<DoubleVector>(facilities.size());                    int[] weights = new int[facilities.size()];                    int i = 0;                    for (CandidateCluster fac : facilities) {                        facilityCentroids.add(fac.centerOfMass());                        weights[i++] = fac.size();                    }                    // Wrap the facilities centroids in a matrix for convenience                    Matrix m = Matrices.asMatrix(facilityCentroids);                    // Select the initial seed points for reducing the kappa                    // clusters to k using the generalized ORSS selection                    // process, which supports data comparisons other than                    // Euclidean distance                    GeneralizedOrssSeed orss = new GeneralizedOrssSeed(simFunc);                    DoubleVector[] centroids = orss.chooseSeeds(numClusters, m);                    assert nonNullCentroids(centroids)                         : "ORSS seed returned too few centroids";                                        // This records the assignments of the kappa facilities to                    // the k centers.  Initially, everyhting is assigned to the                    // same center and iterations repeat until convergence.                    int[] facilityAssignments = new int[facilities.size()];                                        // Using those facilities as starting points, run k-means on                    // the facility centroids until no facilities change their                    // memebership.                    int numChanged = 0;                    int kmeansIters = 0;                    do {                        numChanged = 0;                        // Recompute the new centroids each time                        DoubleVector[] updatedCentroids =                             new DoubleVector[numClusters];                        for (i = 0; i < updatedCentroids.length; ++i)                             updatedCentroids[i] = new DenseVector(cols);                        int[] updatedCentroidSizes = new int[numClusters];                        double similaritySum = 0;                                                // For each CandidateCluster find the most similar centroid                        i = 0;                        for (CandidateCluster fac : facilities) {                            int mostSim = -1;                            double highestSim = -1;                            for (int j = 0; j < centroids.length; ++j) {//                                  System.out.printf("centroids[%d]: %s%n fac.centroid(): %s%n",//                                                    j, centroids[j], //                                                    fac.centerOfMass());                                double sim = simFunc.sim(centroids[j],                                                          fac.centerOfMass());                                if (sim > highestSim) {                                    highestSim = sim;                                    mostSim = j;                                }                            }                            // For the most similar centroid, update its center                            // of mass for the next round with the weighted                            // vector                            VectorMath.add(updatedCentroids[mostSim],                                            fac.sum());                            updatedCentroidSizes[mostSim] += fac.size();                            int curAssignment = facilityAssignments[i];                            facilityAssignments[i] = mostSim;                            similaritySum += highestSim;                            if (curAssignment != mostSim) {                                 veryVerbose(LOGGER, "Facility %d changed its " +                                            "centroid from %d to %d",                                            i, curAssignment, mostSim);                                numChanged++;                            }                            i++;                        }                        // Once all the facilities have been assigned to one of                        // the k-centroids, recompute the centroids by                        // normalizing the sum of the weighted vectors according                        // the number of points                        for (int j = 0; j < updatedCentroids.length; ++j) {                            DoubleVector v = updatedCentroids[j];                            int size = updatedCentroidSizes[j];                            for (int k = 0; k < cols; ++k)                                 v.set(k, v.get(k) / size);                            // Update this centroid for the next round                            centroids[j] = v;                                                    }                        veryVerbose(LOGGER, "%d centroids swapped their facility",                                    numChanged);                    } while (numChanged > 0 &&                                  ++kmeansIters < MAX_BATCH_KMEANS_ITERS);                    // Use the final assignments to create assignments for each                    // of the input data points                    Assignment[] assignments = new Assignment[rows];                    for (int j = 0; j < facilityAssignments.length; ++j) {                        CandidateCluster fac = facilities.get(j);                        veryVerbose(LOGGER, "Facility %d had a center of mass at %s",                                    j, fac.centerOfMass());                                                int clusterId = facilityAssignments[j];                        IntIterator iter = fac.indices().iterator();                        while (iter.hasNext()) {                            int row = iter.nextInt();                            assignments[row] =                                 new HardAssignment(clusterId);                        }                    }                    return new Assignments(numClusters, assignments, matrix);                }            }        }        throw new AssertionError(            "Processed all data points without making assignment");    }
public Assignments cluster(Matrix matrix, int numClusters, Properties props) {        if (matrix == null || props == null)            throw new NullPointerException();        if (numClusters < 1)            throw new IllegalArgumentException(                "The number of clusters must be positive");        if (numClusters > matrix.rows())            throw new IllegalArgumentException(                "The number of clusters exceeds the number of data points");        int kappa = (int)(numClusters * (1 + Math.log(matrix.rows())));        String kappaProp = props.getProperty(KAPPA_PROPERTY);        if (kappaProp != null) {            try {                int k = Integer.parseInt(kappaProp);                if (k < numClusters                        || k > numClusters * (1 + Math.log(matrix.rows())))                    throw new IllegalArgumentException(                        "kappa must be at least the number of clusters, k, " +                        "and at most k * log(matrix.rows())");                kappa = k;            } catch (NumberFormatException nfe) {                throw new IllegalArgumentException("Invalid kappa", nfe);            }        }        double beta = DEFAULT_BETA;        String betaProp = props.getProperty(BETA_PROPERTY);        if (betaProp != null) {            try {                double b = Double.parseDouble(betaProp);                if (b <= 0)                    throw new IllegalArgumentException(                        "beta must be positive");                beta = b;            } catch (NumberFormatException nfe) {                throw new IllegalArgumentException("Invalid beta", nfe);            }        }        SimilarityFunction simFunc = DEFAULT_SIMILARITY_FUNCTION;        String simFuncProp = props.getProperty(SIMILARITY_FUNCTION_PROPERTY);        if (simFuncProp != null) {            try {                SimilarityFunction sf = ReflectionUtil                    .<SimilarityFunction>getObjectInstance(simFuncProp);                simFunc = sf;            } catch (Error e) {                throw new IllegalArgumentException(                    "Invalid similarity function class", e);            }        }        return cluster(matrix, numClusters, kappa, beta, simFunc);    }
protected double cluster(DataSet data, boolean doInit, int[] medioids, int[] assignments, List<Double> cacheAccel, boolean parallel)    {        DoubleAdder totalDistance =new DoubleAdder();        LongAdder changes = new LongAdder();        Arrays.fill(assignments, -1);//-1, invalid category!                int[] bestMedCand = new int[medioids.length];        double[] bestMedCandDist = new double[medioids.length];        List<Vec> X = data.getDataVectors();        final List<Double> accel;                if(doInit)        {            TrainableDistanceMetric.trainIfNeeded(dm, data);            accel = dm.getAccelerationCache(X);            selectIntialPoints(data, medioids, dm, accel, rand, seedSelection);        }        else            accel = cacheAccel;        int iter = 0;        do        {            changes.reset();            totalDistance.reset();                        ParallelUtils.run(parallel, data.size(), (start, end)->            {                for(int i = start; i < end; i++)                {                    int assignment = 0;                    double minDist = dm.dist(medioids[0], i, X, accel);                    for (int k = 1; k < medioids.length; k++)                    {                        double dist = dm.dist(medioids[k], i, X, accel);                        if (dist < minDist)                        {                            minDist = dist;                            assignment = k;                        }                    }                    //Update which cluster it is in                    if (assignments[i] != assignment)                    {                        changes.increment();                        assignments[i] = assignment;                    }                    totalDistance.add(minDist * minDist);                }            });                        //TODO this update may be faster by using more memory, and actually moiving people about in the assignment loop above            //Update the medoids            Arrays.fill(bestMedCandDist, Double.MAX_VALUE);            for(int i = 0; i < data.size(); i++)            {                double thisCandidateDistance;                final int clusterID = assignments[i];                final int medCandadate = i;                                final int ii = i;                thisCandidateDistance = ParallelUtils.range(data.size(), parallel)                        .filter(j -> j != ii && assignments[j] == clusterID)                        .mapToDouble(j -> Math.pow(dm.dist(medCandadate, j, X, accel), 2))                        .sum();                                if(thisCandidateDistance < bestMedCandDist[clusterID])                {                    bestMedCand[clusterID] = i;                    bestMedCandDist[clusterID] = thisCandidateDistance;                }            }            System.arraycopy(bestMedCand, 0, medioids, 0, medioids.length);        }        while( changes.sum() > 0 && iter++ < iterLimit);                return totalDistance.sum();    }
public CharSequence cluster() {    if (d1 == 0) {      // Application portion is empty      return null;    } else {      return (dN > 0 && dN == asg.length()) ? asg() : substr(asg, 0, dN);    }  }
public String cluster() {    if (d1 == 0) {      // Application portion is empty      return null;    } else {      return (dN > 0 && dN == asg.length()) ? asg() : substr(asg, 0, dN);    }  }
@SuppressWarnings("deprecation")public static synchronized Cluster cluster(Env env, String prefix) throws APIException, IOException {if(cb == null) {String pre;if(prefix==null) {pre="";} else {env.info().log("Cassandra Connection for ",prefix);pre = prefix+'.';}cb = Cluster.builder();String str = env.getProperty(pre+CASSANDRA_CLUSTERS_PORT,"9042");if(str!=null) {env.init().log("Cass Port = ",str );cb.withPort(Integer.parseInt(str));}str = env.getProperty(pre+CASSANDRA_CLUSTERS_USER_NAME,null);if(str!=null) {env.init().log("Cass User = ",str );String epass = env.getProperty(pre + CASSANDRA_CLUSTERS_PASSWORD,null);if(epass==null) {throw new APIException("No Password configured for " + str);}//TODO Figure out way to ensure Decryptor setting in AuthzEnvif(env instanceof AuthzEnv) {cb.withCredentials(str,((AuthzEnv)env).decrypt(epass,true));} else {cb.withCredentials(str, env.decryptor().decrypt(epass));}}str = env.getProperty(pre+CASSANDRA_RESET_EXCEPTIONS,null);if(str!=null) {env.init().log("Cass ResetExceptions = ",str );for(String ex : Split.split(',', str)) {resetExceptions.add(new Resettable(env,ex));}}str = env.getProperty(LATITUDE,env.getProperty("AFT_LATITUDE",null));Double lat = str!=null?Double.parseDouble(str):null;str = env.getProperty(LONGITUDE,env.getProperty("AFT_LONGITUDE",null));Double lon = str!=null?Double.parseDouble(str):null;if(lat == null || lon == null) {throw new APIException("LATITUDE(or AFT_LATITUDE) and/or LONGITUDE(or AFT_LATITUDE) are not set");}env.init().printf("Service Latitude,Longitude = %f,%f",lat,lon);str = env.getProperty(pre+CASSANDRA_CLUSTERS,"localhost");env.init().log("Cass Clusters = ",str );String[] machs = Split.split(',', str);String[] cpoints = new String[machs.length];String bestDC = null;int numInBestDC = 1;double mlat, mlon,temp,distance = -1.0;for(int i=0;i<machs.length;++i) {String[] minfo = Split.split(':',machs[i]);if(minfo.length>0) {cpoints[i]=minfo[0];}// Calc closest DC with Great Circleif(minfo.length>3) {mlat = Double.parseDouble(minfo[2]);mlon = Double.parseDouble(minfo[3]);if((temp=GreatCircle.calc(lat, lon, mlat, mlon)) > distance) {distance = temp;if(bestDC!=null && bestDC.equals(minfo[1])) {++numInBestDC;} else {bestDC = minfo[1];numInBestDC = 1;}} else {if(bestDC!=null && bestDC.equals(minfo[1])) {++numInBestDC;}}}}cb.addContactPoints(cpoints);if(bestDC!=null) {// 8/26/2016 Management has determined that Accuracy is preferred over speed in bad situations// Local DC Aware Load Balancing appears to have the highest normal performance, with the best// Degraded Accuracycb.withLoadBalancingPolicy(new DCAwareRoundRobinPolicy(bestDC, numInBestDC, true /*allow LocalDC to look at other DCs for LOCAL_QUORUM */));env.init().printf("Cassandra configured for DCAwareRoundRobinPolicy at %s with emergency remote of up to %d node(s)",bestDC, numInBestDC);} else {env.init().printf("Cassandra is using Default Policy, which is not DC aware");}}return cb.build();}

connect to sql
public void connectToPostgreSQLDatabase(String database, String host, String port, String user, String password, Boolean secure, String ca, String crt, String key) throws SQLException {        if (port.startsWith("[")) {            port = port.substring(1, port.length() - 1);        }        if (!secure) {            if (password == null) {                password = "stratio";            }            try {                myConnection = DriverManager.getConnection("jdbc:postgresql://" + host + ":" + port + "/" + database, user, password);            } catch (SQLException se) {                // log the exception                this.getLogger().error(se.getMessage());                // re-throw the exception                throw se;            }        } else {            Properties props = new Properties();            if (user != null) {                props.setProperty("user", user);            }            if (ca != null) {                props.setProperty("sslrootcert", ca);            }            if (crt != null) {                props.setProperty("sslcert", crt);            }            if (key != null) {                props.setProperty("sslkey", key);            }            props.setProperty("password", "null");            props.setProperty("ssl", "true");            props.setProperty("sslmode", "verify-full");            try {                myConnection = DriverManager.getConnection("jdbc:postgresql://" + host + ":" + port + "/" + database, props);            } catch (SQLException se) {                // log the exception                this.getLogger().error(se.getMessage());                // re-throw the exception                throw se;            }        }    }
public Link connect(int id, int bandwidth, Switch sw, PhysicalElement pe) {        // Create a new link with a specific id        Link link = lnBuilder.newLink(id, bandwidth, sw, pe);        links.add(link);        return link;    }
public List<Link> connect(int bandwidth, Switch sw, List<? extends PhysicalElement> pelts) {        return pelts.stream().map(pe -> connect(bandwidth, sw, pe)).collect(Collectors.toList());    }
public List<Link> connect(int bandwidth, Switch sw, Node... nodes) {        List<Link> l = new ArrayList<>();        for (Node n : nodes) {            l.add(connect(bandwidth, sw, n));        }        return l;    }
public List<Link> connect(int bandwidth, Switch sw, PhysicalElement... pelts) {        List<Link> l = new ArrayList<>();        for (PhysicalElement pe : pelts) {            l.add(connect(bandwidth, sw, pe));        }        return l;    }
private void connect(CompletableFuture<Connection> future) {    if (!selector.hasNext()) {      LOGGER.debug("{} - Failed to connect to the cluster", id);      future.complete(null);    } else {      Address address = selector.next();      LOGGER.debug("{} - Connecting to {}", id, address);      client.connect(address).whenComplete((c, e) -> handleConnection(address, c, e, future));    }  }
private CompletableFuture<Connection> connect() {    // If the address selector has been reset then reset the connection.    if (selector.state() == AddressSelector.State.RESET && connection != null) {      if (connectFuture != null) {        return connectFuture;      }      CompletableFuture<Connection> future = new OrderedCompletableFuture<>();      future.whenComplete((r, e) -> this.connectFuture = null);      this.connectFuture = future;      Connection oldConnection = this.connection;      this.connection = null;      oldConnection.close();      connect(future);      return future;    }    // If a connection was already established then use that connection.    if (connection != null) {      return CompletableFuture.completedFuture(connection);    }    // If a connection is currently being established then piggyback on the connect future.    if (connectFuture != null) {      return connectFuture;    }    // Create a new connect future and connect to the first server in the cluster.    CompletableFuture<Connection> future = new OrderedCompletableFuture<>();    future.whenComplete((r, e) -> this.connectFuture = null);    this.connectFuture = future;    reset().connect(future);    return future;  }
public void connect (int timeout, InetAddress host, int tcpPort) throws IOException {connect(timeout, host, tcpPort, -1);}
public void connect (int timeout, InetAddress host, int tcpPort, int udpPort) throws IOException {if (host == null) throw new IllegalArgumentException("host cannot be null.");if (Thread.currentThread() == getUpdateThread())throw new IllegalStateException("Cannot connect on the connection's update thread.");this.connectTimeout = timeout;this.connectHost = host;this.connectTcpPort = tcpPort;this.connectUdpPort = udpPort;close();if (INFO) {if (udpPort != -1)info("kryonet", "Connecting: " + host + ":" + tcpPort + "/" + udpPort);elseinfo("kryonet", "Connecting: " + host + ":" + tcpPort);}id = -1;try {if (udpPort != -1) udp = new UdpConnection(serialization, tcp.readBuffer.capacity());long endTime;synchronized (updateLock) {tcpRegistered = false;selector.wakeup();endTime = System.currentTimeMillis() + timeout;tcp.connect(selector, new InetSocketAddress(host, tcpPort), 5000);}// Wait for RegisterTCP.synchronized (tcpRegistrationLock) {while (!tcpRegistered && System.currentTimeMillis() < endTime) {try {tcpRegistrationLock.wait(100);} catch (InterruptedException ignored) {}}if (!tcpRegistered) {throw new SocketTimeoutException("Connected, but timed out during TCP registration.\n"+ "Note: Client#update must be called in a separate thread during connect.");}}if (udpPort != -1) {InetSocketAddress udpAddress = new InetSocketAddress(host, udpPort);synchronized (updateLock) {udpRegistered = false;selector.wakeup();udp.connect(selector, udpAddress);}// Wait for RegisterUDP reply.synchronized (udpRegistrationLock) {while (!udpRegistered && System.currentTimeMillis() < endTime) {RegisterUDP registerUDP = new RegisterUDP();registerUDP.connectionID = id;udp.send(this, registerUDP, udpAddress);try {udpRegistrationLock.wait(100);} catch (InterruptedException ignored) {}}if (!udpRegistered)throw new SocketTimeoutException("Connected, but timed out during UDP registration: " + host + ":" + udpPort);}}} catch (IOException ex) {close();throw ex;}}
public void connect (int timeout, String host, int tcpPort) throws IOException {connect(timeout, InetAddress.getByName(host), tcpPort, -1);}

html encode string
protected static byte[] encodeString(String string) {        Element element = getStringCache().get(string);        byte[] encoded = (element == null ? null : (byte[]) element.getObjectValue());        if (encoded == null) {            ByteBuffer buf = AMF.CHARSET.encode(string);            encoded = new byte[buf.limit()];            buf.get(encoded);            getStringCache().put(new Element(string, encoded));        }        return encoded;    }
public static StringBuilder encodeString(StringBuilder buf,                                             String path,                                             String encode) {        if (buf == null) {            for (int i = 0; i < path.length(); i++) {                char c = path.charAt(i);                if (c == '%' || encode.indexOf(c) >= 0) {                    buf = new StringBuilder(path.length() << 1);                    break;                }            }            if (buf == null)                return null;        }        for (int i = 0; i < path.length(); i++) {            char c = path.charAt(i);            if (c == '%' || encode.indexOf(c) >= 0) {                buf.append('%');                StringUtils.append(buf, (byte) (0xff & c), 16);            } else                buf.append(c);        }        return buf;    }
protected byte[] encodeString(String in) {    byte[] rv = null;    try {      rv = in.getBytes(this.charset);    } catch (UnsupportedEncodingException e) {      throw new RuntimeException(e);    }    return rv;  }
public static String encodeString(final String string, final String encoding) throwsUnsupportedEncodingException {byte[] stringBytes = string.getBytes(encoding);return encode(stringBytes);}
public static String encodeString(final String string) {String encodedString = null;try {encodedString = encodeString(string, "UTF-8");} catch (UnsupportedEncodingException uue) {// Should never happen, java has to support "UTF-8".}return encodedString;}
public void encodeString(final String s) throws IOException {final int lenChars = s.length();final int lenCharacters = s.codePointCount(0, lenChars);encodeUnsignedInteger(lenCharacters);encodeStringOnly(s);}
private String encodeString(String str) {        m_buffer.setLength(0);        char ch;        int inx = 0;        while (inx < str.length()) {            ch = str.charAt(inx++);            switch (ch) {            case '"':  m_buffer.append("\\\""); break;            case '\\': m_buffer.append("\\\\"); break;            case '\b':  m_buffer.append("\\b"); break;            case '\f':  m_buffer.append("\\f"); break;            case '\n':  m_buffer.append("\\n"); break;            case '\r':  m_buffer.append("\\r"); break;            case '\t':  m_buffer.append("\\t"); break;            default:                // All other chars are allowed as-is, despite JSON spec.                m_buffer.append(ch);            }        }        return m_buffer.toString();    }
public static String encodeString(String s) {        try {            return CODEC.encode(s.getBytes("UTF-8"));        } catch (UnsupportedEncodingException e) {            // shouldn't happen            return null;        }    }
static public void encodeString(final FastSerializer fs, String value)    throws IOException {        final byte[] strdata = value.getBytes("UTF-8");        fs.writeInt(strdata.length);        fs.write(strdata);    }
public static String encodeString(String uri)  {    CharBuffer cb = CharBuffer.allocate();    for (int i = 0; i < uri.length(); i++) {      char ch = uri.charAt(i);      switch (ch) {      case '<':        cb.append("&lt;");        break;      case '>':        cb.append("&gt;");        break;      case '&':        cb.append("&amp;");        break;      default:        cb.append(ch);      }    }    return cb.close();  }

finding time elapsed using a timer
public void startTimeoutTimer(int iDelayMS)    {        if (m_timeouttimer == null)        {            m_timeouttimer = new Timer(iDelayMS, this);            m_timeouttimer.setRepeats(false);            m_timeouttimer.start();        }        else            m_timeouttimer.restart();    }
@Override  public Timer timer(String name) {    final com.codahale.metrics.Timer timer = registry.timer(name);    return new Timer() {      @Override      public Timer.Context time() {        final com.codahale.metrics.Timer.Context timerContext = timer.time();        return new Context() {          @Override          public void close() {            timerContext.close();          }        };      }      @Override      public void update(long duration, TimeUnit unit) {        timer.update(duration, unit);      }    };  }
public Timer timer(String name, final MetricSupplier<Timer> supplier) {        return getOrAdd(name, new MetricBuilder<Timer>() {            @Override            public Timer newMetric() {                return supplier.newMetric();            }            @Override            public boolean isInstance(Metric metric) {                return Timer.class.isInstance(metric);            }        });    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.COMPUTATION)    public static Completable timer(long delay, TimeUnit unit) {        return timer(delay, unit, Schedulers.computation());    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.ERROR)    @SchedulerSupport(SchedulerSupport.COMPUTATION)    public static Flowable<Long> timer(long delay, TimeUnit unit) {        return timer(delay, unit, Schedulers.computation());    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.COMPUTATION)    public static Maybe<Long> timer(long delay, TimeUnit unit) {        return timer(delay, unit, Schedulers.computation());    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.CUSTOM)    public static Maybe<Long> timer(long delay, TimeUnit unit, Scheduler scheduler) {        ObjectHelper.requireNonNull(unit, "unit is null");        ObjectHelper.requireNonNull(scheduler, "scheduler is null");        return RxJavaPlugins.onAssembly(new MaybeTimer(Math.max(0L, delay), unit, scheduler));    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.CUSTOM)    public static Single<Long> timer(final long delay, final TimeUnit unit, final Scheduler scheduler) {        ObjectHelper.requireNonNull(unit, "unit is null");        ObjectHelper.requireNonNull(scheduler, "scheduler is null");        return RxJavaPlugins.onAssembly(new SingleTimer(delay, unit, scheduler));    }
public static Timer timer(MetricLevel level, String name) {    return getMetricRegistry(level).timer(METRIC_PREFIX + name);  }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.ERROR)    @SchedulerSupport(SchedulerSupport.CUSTOM)    public static Flowable<Long> timer(long delay, TimeUnit unit, Scheduler scheduler) {        ObjectHelper.requireNonNull(unit, "unit is null");        ObjectHelper.requireNonNull(scheduler, "scheduler is null");        return RxJavaPlugins.onAssembly(new FlowableTimer(Math.max(0L, delay), unit, scheduler));    }

parse binary file to custom class
@Deprecated    public static ResourceHandler.Builder fileOrClasspath(String fileRootIfExists, String classpathRoot) {        Path path = Paths.get(fileRootIfExists);        if (Files.isDirectory(path)) {            return fileHandler(path);        } else {            return classpathHandler(classpathRoot);        }    }
public static ResourceHandlerBuilder fileOrClasspath(String fileRootIfExists, String classpathRoot) {        Path path = Paths.get(fileRootIfExists);        if (Files.isDirectory(path)) {            return fileHandler(path);        } else {            return classpathHandler(classpathRoot);        }    }
static String getFileClassName(FileDescriptor file, ProtoFlavor flavor) {    return getFileClassName(file.toProto(), flavor);  }
static String getFileClassName(FileDescriptorProto file, ProtoFlavor flavor) {    switch (flavor) {      case PROTO2:        return getFileImmutableClassName(file);      default:        throw new AssertionError();    }  }
public static void addFileToClassPath(Path file, Configuration conf)    throws IOException {    String classpath = conf.get("mapred.job.classpath.files");    conf.set("mapred.job.classpath.files", classpath == null ? file.toString()             : classpath + System.getProperty("path.separator") + file.toString());    URI uri = file.makeQualified(file.getFileSystem(conf)).toUri();    addCacheFile(uri, conf);  }
private static InputStream findFileInClasspath(String fileName) {InputStream is = null;try {ClassLoader classLoader = Thread.currentThread().getContextClassLoader();is = classLoader.getResourceAsStream(fileName);return is;} catch (Exception ex) {log.error(String.format("Error while reading file '%s' from classpath", fileName), ex);return null;}}
private static String getFileTypeIconClass(String resourceTypeName, String fileName, boolean small) {        if ((fileName != null) && fileName.contains(".")) {            int last = fileName.lastIndexOf(".");            if (fileName.length() > (last + 1)) {                String suffix = fileName.substring(fileName.lastIndexOf(".") + 1);                return getResourceSubTypeIconClass(resourceTypeName, suffix, small);            }        }        return "";    }
public static String readFileFromClassPath(String _fileName) {        StringBuilder sb = new StringBuilder();        for (String string : readFileFromClassPathAsList(_fileName)) {            sb.append(string).append("\n");        }        return sb.length() == 0 ? null : sb.toString();    }
boolean isProfileClassVisible() {try {Thread.currentThread().getContextClassLoader().loadClass(profileAfterAction.getClass().getName());return true;} catch (Throwable e) {return false;}}
public static String readFileFromClasspath(String file) {logger.trace("Reading file [{}]...", file);String content = null;try (InputStream asStream = SettingsReader.class.getClassLoader().getResourceAsStream(file)) {if (asStream == null) {logger.trace("Can not find [{}] in class loader.", file);return null;}content = IOUtils.toString(asStream, "UTF-8");} catch (IOException e) {logger.warn("Can not read [{}].", file);}return content;}

get current ip address
private static long getIPAddress()    {        if (tc.isEntryEnabled())            Tr.entry(tc, "getIPAddress");        int lower32Bits = 0;        try        {            final byte[] address = AccessController.doPrivileged(new PrivilegedExceptionAction<byte[]>() {                @Override                public byte[] run() throws UnknownHostException {                    return java.net.InetAddress.getLocalHost().getAddress();                }            });            lower32Bits = ((address[0] & 0xFF) << 24)                          | ((address[1] & 0xFF) << 16)                          | ((address[2] & 0xFF) << 8)                          | ((address[3] & 0xFF) << 0);        } catch (PrivilegedActionException paex) {            com.ibm.ws.ffdc.FFDCFilter.processException(paex.getCause(), "com.ibm.ws.util.UUID.getIPAddress", "794");            if (tc.isEventEnabled())                Tr.event(tc, "Exception caught getting host address.", paex.getCause());            // Try random number instead!            lower32Bits = new java.util.Random().nextInt();        } catch (Exception e) // Host address unavailable        {            com.ibm.ws.ffdc.FFDCFilter.processException(e, "com.ibm.ws.util.UUID.getIPAddress", "661");            if (tc.isEventEnabled())                Tr.event(tc, "Exception caught getting host address.", e);            // Try random number instead!            lower32Bits = new java.util.Random().nextInt();        }        final long ipAddress = lower32Bits & 0x00000000FFFFFFFFL;        if (tc.isEntryEnabled())            Tr.exit(tc, "getIPAddress", Long.valueOf(ipAddress));        return ipAddress;    }
public static String getIpAddress(HttpServletRequest request) {        String ip = request.getHeader("x-forwarded-for");        if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) {            ip = request.getHeader("Proxy-Client-IP");        }        if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) {            ip = request.getHeader("WL-Proxy-Client-IP");        }        if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) {            ip = request.getHeader("HTTP_CLIENT_IP");        }        if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) {            ip = request.getHeader("HTTP_X_FORWARDED_FOR");        }        if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) {            ip = request.getRemoteAddr();        }        return ip;    }
@Nullable    @Override    public IpAddress getIpAddress(@Nonnull String addressId) throws InternalException, CloudException {        throw new OperationNotSupportedException("AzureIpAddressSupport#getIpAddress not supported");    }
public String getIPAddress() {String value = System.getProperty("org.globus.ip");if (value != null) {    return value;}value = getProperty("ip", null);if (value != null) {    return value;}value = getHostName();if (value != null) {    try {return InetAddress.getByName(value).getHostAddress();    } catch (UnknownHostException e) {return null;    }}return value;    }
private String getScriptAddress(@Nullable Script script) {        String address = "";        try {            if (script != null) {                address = script.getToAddress(params, true).toString();            }        } catch (Exception e) {        }        return address;    }
public static InetAddress getIPHostAddress(String host) {        InetAddress result = null;        Matcher matcher = IPV4_QUADS.matcher(host);        if (matcher == null || !matcher.matches()) {            return result;        }        try {            // Doing an Inet.getByAddress() avoids a lookup.            result = InetAddress.getByAddress(host,                    new byte[] {                    (byte)(new Integer(matcher.group(1)).intValue()),                    (byte)(new Integer(matcher.group(2)).intValue()),                    (byte)(new Integer(matcher.group(3)).intValue()),                    (byte)(new Integer(matcher.group(4)).intValue())});        } catch (NumberFormatException e) {            logger.warning(e.getMessage());        } catch (UnknownHostException e) {            logger.warning(e.getMessage());        }        return result;    }
static String getLocalIPAddress() {        String ipAddress = "";        try {            List<NetworkInterface> netInterfaces = Collections.list(NetworkInterface.getNetworkInterfaces());            for (NetworkInterface netInterface : netInterfaces) {                List<InetAddress> addresses = Collections.list(netInterface.getInetAddresses());                for (InetAddress address : addresses) {                    if (!address.isLoopbackAddress()) {                        String ip = address.getHostAddress();                        boolean isIPv4 = ip.indexOf(':') < 0;                        if (isIPv4) {                            ipAddress = ip;                            break;                        }                    }                }            }        } catch (Throwable ignore) {        }        return ipAddress;    }
public static synchronized String getLocalIpAddress(int timeoutMs) {    if (sLocalIP != null) {      return sLocalIP;    }    try {      InetAddress address = InetAddress.getLocalHost();      LOG.debug("address: {} isLoopbackAddress: {}, with host {} {}", address,          address.isLoopbackAddress(), address.getHostAddress(), address.getHostName());      // Make sure that the address is actually reachable since in some network configurations      // it is possible for the InetAddress.getLocalHost() call to return a non-reachable      // address e.g. a broadcast address      if (!isValidAddress(address, timeoutMs)) {        Enumeration<NetworkInterface> networkInterfaces = NetworkInterface.getNetworkInterfaces();        // Make getNetworkInterfaces have the same order of network interfaces as listed on        // unix-like systems. This optimization can help avoid to get some special addresses, such        // as loopback address"127.0.0.1", virtual bridge address "192.168.122.1" as far as        // possible.        if (!WINDOWS) {          List<NetworkInterface> netIFs = Collections.list(networkInterfaces);          Collections.reverse(netIFs);          networkInterfaces = Collections.enumeration(netIFs);        }        while (networkInterfaces.hasMoreElements()) {          NetworkInterface ni = networkInterfaces.nextElement();          Enumeration<InetAddress> addresses = ni.getInetAddresses();          while (addresses.hasMoreElements()) {            address = addresses.nextElement();            // Address must not be link local or loopback. And it must be reachable            if (isValidAddress(address, timeoutMs)) {              sLocalIP = address.getHostAddress();              return sLocalIP;            }          }        }        LOG.warn("Your hostname, {} resolves to a loopback/non-reachable address: {}, "                  +  "but we couldn't find any external IP address!",                  InetAddress.getLocalHost().getHostName(), address.getHostAddress());      }      sLocalIP = address.getHostAddress();      return sLocalIP;    } catch (IOException e) {      throw new RuntimeException(e);    }  }
public static String getPublicIPAddress() throws Exception {        final String IPV4_REGEX = "\\A(25[0-5]|2[0-4]\\d|[0-1]?\\d?\\d)(\\.(25[0-5]|2[0-4]\\d|[0-1]?\\d?\\d)){3}\\z";        String ipAddr = null;        Enumeration e = NetworkInterface.getNetworkInterfaces();        while (e.hasMoreElements()) {            NetworkInterface n = (NetworkInterface) e.nextElement();            Enumeration ee = n.getInetAddresses();            while (ee.hasMoreElements()) {                InetAddress i = (InetAddress) ee.nextElement();                // Pick the first non loop back address                if ((!i.isLoopbackAddress() && i.isSiteLocalAddress()) ||                    i.getHostAddress().matches(IPV4_REGEX)) {                    ipAddr = i.getHostAddress();                    break;                }            }            if (ipAddr != null) {                break;            }        }        return ipAddr;    }
public static Inet4Address get6to4IPv4Address(Inet6Address ip) {    Preconditions.checkArgument(is6to4Address(ip),        "Address '%s' is not a 6to4 address.", toAddrString(ip));    return getInet4Address(Arrays.copyOfRange(ip.getAddress(), 2, 6));  }

convert int to bool
public static Point convertPoint(        Component sourceComponent,         Point2D point,        Component targetComponent)    {        Point p = new Point((int)point.getX(), (int)point.getY());        return SwingUtilities.convertPoint(            sourceComponent, p, targetComponent);    }
private int convertToInt(Object o, int defaultValue) {if (o.getClass() == Integer.class) {return (Integer) o;}else if (o.getClass() == Long.class) {long value = (Long) o;if (value <= Integer.MAX_VALUE && value >= Integer.MIN_VALUE) {return (int) value;} else {LOG.warn("Configuration value {} overflows/underflows the integer type.", value);return defaultValue;}}else {try {return Integer.parseInt(o.toString());}catch (NumberFormatException e) {LOG.warn("Configuration cannot evaluate value {} as an integer number", o);return defaultValue;}}}
public static Long convertToInt(RLPElement rpe) {Long result=0L;byte[] rawBytes=rpe.getRawData();if ((rawBytes!=null)) {// fill leading zerosif (rawBytes.length<EthereumUtil.INT_SIZE) {byte[] fullBytes=new byte[EthereumUtil.INT_SIZE];int dtDiff=EthereumUtil.INT_SIZE-rawBytes.length;for (int i=0;i<rawBytes.length;i++) {fullBytes[dtDiff+i]=rawBytes[i];result=(long) ByteBuffer.wrap(fullBytes).getInt()& 0x00000000ffffffffL;}} else {result=(long) ByteBuffer.wrap(rawBytes).getInt() & 0x00000000ffffffffL;}}return result;}
public Integer convertToInt(String value) {        Integer result = null;        if (value != null) {            result = Integer.valueOf(value);        }        return result;    }
public static int convertToInt(final Set<PosixFilePermission> aPermSet) {        int result = 0;        if (aPermSet.contains(PosixFilePermission.OWNER_READ)) {            result = result | 0400;        }        if (aPermSet.contains(PosixFilePermission.OWNER_WRITE)) {            result = result | 0200;        }        if (aPermSet.contains(PosixFilePermission.OWNER_EXECUTE)) {            result = result | 0100;        }        if (aPermSet.contains(PosixFilePermission.GROUP_READ)) {            result = result | 040;        }        if (aPermSet.contains(PosixFilePermission.GROUP_WRITE)) {            result = result | 020;        }        if (aPermSet.contains(PosixFilePermission.GROUP_EXECUTE)) {            result = result | 010;        }        if (aPermSet.contains(PosixFilePermission.OTHERS_READ)) {            result = result | 04;        }        if (aPermSet.contains(PosixFilePermission.OTHERS_WRITE)) {            result = result | 02;        }        if (aPermSet.contains(PosixFilePermission.OTHERS_EXECUTE)) {            result = result | 01;        }        return result;    }
public static WlBorderCoefFixed<WlCoef_I32> convertToInt( WlBorderCoefFixed<WlCoef_F32> orig ,  WlCoef_I32 inner ) {WlBorderCoefFixed<WlCoef_I32> ret =new WlBorderCoefFixed<>(orig.getLowerLength(), orig.getUpperLength());for( int i = 0; i < orig.getLowerLength(); i++ ) {WlCoef_F32 o = orig.getLower(i);WlCoef_I32 r = new WlCoef_I32();ret.setLower(i,r);convertCoef_F32_to_I32(inner.denominatorScaling, inner.denominatorWavelet, o, r);}for( int i = 0; i < orig.getUpperLength(); i++ ) {WlCoef_F32 o = orig.getUpper(i);WlCoef_I32 r = new WlCoef_I32();ret.setUpper(i,r);convertCoef_F32_to_I32(inner.denominatorScaling, inner.denominatorWavelet, o, r);}ret.setInnerCoef(inner);return ret;}
public void convertToPoint() {        EGeometryType geometryType = EGeometryType.forGeometry(getGeometry());        switch( geometryType ) {        case MULTIPOLYGON:        case POLYGON:        case LINESTRING:        case MULTILINESTRING:            // convert to line            Coordinate[] tmpCoords = geometry.getCoordinates();            geometry = GeometryUtilities.gf().createMultiPoint(tmpCoords);            // reset prepared geometry            preparedGeometry = null;            break;        default:            break;        }    }
public SimpleFeature convertDwgPoint( String typeName, String layerName, DwgPoint point, int id ) {        double[] p = point.getPoint();        Point2D pto = new Point2D.Double(p[0], p[1]);        CoordinateList coordList = new CoordinateList();        Coordinate coord = new Coordinate(pto.getX(), pto.getY(), 0.0);        coordList.add(coord);        SimpleFeatureTypeBuilder b = new SimpleFeatureTypeBuilder();        b.setName(typeName);        b.setCRS(crs);        b.add(THE_GEOM, MultiPoint.class);        b.add(LAYER, String.class);        SimpleFeatureType type = b.buildFeatureType();        SimpleFeatureBuilder builder = new SimpleFeatureBuilder(type);        Geometry points = gF.createMultiPoint(coordList.toCoordinateArray());        Object[] values = new Object[]{points, layerName};        builder.addAll(values);        return builder.buildFeature(typeName + "." + id);    }
public static int convertStrToInt( final String string, final int defaultValue )    {        if ( string == null )        {            return defaultValue;        }        try        {            return Integer.parseInt( string );        }        catch ( Exception e )        {            return defaultValue;        }    }
private EConvResult convertInternal(byte[] in, Ptr inPtr, int inStop, byte[] out, Ptr outPtr, int outStop, int flags) {        lastError.reset();        EConvResult res;        int len;        if (numTranscoders == 0) {            if (inBuf.bytes != null && inBuf.dataStart != inBuf.dataEnd) {                if (outStop - outPtr.p < inBuf.dataEnd - inBuf.dataStart) {                    len = outStop - outPtr.p;                    System.arraycopy(inBuf.bytes, inBuf.dataStart, out, outPtr.p, len);                    outPtr.p = outStop;                    inBuf.dataStart += len;                    return convertInternalResult(EConvResult.DestinationBufferFull, null);                }                len = inBuf.dataEnd - inBuf.dataStart;                System.arraycopy(inBuf.bytes, inBuf.dataStart, out, outPtr.p, len);                outPtr.p += len;                inBuf.dataStart = inBuf.dataEnd = inBuf.bufStart;                if ((flags & AFTER_OUTPUT) != 0) return convertInternalResult(EConvResult.AfterOutput, null);            }            if (outStop - outPtr.p < inStop - inPtr.p) {                len = outStop - outPtr.p;            } else {                len = inStop - inPtr.p;            }            if (len > 0 && (flags & AFTER_OUTPUT) != 0) {                out[outPtr.p++] = in[inPtr.p++];                return convertInternalResult(EConvResult.AfterOutput, null);            }            System.arraycopy(in, inPtr.p, out, outPtr.p, len);            outPtr.p += len;            inPtr.p += len;            if (inPtr.p != inStop) {                res = EConvResult.DestinationBufferFull;            } else if ((flags & PARTIAL_INPUT) != 0) {                res = EConvResult.SourceBufferEmpty;            } else {                res = EConvResult.Finished;            }            return convertInternalResult(res, null);        }        boolean hasOutput = false;        EConvElement elem = elements[numTranscoders - 1];        if (elem.bytes != null) {            int dataStart = elem.dataStart;            int dataEnd = elem.dataEnd;            byte[] data = elem.bytes;            if (dataStart != dataEnd) {                if (outStop - outPtr.p < dataEnd - dataStart) {                    len = outStop - outPtr.p;                    System.arraycopy(data, dataStart, out, outPtr.p, len);                    outPtr.p = outStop;                    elem.dataStart += len;                    return convertInternalResult(EConvResult.DestinationBufferFull, null);                }                len = dataEnd - dataStart;                System.arraycopy(data, dataStart, out, outPtr.p, len);                outPtr.p += len;                elem.dataStart = elem.dataEnd = elem.bufStart;                hasOutput = true;            }        }        Ptr resultPosition = new Ptr(0);        if (inBuf != null && inBuf.dataStart != inBuf.dataEnd) {            Ptr inDataStartPtr = new Ptr(inBuf.dataStart);            res = transConv(inBuf.bytes, inDataStartPtr, inBuf.dataEnd, out, outPtr, outStop, (flags & ~AFTER_OUTPUT) | PARTIAL_INPUT, resultPosition);            inBuf.dataStart = inDataStartPtr.p;            if (!res.isSourceBufferEmpty()) return convertInternalResult(EConvResult.SourceBufferEmpty, resultPosition);        }        if (hasOutput && (flags & AFTER_OUTPUT) != 0 && inPtr.p != inStop) {            inStop = inPtr.p;            res = transConv(in, inPtr, inStop, out, outPtr, outStop, flags, resultPosition);            if (res.isSourceBufferEmpty()) res = EConvResult.AfterOutput;        } else if ((flags & AFTER_OUTPUT) != 0 || numTranscoders == 1) {            res = transConv(in, inPtr, inStop, out, outPtr, outStop, flags, resultPosition);        } else {            flags |= AFTER_OUTPUT;            do {                res = transConv(in, inPtr, inStop, out, outPtr, outStop, flags, resultPosition);            } while (res.isAfterOutput());        }        return convertInternalResult(res, resultPosition);    }

read text file line by line
Rule TextLine() {//return Sequence(Optional(NonCommentChar(), TexText()),//Eol()).label("TextLine");return Sequence(NonCommentChar(),FirstOf(WSP(), ALPHA(), DIGIT()),//not a ":"TexText(),Eol()).label(TextLine).suppressSubnodes();}
CharacterHit hitTextLine(CaretOffsetX x, int line) {        return text.hitLine(x.value, line);    }
Rule XcomTextline() {return Sequence(String("text"),OneOrMore(WSP()).suppressNode(),TexText()).label(XcomTextline);}
@Override    protected ConfigElement processTextLine(String configfile, int lineno, String line) throws ConfigParseException    {        ConfigElement configElement;        if ((line.trim().startsWith("exten") || line.trim().startsWith("include")) && currentCategory != null                && (currentCategory.getName().equals("general") || currentCategory.getName().equals("globals")))            throw new ConfigParseException(configfile, lineno,                    "cannot have 'exten' or 'include' in global or general sections");        /*         * Goal here is to break out anything unique that we might want to look         * at and parse separately. For now, only exten and include fit that         * criteria. Eventually, I could see parsing sections for things from         * macros, contexts to differentiate them from categories, switch for         * realtime, and more.         */        if (line.trim().startsWith("exten"))        {            configElement = parseExtension(configfile, lineno, line);            currentCategory.addElement(configElement);            return configElement;        }        else if (line.trim().startsWith("include"))        {            // use parseVariable since we have access to it            ConfigVariable configvar = parseVariable(configfile, lineno, line);            configElement = new ConfigInclude(configfile, lineno, configvar.getValue());            currentCategory.addElement(configElement);            return configElement;        }        // leave everything else the same        configElement = super.processTextLine(configfile, lineno, line);        return configElement;    }
protected String getTextLineNumber(int rowStartOffset) {    Element root = component.getDocument().getDefaultRootElement();    int index = root.getElementIndex(rowStartOffset);    Element line = root.getElement(index);    if (line.getStartOffset() == rowStartOffset)      return String.valueOf(index + 1);    else      return "";  }
Rule NonQuoteOneTextLine() {//TODO TexText?return FirstOf(SP(),'!',CharRange('#', ':'),CharRange('<', '~'),LatinExtendedAndOtherAlphabet()).label(NonQuoteOneTextLine).suppressSubnodes();}
public Integer getEstimatedTextLines() {        if (!dataObj.has(CUSTOM_FIELD_AVG_TEXT_LENGTH)) {            return null;        }        Integer numLines = null;        try {            JSONObject obj = dataObj.getJSONObject(CUSTOM_FIELD_AVG_TEXT_LENGTH);            numLines = obj.getInt(CUSTOM_FIELD_NUM_LINES);        } catch (JSONException e) {        }        return numLines;    }
@Before("call(* com.arpnetworking.steno.LogBuilder.log())")    public void addToContextLineAndMethod(final JoinPoint joinPoint) {        final SourceLocation sourceLocation = joinPoint.getSourceLocation();        final LogBuilder targetLogBuilder = (LogBuilder) joinPoint.getTarget();        targetLogBuilder.addContext("line", String.valueOf(sourceLocation.getLine()));        targetLogBuilder.addContext("file", sourceLocation.getFileName());        targetLogBuilder.addContext("class", sourceLocation.getWithinType());    }
public Note getNoteFirstExtendedLineLow() {if (m_lowNote == null) {//A 7th (label=6) for 5 lines,//A 5th (label=4) for 3 lines,//A 3rd (label=2) for 1 linebyte label = (byte) (getStaffLines() + 1);Interval interv = new Interval(label,label==5?Interval.PERFECT:Interval.MAJOR,Interval.DOWNWARD);m_lowNote = interv.calculateSecondNote(getMiddleNote());m_lowNote.setAccidental(new Accidental());//Accidental.NONE}return m_lowNote;}
public Note getNoteFirstExtendedLineHigh() {if (m_highNote == null) {//A 7th (label=6) for 5 lines,//A 5th (label=4) for 3 lines,//A 3rd (label=2) for 1 linebyte label = (byte) (getStaffLines() + 1);Interval interv = new Interval(label,label==5?Interval.PERFECT:Interval.MAJOR,Interval.UPWARD);m_highNote = interv.calculateSecondNote(getMiddleNote());m_highNote.setAccidental(new Accidental());//Accidental.NONE}return m_highNote;}

get executable path
public static File getExecutionPath() throws OSException {        try {            return new File(OSUtils.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath());        } catch (URISyntaxException ex) {            throw new OSException(ex);        }    }
public static TreePath getPath(CompilationUnitTree unit, Tree target) {        return getPath(new TreePath(unit), target);    }
public static DocTreePath getPath(TreePath treePath, DocCommentTree doc, DocTree target) {        return getPath(new DocTreePath(treePath, doc), target);    }
public static DocTreePath getPath(DocTreePath path, DocTree target) {        Objects.requireNonNull(path); //null check        Objects.requireNonNull(target); //null check        class Result extends Error {            static final long serialVersionUID = -5942088234594905625L;            DocTreePath path;            Result(DocTreePath path) {                this.path = path;            }        }        class PathFinder extends DocTreePathScanner<DocTreePath,DocTree> {            @Override            public DocTreePath scan(DocTree tree, DocTree target) {                if (tree == target) {                    throw new Result(new DocTreePath(getCurrentPath(), target));                }                return super.scan(tree, target);            }        }        if (path.getLeaf() == target) {            return path;        }        try {            new PathFinder().scan(path, target);        } catch (Result result) {            return result.path;        }        return null;    }
private String getPath(QPath path)   {      try      {         return lFactory.createJCRPath(path).getAsString(false);      }      catch (RepositoryException e)      {         throw new IllegalStateException(e.getMessage(), e);      }   }
public static String getPath(String relativePath, String backupDirCanonicalPath) throws MalformedURLException   {      String path = "file:" + backupDirCanonicalPath + "/" + relativePath;      URL urlPath = new URL(resolveFileURL(path));      return urlPath.getFile();   }
@SuppressWarnings("unchecked")    public <E, F> Path<F> getPath(Root<E> root, List<Attribute<?, ?>> attributes) {        Path<?> path = root;        for (Attribute<?, ?> attribute : attributes) {            boolean found = false;            if (path instanceof FetchParent) {                for (Fetch<E, ?> fetch : ((FetchParent<?, E>) path).getFetches()) {                    if (attribute.getName().equals(fetch.getAttribute().getName()) && (fetch instanceof Join<?, ?>)) {                        path = (Join<E, ?>) fetch;                        found = true;                        break;                    }                }            }            if (!found) {                if (attribute instanceof PluralAttribute) {                    path = ((From<?, ?>) path).join(attribute.getName(), JoinType.LEFT);                } else {                    path = path.get(attribute.getName());                }            }        }        return (Path<F>) path;    }
public List<String> getPath(long sequence) {        List<InternalDocumentRevision> objects = getPathForNode(sequence);        List<String> res = new ArrayList<String>();        for(InternalDocumentRevision object : objects) {            res.add(object.getRevision());        }        return res;    }
public String getPath()    {        final StringBuilder path = new StringBuilder();        if (getPrevious() != null) {            path.append(getPrevious().getPath());        }        return path.toString();    }
private Path getPath(PropertyWriter writer, JsonStreamContext sc) {        LinkedList<PathElement> elements = new LinkedList<>();        if (sc != null) {            elements.add(new PathElement(writer.getName(), sc.getCurrentValue()));            sc = sc.getParent();        }        while (sc != null) {            if (sc.getCurrentName() != null && sc.getCurrentValue() != null) {                elements.addFirst(new PathElement(sc.getCurrentName(), sc.getCurrentValue()));            }            sc = sc.getParent();        }        return new Path(elements);    }

httpclient post json
public static final ChannelInitializer<Channel> httpClient(      final SimpleChannelInboundHandler<HttpResponse> handler) {    return new ChannelInitializer<Channel>() {      @Override      protected void initChannel(Channel channel) throws Exception {        ChannelPipeline pipeline = channel.pipeline();        pipeline.addLast("httpCodec", new HttpClientCodec());        pipeline.addLast("aggregator", new HttpObjectAggregator(10 * 1024 * 1024));        pipeline.addLast("httpClientHandler", handler);      }    };  }
protected HttpClient getHttpClient() {        HttpClient client = new HttpClient();        if (Jenkins.getInstance() != null) {            ProxyConfiguration proxy = Jenkins.getInstance().proxy;            if (useProxy && (proxy != null)){                client.getHostConfiguration().setProxy(proxy.name, proxy.port);                String username = proxy.getUserName();                String password = proxy.getPassword();                if (!StringUtils.isEmpty(username.trim()) && !StringUtils.isEmpty(password.trim())) {                    logger.info("Using proxy authentication (user=" + username + ")");                    client.getState().setProxyCredentials(AuthScope.ANY,                            new UsernamePasswordCredentials(username.trim(), password.trim()));                }            }        }        return client;    }
public static CloseableHttpClient newHttpClient() {        final SocketConfig socketConfig = SocketConfig.custom()                .setSoKeepAlive(Boolean.TRUE).setTcpNoDelay(Boolean.TRUE)                .setSoTimeout(SOCKET_TIMEOUT_MS).build();        final PoolingHttpClientConnectionManager manager = new PoolingHttpClientConnectionManager();        manager.setDefaultMaxPerRoute(MAX_HOSTS);        manager.setMaxTotal(MAX_HOSTS);        manager.setDefaultSocketConfig(socketConfig);        final RequestConfig requestConfig = RequestConfig.custom()                .setConnectTimeout(CONNECTION_TIMEOUT_MS)                .setCookieSpec(CookieSpecs.IGNORE_COOKIES)                .setStaleConnectionCheckEnabled(Boolean.FALSE)                .setSocketTimeout(SOCKET_TIMEOUT_MS).build();        final CloseableHttpClient client = HttpClients                .custom()                .disableRedirectHandling()                .setConnectionManager(manager)                .setDefaultRequestConfig(requestConfig)                .setConnectionReuseStrategy(                        new DefaultConnectionReuseStrategy())                .setConnectionBackoffStrategy(new DefaultBackoffStrategy())                .setRetryHandler(                        new DefaultHttpRequestRetryHandler(MAX_RETRIES, false))                .setKeepAliveStrategy(new DefaultConnectionKeepAliveStrategy())                .build();        return client;    }
public CloseableHttpClient NewHttpClient() throws Exception {    SSLContext sslcontext = SSLContexts.custom().loadTrustMaterial(null, new TrustSelfSignedStrategy()).build();    SSLConnectionSocketFactory sslsf = new SSLConnectionSocketFactory(sslcontext);    this.httpclient = HttpClients.custom().setSSLSocketFactory(sslsf).build();    return this.httpclient;    }
public ApiClient setHttpClient(OkHttpClient newHttpClient) {        if (!httpClient.equals(newHttpClient)) {            newHttpClient.networkInterceptors().addAll(httpClient.networkInterceptors());            httpClient.networkInterceptors().clear();            newHttpClient.interceptors().addAll(httpClient.interceptors());            httpClient.interceptors().clear();            this.httpClient = newHttpClient;        }        return this;    }
public void setHttpClient(HttpClient httpClient) {        if (httpClient != defaultHttpClient                && this.httpClient == defaultHttpClient) {            defaultHttpClient.getConnectionManager().shutdown();        }        this.httpClient = httpClient;    }
public CloseableHttpClient getHttpClient() {        CloseableHttpClient result = httpClient;        if (result == null) {            synchronized (DocumentLoader.class) {                result = httpClient;                if (result == null) {                    result = httpClient = JsonUtils.getDefaultHttpClient();                }            }        }        return result;    }
@SuppressWarnings("deprecation")    private static synchronized HttpClient initHttpClient(final BOSHClientConfig config) {        // Create and initialize HTTP parameters        org.apache.http.params.HttpParams params = new org.apache.http.params.BasicHttpParams();        org.apache.http.conn.params.ConnManagerParams.setMaxTotalConnections(params, 100);        org.apache.http.params.HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);        org.apache.http.params.HttpProtocolParams.setUseExpectContinue(params, false);        if (config != null &&                config.getProxyHost() != null &&                config.getProxyPort() != 0) {            HttpHost proxy = new HttpHost(                    config.getProxyHost(),                    config.getProxyPort());            params.setParameter(org.apache.http.conn.params.ConnRoutePNames.DEFAULT_PROXY, proxy);        }        // Create and initialize scheme registry         org.apache.http.conn.scheme.SchemeRegistry schemeRegistry = new org.apache.http.conn.scheme.SchemeRegistry();        schemeRegistry.register(                new org.apache.http.conn.scheme.Scheme("http", org.apache.http.conn.scheme.PlainSocketFactory.getSocketFactory(), 80));            org.apache.http.conn.ssl.SSLSocketFactory sslFactory = org.apache.http.conn.ssl.SSLSocketFactory.getSocketFactory();            sslFactory.setHostnameVerifier(org.apache.http.conn.ssl.SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);            schemeRegistry.register(                    new org.apache.http.conn.scheme.Scheme("https", sslFactory, 443));        // Create an HttpClient with the ThreadSafeClientConnManager.        // This connection manager must be used if more than one thread will        // be using the HttpClient.        org.apache.http.conn.ClientConnectionManager cm = new org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager(params, schemeRegistry);        return new org.apache.http.impl.client.DefaultHttpClient(cm, params);    }
protected static org.apache.http.client.HttpClient buildHttpClient(boolean contentCompression, boolean sslVerification) {        RequestConfig rc = RequestConfig.custom()                .setCookieSpec(CookieSpecs.STANDARD)                .build();        HttpClientBuilder builder = HttpClients.custom()                .useSystemProperties();        if (!contentCompression) {            builder.disableContentCompression();        }        if (!sslVerification) {            try {                builder.setSSLSocketFactory(generateAllTrustingSSLConnectionSocketFactory());            } catch (Exception e) {                throw new RuntimeException("Unable to create all-trusting SSLConnectionSocketFactory", e);            }        }        return builder.setConnectionReuseStrategy(NoConnectionReuseStrategy.INSTANCE)                .setUserAgent(HttpClient.class.getName())                .setDefaultRequestConfig(rc)                .build();    }
private Client buildHttpClient(boolean debugging) {    final ClientConfig conf = new DefaultClientConfig();    // Add the JSON serialization support to Jersey    JacksonJsonProvider jsonProvider = new JacksonJsonProvider(mapper);    conf.getSingletons().add(jsonProvider);        // Force TLS v1.2    try {    System.setProperty("https.protocols", "TLSv1.2");    } catch (SecurityException se) {        System.err.println("failed to set https.protocols property");    }        // Setup the SSLContext object to use for HTTPS connections to the API    if (sslContext == null) {    try {    sslContext = SSLContext.getInstance("TLSv1.2");    sslContext.init(null, new TrustManager[] { new SecureTrustManager() }, new SecureRandom());    } catch (final Exception ex) {      System.err.println("failed to initialize SSL context");    }    conf.getProperties().put(HTTPSProperties.PROPERTY_HTTPS_PROPERTIES, new HTTPSProperties(new HostnameVerifier() {@Overridepublic boolean verify(String hostname, SSLSession session) {return true;}}, sslContext));    HttpsURLConnection.setDefaultSSLSocketFactory(sslContext.getSocketFactory());    }    Client client = new Client(new URLConnectionClientHandler(new HttpURLConnectionFactory() {Proxy p = null;@Overridepublic HttpURLConnection getHttpURLConnection(URL url) throws IOException {    // set up the proxy/no-proxy settingsif (p == null) {if (System.getProperties().containsKey("https.proxyHost")) {// set up the proxy host and port            final String host = System.getProperty("https.proxyHost");            final Integer port = Integer.getInteger("https.proxyPort");            if (host != null && port != null) {    p = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(host, port));            }// set up optional proxy authentication credentialsfinal String user = System.getProperty("https.proxyUser");    final String password = System.getProperty("https.proxyPassword");    if (user != null && password != null) {    Authenticator.setDefault(new Authenticator() {    @Override    protected PasswordAuthentication getPasswordAuthentication() {        if (getRequestorType() == RequestorType.PROXY && getRequestingHost().equalsIgnoreCase(host) && port == getRequestingPort()) {        return new PasswordAuthentication(user, password.toCharArray());        }        return null;    }});    }} else if (System.getProperties().containsKey("http.proxyHost")) {// set up the proxy host and port            final String host = System.getProperty("http.proxyHost");            final Integer port = Integer.getInteger("http.proxyPort");            if (host != null && port != null) {    p = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(host, port));            }// set up optional proxy authentication credentialsfinal String user = System.getProperty("http.proxyUser");    final String password = System.getProperty("http.proxyPassword");    if (user != null && password != null) {    Authenticator.setDefault(new Authenticator() {    @Override    protected PasswordAuthentication getPasswordAuthentication() {        if (getRequestorType() == RequestorType.PROXY && getRequestingHost().equalsIgnoreCase(host) && port == getRequestingPort()) {        return new PasswordAuthentication(user, password.toCharArray());        }        return null;    }});    }}// no-proxy fallback if the proxy settings are misconfigured in the system propertiesif (p == null) {p = Proxy.NO_PROXY;}}HttpsURLConnection connection = (HttpsURLConnection) url.openConnection(p);    connection.setSSLSocketFactory(sslContext.getSocketFactory());return connection;}}), conf);        if (debugging) {      client.addFilter(new LoggingFilter());    }    return client;  }

get inner html
@Overridepublic String getInnerHTML() throws WidgetException {WebElement element = findElement();WebDriver wd = getGUIDriver().getWrappedDriver();String innerHtml = (String) ((JavascriptExecutor) wd).executeScript("return arguments[0].innerHTML;", element);return innerHtml;}
private static String getIconInnerHTML(        CmsResourceUtil resUtil,        CmsResourceState state,        boolean showLocks,        boolean showDetailIcon) {        Resource iconResource = resUtil.getBigIconResource();        return getIconInnerHTML(resUtil, iconResource, state, showLocks, showDetailIcon);    }
private static String getIconInnerHTML(        CmsResourceUtil resUtil,        Resource iconResource,        CmsResourceState state,        boolean showLocks,        boolean showDetailIcon) {        String content;        if (iconResource instanceof FontIcon) {            content = ((FontIcon)iconResource).getHtml();        } else if (iconResource instanceof ExternalResource) {            content = "<img src=\"" + ((ExternalResource)iconResource).getURL() + "\" />";        } else {            content = "";        }        boolean isNavLevel = false;        if (resUtil != null) {            if (showDetailIcon && !isNavLevel) {                if (resUtil.getResource().isFolder()) {                    String detailType = getDefaultFileOrDetailType(resUtil.getCms(), resUtil.getResource());                    if (detailType != null) {                        String smallIconUri = getSmallTypeIconHTML(detailType, false);                        if (smallIconUri != null) {                            content += smallIconUri;                        }                    }                } else if (CmsResourceTypeXmlContainerPage.isContainerPage(resUtil.getResource())) {                    String detailType = getDefaultFileOrDetailType(resUtil.getCms(), resUtil.getResource());                    if (detailType != null) {                        String smallIconUri = getSmallTypeIconHTML(detailType, true);                        if (smallIconUri != null) {                            content += smallIconUri;                        }                    }                }            }            if (showLocks) {                String lockIcon;                String message = null;                if (resUtil.getLock().getSystemLock().isPublish()) {                    lockIcon = OpenCmsTheme.LOCK_PUBLISH + " " + ICON_CLASS_LOCK_PUBLISH;                    message = CmsVaadinUtils.getMessageText(                        org.opencms.workplace.explorer.Messages.GUI_PUBLISH_TOOLTIP_0);                } else {                    switch (resUtil.getLockState()) {                        case 1:                            lockIcon = OpenCmsTheme.LOCK_OTHER + " " + ICON_CLASS_LOCK_OTHER;                            break;                        case 2:                            lockIcon = OpenCmsTheme.LOCK_SHARED + " " + ICON_CLASS_LOCK_SHARED;                            break;                        case 3:                            lockIcon = OpenCmsTheme.LOCK_USER + " " + ICON_CLASS_LOCK_OWN;                            break;                        default:                            lockIcon = null;                    }                    if (lockIcon != null) {                        message = CmsVaadinUtils.getMessageText(                            Messages.GUI_EXPLORER_LIST_ACTION_LOCK_NAME_2,                            resUtil.getLockedByName(),                            resUtil.getLockedInProjectName());                    }                }                if (lockIcon != null) {                    content += getOverlaySpan(lockIcon, message);                }            }        }        if (state != null) {            String title = resUtil != null            ? CmsVaadinUtils.getMessageText(org.opencms.workplace.commons.Messages.GUI_LABEL_USER_LAST_MODIFIED_0)                + " "                + resUtil.getUserLastModified()            : null;            if (state.isChanged() || state.isDeleted()) {                content += getOverlaySpan(OpenCmsTheme.STATE_CHANGED + " " + ICON_CLASS_CHANGED, title);            } else if (state.isNew()) {                content += getOverlaySpan(OpenCmsTheme.STATE_NEW + " " + ICON_CLASS_CHANGED, title);            }        }        if ((resUtil != null) && (resUtil.getLinkType() == 1)) {            content += getOverlaySpan(OpenCmsTheme.SIBLING + " " + ICON_CLASS_SIBLING, null);        }        return content;    }
public static String getHTML(IMolecularFormula formula, String[] orderElements, boolean showCharge, boolean showIsotopes) {        StringBuilder sb = new StringBuilder();        for (String orderElement : orderElements) {            IElement element = formula.getBuilder().newInstance(IElement.class, orderElement);            if (containsElement(formula, element)) {                if (!showIsotopes) {                    sb.append(element.getSymbol());                    int n = getElementCount(formula, element);                    if (n > 1) {                        sb.append("<sub>").append(n).append("</sub>");                    }                } else {                    for (IIsotope isotope : getIsotopes(formula, element)) {                        Integer massNumber = isotope.getMassNumber();                        if (massNumber != null)                            sb.append("<sup>").append(massNumber).append("</sup>");                        sb.append(isotope.getSymbol());                        int n = formula.getIsotopeCount(isotope);                        if (n > 1) {                            sb.append("<sub>").append(n).append("</sub>");                        }                    }                }            }        }        if (showCharge) {            Integer charge = formula.getCharge();            if (charge == CDKConstants.UNSET || charge == 0) {                return sb.toString();            } else {                sb.append("<sup>");                if (charge > 1 || charge < -1)                    sb.append(Math.abs(charge));                if (charge > 0)                    sb.append('+');                else                    sb.append(MINUS); // note, not a hyphen!                sb.append("</sup>");            }        }        return sb.toString();    }
public static String getHTML(IMolecularFormula formula, boolean chargeB, boolean isotopeB) {        String[] orderElements;        if (containsElement(formula, formula.getBuilder().newInstance(IElement.class, "C")))            orderElements = generateOrderEle_Hill_WithCarbons();        else            orderElements = generateOrderEle_Hill_NoCarbons();        return getHTML(formula, orderElements, chargeB, isotopeB);    }
public String getHtml(String title) {        return "<span class=\"v-icon "            + m_styleName            + " "            + m_additionalButtonStyle            + "\" title=\""            + title            + "\">&#x"            + Integer.toHexString(getCodepoint())            + ";</span>";    }
public Html getHtml() {        if (html == null) {            html = new Html(rawText, request.getUrl());        }        return html;    }
public String getHtml(Formatter formatter, String value) {        String result = null;        if (value != null) {            if ("".equals(value)) {                result = "";            } else {                String formattedResponse = formatter.format(value);                result = "<pre>" + StringEscapeUtils.escapeHtml4(formattedResponse) + "</pre>";            }        }        return result;    }
@Override@Exportpublic String getHtml(Geometry geometry, Coordinate dragPoint, Coordinate startA, Coordinate startB) {return htmlCallback == null ? "" : htmlCallback.execute(geometry, dragPoint, startA, startB);}
public String getHtml() {        return NODE_NAME + " : " + this.node.getId() + " : " + this.node.getQueryElement() == null ? "" : this.node.getQueryElement().getQueryName();    }

convert string to number
protected static Number stringToNumber(final String val) throws NumberFormatException {        char initial = val.charAt(0);        if ((initial >= '0' && initial <= '9') || initial == '-') {            // decimal representation            if (isDecimalNotation(val)) {                // quick dirty way to see if we need a BigDecimal instead of a Double                // this only handles some cases of overflow or underflow                if (val.length()>14) {                    return new BigDecimal(val);                }                final Double d = Double.valueOf(val);                if (d.isInfinite() || d.isNaN()) {                    // if we can't parse it as a double, go up to BigDecimal                    // this is probably due to underflow like 4.32e-678                    // or overflow like 4.65e5324. The size of the string is small                    // but can't be held in a Double.                    return new BigDecimal(val);                }                return d;            }            // integer representation.            // This will narrow any values to the smallest reasonable Object representation            // (Integer, Long, or BigInteger)                        // string version            // The compare string length method reduces GC,            // but leads to smaller integers being placed in larger wrappers even though not            // needed. i.e. 1,000,000,000 -> Long even though it's an Integer            // 1,000,000,000,000,000,000 -> BigInteger even though it's a Long            //if(val.length()<=9){            //    return Integer.valueOf(val);            //}            //if(val.length()<=18){            //    return Long.valueOf(val);            //}            //return new BigInteger(val);                        // BigInteger version: We use a similar bitLenth compare as            // BigInteger#intValueExact uses. Increases GC, but objects hold            // only what they need. i.e. Less runtime overhead if the value is            // long lived. Which is the better tradeoff? This is closer to what's            // in stringToValue.            BigInteger bi = new BigInteger(val);            if(bi.bitLength()<=31){                return Integer.valueOf(bi.intValue());            }            if(bi.bitLength()<=63){                return Long.valueOf(bi.longValue());            }            return bi;        }        throw new NumberFormatException("val ["+val+"] is not a valid number.");    }
@SuppressWarnings("nls")    private double[] nsewStringsToNumbers( String north, String south, String east, String west ) {        double no = -1.0;        double so = -1.0;        double ea = -1.0;        double we = -1.0;        if (north.indexOf("N") != -1 || north.indexOf("n") != -1) {            north = north.substring(0, north.length() - 1);            no = degreeToNumber(north);        } else if (north.indexOf("S") != -1 || north.indexOf("s") != -1) {            north = north.substring(0, north.length() - 1);            no = -degreeToNumber(north);        } else {            no = Double.parseDouble(north);        }        if (south.indexOf("N") != -1 || south.indexOf("n") != -1) {            south = south.substring(0, south.length() - 1);            so = degreeToNumber(south);        } else if (south.indexOf("S") != -1 || south.indexOf("s") != -1) {            south = south.substring(0, south.length() - 1);            so = -degreeToNumber(south);        } else {            so = Double.parseDouble(south);        }        if (west.indexOf("E") != -1 || west.indexOf("e") != -1) {            west = west.substring(0, west.length() - 1);            we = degreeToNumber(west);        } else if (west.indexOf("W") != -1 || west.indexOf("w") != -1) {            west = west.substring(0, west.length() - 1);            we = -degreeToNumber(west);        } else {            we = Double.parseDouble(west);        }        if (east.indexOf("E") != -1 || east.indexOf("e") != -1) {            east = east.substring(0, east.length() - 1);            ea = degreeToNumber(east);        } else if (east.indexOf("W") != -1 || east.indexOf("w") != -1) {            east = east.substring(0, east.length() - 1);            ea = -degreeToNumber(east);        } else {            ea = Double.parseDouble(east);        }        return new double[]{no, so, ea, we};    }
void expectStringOrNumber(Node n, JSType type, String msg) {    if (!type.matchesNumberContext()        && !type.matchesStringContext()        && !type.matchesStringContext()) {      mismatch(n, msg, type, NUMBER_STRING);    } else {      expectStringOrNumberOrSymbolStrict(n, type, msg);    }  }
public boolean number(TextProvider textProvider)            {        clearLastToken(textProvider);        clearLeadingSpaces(textProvider);        mark(textProvider);        if (m_debug)        debug("testing",textProvider);        StringBuilder sb = new StringBuilder();        boolean hasDecimal = false;        while (true)        {            char c = getNextChar(textProvider);            if (c == 'L')            {                remark(textProvider);                sb.append(c);                break;            }            if (c == 'D')            {                remark(textProvider);                sb.append(c);                break;            }            if (c == 'F')            {                remark(textProvider);                sb.append(c);                break;            }            if (!Character.isDigit(c) && c != '.')            {                break;            }            if (c == '.')            {                if (hasDecimal)                {                    break;                }                else                {                    hasDecimal = true;                }            }            remark(textProvider);            sb.append(c);        }        reset(textProvider); // removes last char        String s = sb.toString().trim();        if (s.length() == 0) return false;        textProvider.setLastToken(s);        debug(textProvider);        return true;    }
public ScriptBuilder number(int index, long num) {        if (num == -1) {            return op(index, OP_1NEGATE);        } else if (num >= 0 && num <= 16) {            return smallNum(index, (int) num);        } else {            return bigNum(index, num);        }    }
public int number(CharSequence seq) {        StateInfo info = getStateInfo(seq);        return info.isInFinalState() ? info.getHash() : -1;    }
public static Expression number(long value) {    Preconditions.checkArgument(        IntegerNode.isInRange(value), "Number is outside JS safe integer range: %s", value);    return Leaf.create(Long.toString(value), /* isCheap= */ true);  }
protected Expression number(int opPos) throws TransformerException  {    return compileUnary(new org.apache.xpath.operations.Number(), opPos);  }
public long number(ImapRequestLineReader request) throws ProtocolException {        String digits = consumeWord(request, new DigitCharValidator());        return Long.parseLong(digits);    }
Rule Number() {        return FirstOf(                Sequence(Optional('-'), Digit0(), '.', Digit1()),                Sequence(Optional('-'), Digit1())        );    }

format date
public static String formatDate(java.util.Date pDate, String format) {        if (pDate == null) {            pDate = new java.util.Date();        }        SimpleDateFormat sdf = new SimpleDateFormat(format);        return sdf.format(pDate);    }
public static String formatDate(Date date) {        SimpleDateFormat formatter = new SimpleDateFormat(TIMESTAMP_FORMAT);        return formatter.format(date);    }
public static String formatDate(Date date) {        return org.apache.http.client.utils.DateUtils.formatDate(date);    }
public static String formatDate(Date date, String pattern) {        if (date == null) throw new IllegalArgumentException("date is null");        if (pattern == null) throw new IllegalArgumentException("pattern is null");        SimpleDateFormat formatter = DateFormatHolder.formatFor(pattern);        return formatter.format(date);    }
public static String formatDate(Date date, String pattern) {        SimpleDateFormat formatter = new SimpleDateFormat(pattern, Locale.US);        formatter.setTimeZone(GMT);        return formatter.format(date);    }
private static String formatDate(Date date) {        SimpleDateFormat formatter = new SimpleDateFormat(                "yyyy-MM-dd'T'HH:mm:ss'Z'");        formatter.setTimeZone(TimeZone.getTimeZone("GMT"));        return formatter.format(date);    }
public static String formatDate(Calendar date, int precision) {        assert date != null;        // Remember that the bloody month field is zero-relative!        switch (precision) {        case Calendar.MILLISECOND:            // YYYY-MM-DD hh:mm:ss.SSS            return String.format("%04d-%02d-%02d %02d:%02d:%02d.%03d",                                 date.get(Calendar.YEAR), date.get(Calendar.MONTH)+1, date.get(Calendar.DAY_OF_MONTH),                                 date.get(Calendar.HOUR_OF_DAY), date.get(Calendar.MINUTE), date.get(Calendar.SECOND),                                 date.get(Calendar.MILLISECOND));        case Calendar.SECOND:            // YYYY-MM-DD hh:mm:ss            return String.format("%04d-%02d-%02d %02d:%02d:%02d",                                 date.get(Calendar.YEAR), date.get(Calendar.MONTH)+1, date.get(Calendar.DAY_OF_MONTH),                                 date.get(Calendar.HOUR_OF_DAY), date.get(Calendar.MINUTE), date.get(Calendar.SECOND));        case Calendar.MINUTE:            // YYYY-MM-DD hh:mm            return String.format("%04d-%02d-%02d %02d:%02d",                                 date.get(Calendar.YEAR), date.get(Calendar.MONTH)+1, date.get(Calendar.DAY_OF_MONTH),                                 date.get(Calendar.HOUR_OF_DAY), date.get(Calendar.MINUTE));        case Calendar.HOUR:            // YYYY-MM-DD hh            return String.format("%04d-%02d-%02d %02d",                                 date.get(Calendar.YEAR), date.get(Calendar.MONTH)+1, date.get(Calendar.DAY_OF_MONTH),                                 date.get(Calendar.HOUR_OF_DAY));        case Calendar.DATE:            // YYYY-MM-DD            return String.format("%04d-%02d-%02d",                                 date.get(Calendar.YEAR), date.get(Calendar.MONTH)+1, date.get(Calendar.DAY_OF_MONTH));        case Calendar.MONTH:            // YYYY-MM            return String.format("%04d-%02d", date.get(Calendar.YEAR), date.get(Calendar.MONTH)+1);        case Calendar.YEAR:            // YYYY            return String.format("%04d", date.get(Calendar.YEAR));        }        throw new IllegalArgumentException("Unknown precision: " + precision);    }
public static String formatDate(long time) {        // Map date/time to a GregorianCalendar object (local time zone).        GregorianCalendar date = new GregorianCalendar();        date.setTimeInMillis(time);        return formatDate(date, Calendar.SECOND);    }
private String formatDate(final WPartialDateField dateField) {Integer day = dateField.getDay();Integer month = dateField.getMonth();Integer year = dateField.getYear();if (day != null || month != null || year != null) {StringBuffer buf = new StringBuffer(10);append(buf, year, 4);buf.append('-');append(buf, month, 2);buf.append('-');append(buf, day, 2);return buf.toString();}return null;}
public static String formatDate(Long timestamp, String format, Locale loc) {if (StringUtils.isBlank(format)) {format = DateFormatUtils.ISO_8601_EXTENDED_DATE_FORMAT.getPattern();}if (timestamp == null) {timestamp = timestamp();}if (loc == null) {loc = Locale.US;}return DateFormatUtils.format(timestamp, format, loc);}

readonly array
public static JsonArray array(String... strings) {    if (strings == null) {      throw new NullPointerException("values is null");    }    JsonArray array = new JsonArray();    for (String value : strings) {      array.add(value);    }    return array;  }
public INDArray array() {        List<INDArray> retList = new ArrayList<>(list.size());        for(X x : list) {            INDArray arr = x.array();            retList.add(arr.reshape(1, arr.length()));        }        return Nd4j.concat(0,retList.toArray(new INDArray[retList.size()]));    }
public static <T> QueryParameterValue array(T[] array, Class<T> clazz) {    return array(array, classToType(clazz));  }
public static <T> QueryParameterValue array(T[] array, StandardSQLTypeName type) {    List<QueryParameterValue> listValues = new ArrayList<>();    for (T obj : array) {      listValues.add(QueryParameterValue.of(obj, type));    }    return QueryParameterValue.newBuilder()        .setArrayValues(listValues)        .setType(StandardSQLTypeName.ARRAY)        .setArrayType(type)        .build();  }
@Override  public Object[] array() {    DataType dt = data.dataType();    Object[] list = new Object[length];    try {      for (int i = 0; i < length; i++) {        if (!data.isNullAt(offset + i)) {          list[i] = get(i, dt);        }      }      return list;    } catch(Exception e) {      throw new RuntimeException("Could not get the array", e);    }  }
public static Array array(Object array) {        if (array instanceof Object[]) {            return array((Object[]) array);        }        switch (tId(array.getClass())) {            case I_BOOLEAN:     return array((boolean[]) array);            case I_BYTE:        return array((byte[]) array);            case I_CHARACTER:   return array((char[]) array);            case I_DOUBLE:      return array((double[]) array);            case I_FLOAT:       return array((float[]) array);            case I_INTEGER:     return array((int[]) array);            case I_LONG:        return array((long[]) array);            case I_SHORT:       return array((short[]) array);        }        throw new IllegalArgumentException("No array: " + array);    }
public static Type array(Type elementType) {    Preconditions.checkNotNull(elementType);    switch (elementType.getCode()) {      case BOOL:        return TYPE_ARRAY_BOOL;      case INT64:        return TYPE_ARRAY_INT64;      case FLOAT64:        return TYPE_ARRAY_FLOAT64;      case STRING:        return TYPE_ARRAY_STRING;      case BYTES:        return TYPE_ARRAY_BYTES;      case TIMESTAMP:        return TYPE_ARRAY_TIMESTAMP;      case DATE:        return TYPE_ARRAY_DATE;      default:        return new Type(Code.ARRAY, elementType, null);    }  }
Expr array() {if (peek().sym != Sym.LBRACK) {return atom();}move();if (peek().sym == Sym.RBRACK) {move();return new Array(ExprList.NULL_EXPR_ARRAY, location);}ExprList exprList = exprList();if (exprList.length() == 1 && peek().sym == Sym.RANGE) {move();Expr end = expr();match(Sym.RBRACK);return new RangeArray(exprList.getExprArray()[0], end, location);}match(Sym.RBRACK);return new Array(exprList.getExprArray(), location);}
public JSONWriter array() throws JSONException {    if (this.mode == 'i' || this.mode == 'o' || this.mode == 'a') {      this.push(null);      this.append("[");      this.comma = false;      return this;    }    throw new JSONException("Misplaced array.");  }
@Override    public CompoundSelection<Object[]> array(Selection<?>... arg0)    {        return new DefaultCompoundSelection<Object[]>(Arrays.asList(arg0), Object.class);    }

filter array
public static Filter filterArrayToChain(Filter[] filterArray) {        for (int i = 0; i < (filterArray.length - 1); i++) {            AbstractFilter thisFilter = (AbstractFilter) filterArray[i];            thisFilter.setAnd(filterArray[i + 1]);        }        AbstractFilter lastFilter = (AbstractFilter) filterArray[filterArray.length - 1];        lastFilter.setAnd(null);        return filterArray[0];    }
@Override    public Filter[] filterChainToArray() {        int length = chainLength();        Filter[] array = new Filter[length];        Filter thisFilter = this;        for (int i = 0; i < length; i++) {            array[i] = thisFilter;            thisFilter = thisFilter.getAnd();        }        return array;    }
private boolean filter(Event event) {        for (EventFilter filter : eventFilters) {            if (filter.filter(event)) {                return true;            }        }        return false;    }
private boolean filter(Event event) {        if (null == filters) return false;        for (EventFilter filter : filters) {            if (filter.filter(event)) {                return true;            }        }        return false;    }
private boolean filter(Class<?> clazz, List<ClassFilter> filters) {        boolean flag = true;        for (ClassFilter filter : filters) {            if (filter.filter(clazz)) {                flag = false;                break;            }        }        return flag;    }
@NotNull    public IntStream filter(@NotNull final IntPredicate predicate) {        return new IntStream(params, new IntFilter(iterator, predicate));    }
@NotNull    public LongStream filter(@NotNull final LongPredicate predicate) {        return new LongStream(params, new LongFilter(iterator, predicate));    }
@NotNull    public Stream<T> filter(@NotNull final Predicate<? super T> predicate) {        return new Stream<T>(params, new ObjFilter<T>(iterator, predicate));    }
@NotNull    public DoubleStream filter(@NotNull final DoublePredicate predicate) {        return new DoubleStream(params, new DoubleFilter(iterator, predicate));    }
public Iterable<MetricsInfo> filter(Iterable<MetricsInfo> metricsInfos) {    List<MetricsInfo> metricsFiltered = new ArrayList<MetricsInfo>();    for (MetricsInfo metricsInfo : metricsInfos) {      if (contains(metricsInfo.getName())) {        metricsFiltered.add(metricsInfo);      }    }    return metricsFiltered;  }

map to json
protected static JsonObject mapToJson(Map<String, String> map) {        JsonObject root = new JsonObject();        for (Entry<String, String> entry : map.entrySet()) {            String[] split = StringUtils.split(entry.getKey(), '.');            ArrayDeque<String> dq = new ArrayDeque<>(Arrays.asList(split));            createOrDescend(root, dq, entry.getValue());        }        return root;    }
public JSONObject nodesMapToJSON(StaticRouting.NodesMap nm) {        JSONObject o = new JSONObject();        o.put("src", nm.getSrc().id());        o.put("dst", nm.getDst().id());        return o;    }
public static String mapToJsonArray(Map<?, ?> map) {        JSONArray array = new JSONArray();        if (Checker.isNotEmpty(map)) {            map.forEach((key, value) -> {                JSONObject object = new JSONObject();                object.put("key", key);                object.put("value", value);                array.add(object);            });        }        return formatJson(array.toString());    }
public static String mapToJSONString(Map<?, ?> map) {if (map == null || map.size() == 0) {return "{}";}StringBuilder sb = new StringBuilder("{");for (Object o : map.entrySet()) {Entry<?, ?> e = (Entry<?, ?>) o;buildAppendString(sb, e.getKey()).append('=');buildAppendString(sb, e.getValue()).append(',').append(' ');}return sb.delete(sb.length() - 2, sb.length()).append('}').toString();}
public static JSONObject mapToJsonObject(Map<String, Object> map)    {        JSONObject jsonObj = new JSONObject();                try {            for (String key : map.keySet())            {                Object value = map.get(key);                if (value instanceof Map)                    jsonObj.put(key, AjaxProxyTask.mapToJsonObject((Map)value));                else                    jsonObj.put(key, value);            }        } catch (JSONException e) {            e.printStackTrace();        }                return jsonObj;    }
public static String mapAsJson(Map<String, String> map) {        JSONObject obj = new JSONObject();        for (Map.Entry<String, String> entry : map.entrySet()) {            try {                obj.put(entry.getKey(), entry.getValue());            } catch (JSONException e) {                LOG.error(e.getLocalizedMessage(), e);            }        }        return obj.toString();    }
public JSONObject mapColorDataToJSON() {final JSONObject jsonObject = new JSONObject();try {jsonObject.put("name", name);jsonObject.put("color", color);} catch (JSONException e) {final String message = LogMessageUtil.failMsg(e);LoggerFactory.getLogger(AccumulatedSingleGraphAO.class).warn(message, e);}return jsonObject;}
@SuppressWarnings("unchecked")    private JSONObject convertMapToJSONObject(Map map) throws IOException {        Map newMap;        // Only perform wrapping if it's enabled and the input map requires it.        if (isWrapNestedMapsAndCollections && requiresWrap(map)) {            newMap = new HashMap<String, Object>();            // Iterate through the elements in the input map.            for (Object key : map.keySet()) {                Object value = map.get(key);                Object newValue = value;                // Perform recursive conversions on maps and collections.                if (value instanceof Map) {                    newValue = convertMapToJSONObject((Map) value);                } else if (value instanceof Collection) {                    newValue = convertCollectionToJSONArray((Collection) value);                } else if (value instanceof Object[]) {                    newValue = convertCollectionToJSONArray(Arrays.asList((Object[]) value));                }                // Add the value to the new map.                newMap.put(key, newValue);            }        } else {            // Use the input map as-is.            newMap = map;        }        // Pass the new map to the JSONObject constructor.        return getJsonObjectManager().newObject(newMap);    }
private Map<String, Object> getMapFromJSON(String json) {        Map<String, Object> propMap = new HashMap<String, Object>();        ObjectMapper mapper = new ObjectMapper();        // Initialize string if empty        if (json == null || json.length() == 0) {            json = "{}";        }        try {            // Convert string            propMap = mapper.readValue(json, new TypeReference<HashMap<String, Object>>(){});        } catch (Exception e) {            ;        }        return propMap;    }
protected void mappingJsonBody(ActionRuntime runtime, VirtualForm virtualForm, String json) {        final JsonManager jsonManager = getJsonManager();        try {            final Class<?> formType = virtualForm.getFormMeta().getRootFormType(); // called only when root here            final Object fromJson = jsonManager.fromJson(json, formType);            acceptJsonRealForm(virtualForm, fromJson);        } catch (RuntimeException e) {            throwJsonBodyParseFailureException(runtime, virtualForm, json, e);        }    }

parse json file
public List<Feature> parseJsonFiles(List<String> jsonFiles) {        if (jsonFiles.isEmpty()) {            throw new ValidationException("None report file was added!");        }        List<Feature> featureResults = new ArrayList<>();        for (int i = 0; i < jsonFiles.size(); i++) {            String jsonFile = jsonFiles.get(i);            // if file is empty (is not valid JSON report), check if should be skipped or not            if (new File(jsonFile).length() == 0                    && configuration.containsReducingMethod(ReducingMethod.SKIP_EMPTY_JSON_FILES)) {                continue;            }            Feature[] features = parseForFeature(jsonFile);            LOG.log(Level.INFO, String.format("File '%s' contains %d features", jsonFile, features.length));            featureResults.addAll(Arrays.asList(features));        }        // report that has no features seems to be not valid        if (featureResults.isEmpty()) {            throw new ValidationException("Passed files have no features!");        }        return featureResults;    }
public List<DependencyInfo> parseFile(String filePath, String fileContents) {    return parseFileReader(filePath, new StringReader(fileContents));  }
public List<DependencyInfo> parseFile(String filePath) throws IOException {    return parseFileReader(filePath, Files.newReader(new File(filePath), StandardCharsets.UTF_8));  }
public DependencyInfo parseFile(String filePath, String closureRelativePath,      String fileContents) {    return parseReader(filePath, closureRelativePath, new StringReader(fileContents));  }
public void parseFile(File file) throws ParserException, IOException {        Reader reader = null;        try {            reader = new FileReader(file);            nanoElement.parseFromReader(reader);        } catch (XMLParseException e) {            throw new ParserException(e.getMessage());        } finally {            if (reader != null) reader.close();        }    }
private void parseFile(File file) throws Exception {        int lineNumber = 1;        String line = null;        BufferedReader in = null;        try {            in = new BufferedReader(new FileReader(file));            List<TZDBZone> openZone = null;            for ( ; (line = in.readLine()) != null; lineNumber++) {                int index = line.indexOf('#');  // remove comments (doesn't handle # in quotes)                if (index >= 0) {                    line = line.substring(0, index);                }                if (line.trim().length() == 0) {  // ignore blank lines                    continue;                }                StringTokenizer st = new StringTokenizer(line, " \t");                if (openZone != null && Character.isWhitespace(line.charAt(0)) && st.hasMoreTokens()) {                    if (parseZoneLine(st, openZone)) {                        openZone = null;                    }                } else {                    if (st.hasMoreTokens()) {                        String first = st.nextToken();                        if (first.equals("Zone")) {                            if (st.countTokens() < 3) {                                printVerbose("Invalid Zone line in file: " + file + ", line: " + line);                                throw new IllegalArgumentException("Invalid Zone line");                            }                            openZone = new ArrayList<TZDBZone>();                            zones.put(st.nextToken(), openZone);                            if (parseZoneLine(st, openZone)) {                                openZone = null;                            }                        } else {                            openZone = null;                            if (first.equals("Rule")) {                                if (st.countTokens() < 9) {                                    printVerbose("Invalid Rule line in file: " + file + ", line: " + line);                                    throw new IllegalArgumentException("Invalid Rule line");                                }                                parseRuleLine(st);                            } else if (first.equals("Link")) {                                if (st.countTokens() < 2) {                                    printVerbose("Invalid Link line in file: " + file + ", line: " + line);                                    throw new IllegalArgumentException("Invalid Link line");                                }                                String realId = st.nextToken();                                String aliasId = st.nextToken();                                links.put(aliasId, realId);                            } else {                                throw new IllegalArgumentException("Unknown line");                            }                        }                    }                }            }        } catch (Exception ex) {            throw new Exception("Failed while processing file '" + file + "' on line " + lineNumber + " '" + line + "'", ex);        } finally {            if (in != null) {                in.close();            }        }    }
private Object parseFile(File file, String scharset) {        Charset charset = scharset==null || scharset.length ()==0 ? StandardCharsets.UTF_8 : Charset.forName ( scharset );        if (file.length() > 2_000_000) {            try (Reader reader = Files.newBufferedReader( Classpaths.path(file.toString()), charset )) {                return parse(reader);            } catch(IOException ioe) {                throw new JsonException("Unable to process file: " + file.getPath(), ioe);            }        } else {            try {                return JsonFactory.create().fromJson ( Files.newBufferedReader( Classpaths.path(file.toString()), charset ) );            } catch ( IOException e ) {                throw new JsonException("Unable to process file: " + file.getPath(), e);            }        }    }
public static List<SecStrucState> parseFile(String dsspPath,Structure structure, boolean assign)throws IOException, StructureException {File file = new File(dsspPath);Reader read = new FileReader(file);BufferedReader reader = new BufferedReader(read);return generalParse(reader, structure, assign);}
private void parseFile(File schemaSourceFile, CourierParseResult result)      throws IOException  {    if (wasResolved(schemaSourceFile))    {      return;    }    final List<DataSchema> schemas = parseSchema(schemaSourceFile, result);    for (DataSchema schema : schemas)    {      validateSchemaWithFilePath(schemaSourceFile, schema);      result.getSchemaAndLocations().put(schema, new FileDataSchemaLocation(schemaSourceFile));      result.getSourceFiles().add(schemaSourceFile);    }  }
public void parseFile(File file, boolean utterancePerDoc) {        try {            // Build an xml document.            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();            DocumentBuilder db = dbf.newDocumentBuilder();            Document doc = db.parse(file);            // Extract all utterances.            NodeList utterances = doc.getElementsByTagName("u");            StringBuilder fileBuilder = new StringBuilder();            for (int i = 0; i < utterances.getLength(); ++i) {                // Extract all words from the utterance                Element item = (Element) utterances.item(i);                NodeList words = item.getElementsByTagName("w");                StringBuilder utteranceBuilder = new StringBuilder();                // Iterate over the words and get just the word text.                List<String> wordsInUtterance =                    new ArrayList<String>(words.getLength());                for (int j = 0; j < words.getLength(); ++j) {                    // Get the part of speech tag.                    Element wordNode = (Element) words.item(j);                    NodeList posNodeList = wordNode.getElementsByTagName("pos");                    String word = wordNode.getFirstChild().getNodeValue();                    if (posNodeList.getLength() > 0) {                        Node posNode =                             posNodeList.item(0).getFirstChild().getFirstChild();                        String pos = posNode.getNodeValue();                        posTags.put(word, pos);                        if (appendPosTags)                            word += "-" + pos;                    }                    wordsInUtterance.add(word);                }                // Each of the <a> nodes contains additional information about                // the currnet utterances.  This may be syntactic information,                // comments on the scene, descriptions of the action, or                // clarification by the observer.  For all comments but the                // syntactic, use the comment text to create new pseudo                // utterances by combining tokens from the utterance with                // pseudo-tokens in the comment.  The pseudo-tokens have a                // "-GROUNDING" suffix which distiguishes them from tokens                // actually present in the uttered speech.                NodeList auxNodes = item.getElementsByTagName("a");                List<String> augmentedUtterances = new LinkedList<String>();                if (generateAugmented) {                    for (int j = 0; j < auxNodes.getLength(); ++j) {                        // Get any comment for the utterance                        Node n = auxNodes.item(j);                        String auxNodeType = n.getAttributes().                            getNamedItem("type").getNodeValue();                        // Get only those nodes that contain comments or                        // descriptions on the utterance that may be used to                        // ground the words being referred to.                        if (auxNodeType.equals("action")                            || auxNodeType.equals("actions")                            || auxNodeType.equals("addressee")                            || auxNodeType.equals("comments")                            || auxNodeType.equals("explanation")                            || auxNodeType.equals("gesture")                            || auxNodeType.equals("happening")                            || auxNodeType.equals("situation")) {                                                        String commentOnUtterance =                                 n.getFirstChild().getNodeValue();                            // Use the iterator factory to tokenize in the event                            // that the user has specified some form of token                            // filtering                            Iterator<String> tokenIter =                                 IteratorFactory.tokenize(                                        new BufferedReader(                                            new StringReader(                                                commentOnUtterance)));                            // For each of the tokens in the additional                            // information, create a pseudo-utterance using a                            // word from the actual utterance and an                            // grounding-token                            while (tokenIter.hasNext()) {                                String token = tokenIter.next();                                for (String word : wordsInUtterance) {                                    augmentedUtterances.add(word + " "                                        + token + "-GROUNDING");                                }                            }                        }                    }                }                                    // Write the utterance if an utterance is a document.                for (Iterator<String> it = wordsInUtterance.iterator();                          it.hasNext(); ) {                    utteranceBuilder.append(it.next());                    if (it.hasNext())                        utteranceBuilder.append(" ");                }                String utterance = utteranceBuilder.toString();                if (utterancePerDoc) {                    print(utterance);                    // Print all the psuedo utterances constructed from the                    // comments                    for (String aug : augmentedUtterances)                        print(aug);                }                else {  // otherwise save the utterance.                    fileBuilder.append(utterance);                    if (separateByPeriod)                        fileBuilder.append(".");                    fileBuilder.append(" ");                    // Print all the psuedo utterances constructed from the                    // comments.  Unlike the utterances, print these as separate                    // documents to avoid having them register as co-occurrences                    // with other utterances.                    for (String aug : augmentedUtterances)                        print(aug);                }            }            // Write all the utterances if the whole xml file is a document.            if (!utterancePerDoc)                print(fileBuilder.toString());        } catch (Exception e) {            e.printStackTrace();        }    }

get current observable value
public long getCurrentValue(int nth) {    long v = min.getCurrent(nth).get();    return (v == Long.MAX_VALUE) ? 0L : v;  }
public V getCurrentValue(final K key) {    V value = cacheMap.get(key);    LOG.debug("Value for '{}' {} in cache", key, (value == null ? "not " : ""));    if (value != null && !value.isCurrent(key)) {      // value is not current; remove it and return null      remove(key);      return null;    }    return value;  }
@Override public Object getCurrentValue(FieldType field)   {      Object result = null;      if (field != null)      {         int fieldValue = field.getValue();         result = m_array[fieldValue];      }      return (result);   }
@Override public Object getCurrentValue(FieldType field)   {      Object result = null;      if (field != null)      {         ResourceField resourceField = (ResourceField) field;         switch (resourceField)         {            case COST_VARIANCE:            {               result = getCostVariance();               break;            }            case WORK_VARIANCE:            {               result = getWorkVariance();               break;            }            case CV:            {               result = getCV();               break;            }            case SV:            {               result = getSV();               break;            }            case OVERALLOCATED:            {               result = Boolean.valueOf(getOverAllocated());               break;            }            default:            {               result = m_array[field.getValue()];               break;            }         }      }      return (result);   }
@Override public Object getCurrentValue(FieldType field)   {      Object result = null;      if (field != null)      {         switch ((TaskField) field)         {            case PARENT_TASK_UNIQUE_ID:            {               result = m_parent == null ? Integer.valueOf(-1) : m_parent.getUniqueID();               break;            }            case START_VARIANCE:            {               result = getStartVariance();               break;            }            case FINISH_VARIANCE:            {               result = getFinishVariance();               break;            }            case START_SLACK:            {               result = getStartSlack();               break;            }            case FINISH_SLACK:            {               result = getFinishSlack();               break;            }            case COST_VARIANCE:            {               result = getCostVariance();               break;            }            case DURATION_VARIANCE:            {               result = getDurationVariance();               break;            }            case WORK_VARIANCE:            {               result = getWorkVariance();               break;            }            case CV:            {               result = getCV();               break;            }            case SV:            {               result = getSV();               break;            }            case TOTAL_SLACK:            {               result = getTotalSlack();               break;            }            case CRITICAL:            {               result = Boolean.valueOf(getCritical());               break;            }            case COMPLETE_THROUGH:            {               result = getCompleteThrough();               break;            }            default:            {               result = m_array[field.getValue()];               break;            }         }      }      return (result);   }
private ClockAndCount[] getCurrentValues(List<CounterUpdateCell> counterUpdateCells, ColumnFamilyStore cfs)    {        ClockAndCount[] currentValues = new ClockAndCount[counterUpdateCells.size()];        int remaining = counterUpdateCells.size();        if (CacheService.instance.counterCache.getCapacity() != 0)        {            Tracing.trace("Fetching {} counter values from cache", counterUpdateCells.size());            remaining = getCurrentValuesFromCache(counterUpdateCells, cfs, currentValues);            if (remaining == 0)                return currentValues;        }        Tracing.trace("Reading {} counter values from the CF", remaining);        getCurrentValuesFromCFS(counterUpdateCells, cfs, currentValues);        return currentValues;    }
@Purepublic List<Object> getCurrentValues() {if (this.allValues == null) {return Collections.emptyList();}return Collections.unmodifiableList(this.allValues);}
public int[] getCurrentValuesArray() {        int[] currentValues = new int[5];        currentValues[0] = getMinFilterType().getFilterValue(); // MIN FILTER        currentValues[1] = getMagFilterType().getFilterValue(); // MAG FILTER        currentValues[2] = getAnisotropicValue(); // ANISO FILTER        currentValues[3] = getWrapSType().getWrapValue(); // WRAP S        currentValues[4] = getWrapTType().getWrapValue(); // WRAP T        return currentValues;    }
public ValueContainer[] getCurrentLockingValues(Object o) throws PersistenceBrokerException    {        FieldDescriptor[] fields = getLockingFields();        ValueContainer[] result = new ValueContainer[fields.length];        for (int i = 0; i < result.length; i++)        {            result[i] = new ValueContainer(fields[i].getPersistentField().get(o), fields[i].getJdbcType());        }        return result;    }
private void getCurrentValuesFromCFS(List<CounterUpdateCell> counterUpdateCells,                                         ColumnFamilyStore cfs,                                         ClockAndCount[] currentValues)    {        SortedSet<CellName> names = new TreeSet<>(cfs.metadata.comparator);        for (int i = 0; i < currentValues.length; i++)            if (currentValues[i] == null)                names.add(counterUpdateCells.get(i).name());        ReadCommand cmd = new SliceByNamesReadCommand(getKeyspaceName(), key(), cfs.metadata.cfName, Long.MIN_VALUE, new NamesQueryFilter(names));        Row row = cmd.getRow(cfs.keyspace);        ColumnFamily cf = row == null ? null : row.cf;        for (int i = 0; i < currentValues.length; i++)        {            if (currentValues[i] != null)                continue;            Cell cell = cf == null ? null : cf.getColumn(counterUpdateCells.get(i).name());            if (cell == null || !cell.isLive()) // absent or a tombstone.                currentValues[i] = ClockAndCount.BLANK;            else                currentValues[i] = CounterContext.instance().getLocalClockAndCount(cell.value());        }    }

get name of enumerated value
public static String getHostnameValue() {        if (!hostnameInitialised) {            synchronized (LOCK) {                if (!hostnameInitialised) {                    hostname = lookupHostname();                    hostnameInitialised = true;                }            }        }        return hostname;    }
public NameValue getNameValueNode(String strName, Object objValue, boolean bAddIfNotFound)    {        Map<String,NameValue> map = this.getValueMap(bAddIfNotFound);        if (map == null)            return null;        NameValue value = (NameValue)map.get(this.getKey(strName, objValue));        if (value == null)            if (bAddIfNotFound)                this.addNameValueNode(value = new NameValue(strName, objValue));        return value;    }
public NameValue getNameValueLeaf(BaseMessageHeader header, boolean bAddIfNotFound)    {        Object[][] mxString = header.getNameValueTree();        NameValue node = this;        if (mxString != null)        {            for (int i = 0; i < mxString.length; i++)            {                node = node.getNameValueNode((String)mxString[i][MessageConstants.NAME], mxString[i][MessageConstants.VALUE], bAddIfNotFound);                if (node == null)                    return null;            }        }        return node;    }
public NameValue[] getNameValueArray(BaseMessageHeader header)    {        Object[][] mxString = header.getNameValueTree();        NameValue[] rgNodes = new NameValue[10];        rgNodes[0] = this;        int i = 0;        if (mxString != null)        {            for (; i < mxString.length; i++)            {                rgNodes[i + 1] = rgNodes[i].getNameValueNode((String)mxString[i][MessageConstants.NAME], mxString[i][MessageConstants.VALUE], false);                if (rgNodes[i + 1] == null)                    break;            }        }        NameValue[] rgNodesNew = new NameValue[i + 1];        for (int j = 0; j <= i; j++)        {            rgNodesNew[j] = rgNodes[j];        }        return rgNodesNew;    }
public Map<String, String> getGroupNameValueMap(String targetString) {        return getMatcherAsOpt(targetString)                .map(matcher -> groupNameList.stream()                        .collect(Collectors                                .toMap(Function.identity(), matcher::group)))                .orElseGet(Collections::emptyMap);    }
@Purepublic static String getColorNameFromValue(int colorValue) {for (final Entry<String, Integer> entry : COLOR_MATCHES.entrySet()) {final int knownValue = entry.getValue().intValue();if (colorValue == knownValue) {return entry.getKey();}}return null;}
private static Class<?> getNamedOutputValueClass(JobContext job, String namedOutput) {return job.getConfiguration().getClass(MO_PREFIX + namedOutput + VALUE, null, Object.class);}
public static Class<? extends Writable> getNamedOutputValueClass(JobConf conf,                                                  String namedOutput) {    checkNamedOutput(conf, namedOutput, false);    return conf.getClass(MO_PREFIX + namedOutput + VALUE, null,      Writable.class);  }
private String getNameValuePairForDisplay(final Object value) {        if (value != null) {            if (argumentAnnotation.sensitive()) {                return String.format("--%s ***********", getLongName());            } else {                // if we're displaying a tagged argument, include the tag name and attributes                if (value instanceof TaggedArgument) {                    return String.format("--%s %s", TaggedArgumentParser.getDisplayString(getLongName(), (TaggedArgument) value), value);                } else {                    return String.format("--%s %s", getLongName(), value);                }            }        }        return "";    }
private static Class<?> getDefaultNamedOutputValueClass(JobContext job) {return job.getConfiguration().getClass(DEFAULT_MO_PREFIX + VALUE, null, Object.class);}

encode url
public static String encodeUrl(String stringToEncode) {        try {            return URLEncoder.encode(stringToEncode, "UTF-8");        } catch (UnsupportedEncodingException e1) {            throw new RuntimeException(e1);        }    }
public static String encodeUrl(String url) {        Uri uri = Uri.parse(url);        try {            Map<String, List<String>> splitQuery = splitQuery(uri);            StringBuilder encodedQuery = new StringBuilder();            for (String key : splitQuery.keySet()) {                for (String value : splitQuery.get(key)) {                    if (encodedQuery.length() > 0) {                        encodedQuery.append("&");                    }                    encodedQuery.append(key + "=" + URLEncoder.encode(value, "UTF-8"));                }            }            String queryString = encodedQuery != null && encodedQuery.length() > 0 ? "?" + encodedQuery : "";            URI baseUri = new URI(uri.getScheme(), uri.getAuthority(), uri.getPath(), null, uri.getFragment());            return baseUri + queryString;        }        catch (UnsupportedEncodingException ignore) {}        catch (URISyntaxException ignore) {}        return uri.toString();    }
private static String encodeUrl(String url) {        try {            URL u = new URL(url);            return encodeUrl(u).toExternalForm();        } catch (Exception e) {            return url;        }}
public URL encodeURL(URL url) {if(!isValid()) {throw new IllegalStateException("SipApplicationSession already invalidated !");}String urlStr = url.toExternalForm();try {URL ret;if (urlStr.contains("?")) {ret = new URL(url + "&" + SIP_APPLICATION_KEY_PARAM_NAME + "="+ getId());} else {ret = new URL(url + "?" + SIP_APPLICATION_KEY_PARAM_NAME + "="+ getId());}return ret;} catch (Exception e) {throw new IllegalArgumentException("Failed encoding URL : " + url, e);}}
public String encodeURL(String relativePath, String scheme) {StringBuffer urlEncoded = new StringBuffer();//ContextContext context = (Context)sipManager.getContainer();//HostHost host = (Host)context.getParent();//ServiceService service = ((Engine)host.getParent()).getService();String[] aliases = host.findAliases();String hostname = null;// Needed for http://code.google.com/p/sipservlets/issues/detail?id=150// to pass TCK test com.bea.sipservlet.tck.agents.api.javax_servlet_sip.ConvergedHttpSessionTest.testEncodeURL002if(aliases.length < 1) {hostname = host.getName();} else {// FIXME would be better to try to match the alias by some path or IP but unaware if this is really needed at this point// or how it can be effectively donehostname = aliases[0];}//retrieving the port corresponding to the specified scheme//TODO ask EG what if the scheme is not supported on the server ?int port = -1;Connector[] connectors = service.findConnectors();int i = 0;while (i < connectors.length && port < 0) {if(scheme != null && connectors[i].getProtocol().toLowerCase().contains(scheme.toLowerCase())) {port = connectors[i].getPort();}i++;}urlEncoded = urlEncoded.append(scheme);urlEncoded = urlEncoded.append("://");urlEncoded = urlEncoded.append(hostname);urlEncoded = urlEncoded.append(":");urlEncoded = urlEncoded.append(port);urlEncoded = urlEncoded.append(((Context)sipManager.getContainer()).getPath());urlEncoded = urlEncoded.append(encodeURL(relativePath));return urlEncoded.toString();}
public String encodeURL(String url) {        StringBuffer urlEncoded = new StringBuffer();        int indexOfQuestionMark = url.indexOf("?");        if (indexOfQuestionMark > 0) {            // Handles those cases :            // http://forums.searchenginewatch.com/showthread.php?t=9817            // http://forums.searchenginewatch.com/showthread.php?p=72232#post72232            String urlBeforeQuestionMark = url.substring(0, indexOfQuestionMark);            String urlAfterQuestionMark = url.substring(indexOfQuestionMark);            urlEncoded = urlEncoded.append(urlBeforeQuestionMark);            urlEncoded = urlEncoded.append(";jsessionid=");            urlEncoded = urlEncoded.append(httpSession.getId());            urlEncoded = urlEncoded.append(urlAfterQuestionMark);        } else {            // Handles those cases :            // http://www.seroundtable.com/archives/003204.html#more            // http://www.seroundtable.com/archives#more            int indexOfPoundSign = url.indexOf("#");            if (indexOfPoundSign > 0) {                String urlBeforePoundSign = url.substring(0, indexOfPoundSign);                String urlAfterPoundSign = url.substring(indexOfPoundSign);                urlEncoded = urlEncoded.append(urlBeforePoundSign);                urlEncoded = urlEncoded.append(";jsessionid=");                urlEncoded = urlEncoded.append(httpSession.getId());                urlEncoded = urlEncoded.append(urlAfterPoundSign);            } else {                // Handles the rest                // http://www.seroundtable.com/archives/003204.html                // http://www.seroundtable.com/archives                urlEncoded = urlEncoded.append(url);                urlEncoded = urlEncoded.append(";jsessionid=");                urlEncoded = urlEncoded.append(httpSession.getId());            }        }        return urlEncoded.toString();    }
public String encodeURL(String relativePath, String scheme) {        StringBuffer urlEncoded = new StringBuffer();        // Context        SipContextImpl context = (SipContextImpl) sipManager.getContainer();        // ListenersService        List<ListenerService<?>> webServerListeners = context.getWebServerListeners();        // Host        String hostname = context.getDeploymentInfoFacade().getDeploymentInfo().getHostName();        // kakonyii: get aliases from undrertow's host service!        Set<String> aliases = context.getHostOfDeployment().getAllAliases();        // Needed for http://code.google.com/p/sipservlets/issues/detail?id=150        // to pass TCK test com.bea.sipservlet.tck.agents.api.javax_servlet_sip.ConvergedHttpSessionTest.testEncodeURL002        if (aliases.size() >= 1) {            // FIXME would be better to try to match the alias by some path or IP but unaware if this is really needed at this            // point            // or how it can be effectively done            hostname = (String) aliases.toArray()[0];        }        // retrieving the port corresponding to the specified scheme        // TODO ask EG what if the scheme is not supported on the server ?        // kakonyii: find out the port from undertow's web server listeners        int port = -1;        int i = 0;        while (i < webServerListeners.size() && port < 0) {            ListenerService<?> listener = webServerListeners.get(i);            if (scheme != null && ("http".equalsIgnoreCase(scheme) || "https".equalsIgnoreCase(scheme))                    && listener instanceof HttpListenerService) {                if (listener.getBinding().getValue() != null) {                    port = listener.getBinding().getValue().getPort();                    if (listener.getBinding().getValue().getAddress() != null) {                        hostname = listener.getBinding().getValue().getAddress().getHostName();                    }                }            }            i++;        }        urlEncoded = urlEncoded.append(scheme);        urlEncoded = urlEncoded.append("://");        urlEncoded = urlEncoded.append(hostname);        urlEncoded = urlEncoded.append(":");        urlEncoded = urlEncoded.append(port);        // check that at SipContextImpl.getPath():        urlEncoded = urlEncoded.append(context.getPath());        urlEncoded = urlEncoded.append(encodeURL(relativePath));        return urlEncoded.toString();    }
public static String encodeUrl(final String urlStr) {if (Util.empty(urlStr)) {return urlStr;}// Percent EncodeString percentEncode = percentEncodeUrl(urlStr);// XML Enocdereturn encode(percentEncode);}
public String encodeURL(String relativePath, String scheme) {return session.encodeURL(relativePath, scheme);}
public String encodeURL(String relativePath, String scheme) {return convergedSessionDelegate.encodeURL(relativePath, scheme);}

create cookie
private Cookie createCookie(String str) throws UnsupportedEncodingException {    if (LOG.isDebugEnabled()) {      LOG.debug("Cookie name = " + AUTH_COOKIE + " value = " + str);    }    Cookie cookie = new Cookie(AUTH_COOKIE, str);    cookie.setMaxAge(cookieMaxAge);    if (cookieDomain != null) {      cookie.setDomain(cookieDomain);    }    if (cookiePath != null) {      cookie.setPath(cookiePath);    }    cookie.setSecure(isCookieSecure);    return cookie;  }
public static Map createCookieMap(PageContext pContext)    {        // Read all the cookies and construct the entire map        HttpServletRequest request = (HttpServletRequest) pContext.getRequest();        Cookie[] cookies = request.getCookies();        Map ret = new HashMap();        for (int i = 0; cookies != null && i < cookies.length; i++) {            Cookie cookie = cookies[i];            if (cookie != null) {                String name = cookie.getName();                if (!ret.containsKey(name)) {                    ret.put(name, cookie);                }            }        }        return ret;    }
public static Map<String, String> createCookiesMap(HttpServletRequest request) {        Map<String, String> cookiesMap = new HashMap<String, String>();        Cookie[] cookies = request.getCookies();        if (ArrayUtils.isNotEmpty(cookies)) {            for (Cookie cookie : request.getCookies()) {                cookiesMap.put(cookie.getName(), cookie.getValue());            }        }        return cookiesMap;    }
public static String createCookieToken(String clientUserName) {    StringBuffer sb = new StringBuffer();    sb.append(COOKIE_CLIENT_USER_NAME).append(COOKIE_KEY_VALUE_SEPARATOR).append(clientUserName)      .append(COOKIE_ATTR_SEPARATOR);    sb.append(COOKIE_CLIENT_RAND_NUMBER).append(COOKIE_KEY_VALUE_SEPARATOR)      .append((new Random(System.currentTimeMillis())).nextLong());    return sb.toString();  }
protected IPortalCookie getOrCreatePortalCookie(HttpServletRequest request) {        IPortalCookie result = null;        // first check in request        final Cookie cookie = this.getCookieFromRequest(this.cookieName, request);        if (cookie != null) {            // found a potential cookie, call off to the dao            final String value = cookie.getValue();            result = this.portletCookieDao.getPortalCookie(value);        }        // still null? check in the session        if (result == null) {            result = locatePortalCookieInSession(request.getSession());        }        // if by this point we still haven't found the portal cookie, create one        if (result == null) {            result = this.portletCookieDao.createPortalCookie(this.maxAge);            // store the portal cookie value value in the session            HttpSession session = request.getSession();            synchronized (WebUtils.getSessionMutex(session)) {                session.setAttribute(SESSION_ATTRIBUTE__PORTAL_COOKIE_ID, result.getValue());            }        }        return result;    }
public CookieConfigType<SessionConfigType<T>> getOrCreateCookieConfig()   {      Node node = childNode.getOrCreate("cookie-config");      CookieConfigType<SessionConfigType<T>> cookieConfig = new CookieConfigTypeImpl<SessionConfigType<T>>(this, "cookie-config", childNode, node);      return cookieConfig;   }
@NonNull    public <T> T create(@NonNull Class<? extends T> clazz, @NonNull Fallback<T> fallback) {        T t = create(clazz);        return t != null ? t : fallback.get();    }
@NonNull    public <T> List<T> create(@NonNull Collection<Class<? extends T>> classes) {        final List<T> result = new ArrayList<>();        for (Class<? extends T> clazz : classes) {            final T instance = create(clazz);            if (instance != null) {                result.add(instance);            }        }        return result;    }
public static Fingerprint create(String ufsName, UfsStatus status) {    if (status == null) {      return new Fingerprint(Collections.emptyMap());    }    return new Fingerprint(Fingerprint.createTags(ufsName, status));  }
public static Fingerprint create(String ufsName, UfsStatus status, AccessControlList acl) {    if (status == null) {      return new Fingerprint(Collections.emptyMap());    }    Map<Tag, String> tagMap = Fingerprint.createTags(ufsName, status);    if (acl != null) {      tagMap.put(Tag.ACL, acl.toString());    }    return new Fingerprint(tagMap);  }

how to empty array
public static JsonArray array(String... strings) {    if (strings == null) {      throw new NullPointerException("values is null");    }    JsonArray array = new JsonArray();    for (String value : strings) {      array.add(value);    }    return array;  }
public INDArray array() {        List<INDArray> retList = new ArrayList<>(list.size());        for(X x : list) {            INDArray arr = x.array();            retList.add(arr.reshape(1, arr.length()));        }        return Nd4j.concat(0,retList.toArray(new INDArray[retList.size()]));    }
public static <T> QueryParameterValue array(T[] array, Class<T> clazz) {    return array(array, classToType(clazz));  }
public static <T> QueryParameterValue array(T[] array, StandardSQLTypeName type) {    List<QueryParameterValue> listValues = new ArrayList<>();    for (T obj : array) {      listValues.add(QueryParameterValue.of(obj, type));    }    return QueryParameterValue.newBuilder()        .setArrayValues(listValues)        .setType(StandardSQLTypeName.ARRAY)        .setArrayType(type)        .build();  }
@Override  public Object[] array() {    DataType dt = data.dataType();    Object[] list = new Object[length];    try {      for (int i = 0; i < length; i++) {        if (!data.isNullAt(offset + i)) {          list[i] = get(i, dt);        }      }      return list;    } catch(Exception e) {      throw new RuntimeException("Could not get the array", e);    }  }
public static Array array(Object array) {        if (array instanceof Object[]) {            return array((Object[]) array);        }        switch (tId(array.getClass())) {            case I_BOOLEAN:     return array((boolean[]) array);            case I_BYTE:        return array((byte[]) array);            case I_CHARACTER:   return array((char[]) array);            case I_DOUBLE:      return array((double[]) array);            case I_FLOAT:       return array((float[]) array);            case I_INTEGER:     return array((int[]) array);            case I_LONG:        return array((long[]) array);            case I_SHORT:       return array((short[]) array);        }        throw new IllegalArgumentException("No array: " + array);    }
public static Type array(Type elementType) {    Preconditions.checkNotNull(elementType);    switch (elementType.getCode()) {      case BOOL:        return TYPE_ARRAY_BOOL;      case INT64:        return TYPE_ARRAY_INT64;      case FLOAT64:        return TYPE_ARRAY_FLOAT64;      case STRING:        return TYPE_ARRAY_STRING;      case BYTES:        return TYPE_ARRAY_BYTES;      case TIMESTAMP:        return TYPE_ARRAY_TIMESTAMP;      case DATE:        return TYPE_ARRAY_DATE;      default:        return new Type(Code.ARRAY, elementType, null);    }  }
Expr array() {if (peek().sym != Sym.LBRACK) {return atom();}move();if (peek().sym == Sym.RBRACK) {move();return new Array(ExprList.NULL_EXPR_ARRAY, location);}ExprList exprList = exprList();if (exprList.length() == 1 && peek().sym == Sym.RANGE) {move();Expr end = expr();match(Sym.RBRACK);return new RangeArray(exprList.getExprArray()[0], end, location);}match(Sym.RBRACK);return new Array(exprList.getExprArray(), location);}
public JSONWriter array() throws JSONException {    if (this.mode == 'i' || this.mode == 'o' || this.mode == 'a') {      this.push(null);      this.append("[");      this.comma = false;      return this;    }    throw new JSONException("Misplaced array.");  }
@Override    public CompoundSelection<Object[]> array(Selection<?>... arg0)    {        return new DefaultCompoundSelection<Object[]>(Arrays.asList(arg0), Object.class);    }

how to get current date
public static Date getCurrentDate(Context context) throws GeneralException {        URI propName = Constants.ENVIRONMENT.CURRENT_DATE_TIME.attributeId;        String dateTimeValue = context.getEnvironmentValue(propName);        if (dateTimeValue == null) {            throw new GeneralException("Missing value for environment "                    + "context attribute: " + propName);        }        try {            return DateUtility.parseDateStrict(dateTimeValue);        } catch (ParseException e) {            throw new GeneralException(e.getMessage());        }    }
public static Date getCurrentDateTime() throws ParseException {        Calendar currentDate = Calendar.getInstance();        SimpleDateFormat formatter = new SimpleDateFormat(DATE_yyyyMMddTHHmmssSSSZ);        String dateNow = formatter.format(currentDate.getTime());        return getDateFromString(dateNow);    }
public static Date getCurrentDateTime() {        java.util.Calendar calNow = java.util.Calendar.getInstance();        java.util.Date dtNow = calNow.getTime();        return dtNow;    }
public static String getCurrentDateTime(final String localeLang, final String localeCountry, final String timezone, final String dateFormat) throws Exception {        final DateTimeFormatter formatter = getDateTimeFormatter(localeLang, localeCountry, timezone, dateFormat);        final DateTime datetime = DateTime.now();        if (DateTimeUtils.isUnix(localeLang)) {            Long unixSeconds = (long) Math.round(datetime.getMillis() / Constants.Miscellaneous.THOUSAND_MULTIPLIER);            return unixSeconds.toString();        }        return formatter.print(datetime);    }
public String getCurrentExpireDate() {        // get the expiration date        if (isMultiOperation()) {            return CmsTouch.DEFAULT_DATE_STRING;        } else {            try {                CmsResource res = getCms().readResource(getParamResource(), CmsResourceFilter.IGNORE_EXPIRATION);                if (res.getDateExpired() == CmsResource.DATE_EXPIRED_DEFAULT) {                    return CmsTouch.DEFAULT_DATE_STRING;                } else {                    return CmsCalendarWidget.getCalendarLocalizedTime(getLocale(), getMessages(), res.getDateExpired());                }            } catch (CmsException e) {                return CmsCalendarWidget.getCalendarLocalizedTime(                    getLocale(),                    getMessages(),                    System.currentTimeMillis());            }        }    }
public Date getDate() {    double secs = timeUnit.getValueInSeconds(value);    return new Date(getDateOrigin().getTime() + (long) (1000 * secs));  }
static public java.util.Date getDate(int julianDays, int msecs) {        long total = ((long) (julianDays - 1)) * 24 * 3600 * 1000 + msecs;        return new Date(total);    }
public Date getDate() {        Date date = new Date();        try {            String dateText = field.getText();            SimpleDateFormat fmt = new SimpleDateFormat(format);            date = fmt.parse(dateText);        } catch (Exception e) {        }        return date;    }
public static Date getDate(Map<String, Object> map, String key, String dateTimeFormat) {        Object obj = map.get(key);        return obj instanceof Number ? new Date(((Number) obj).longValue())                : (obj instanceof String                        ? DateFormatUtils.fromString(obj.toString(), dateTimeFormat)                        : (obj instanceof Date ? (Date) obj : null));    }
@Override    public Date getDate(int index) {        check(index);        return DateUtils.fromJson(getString(index));    }

how to make the checkbox checked
public static <V, X extends Exception> CheckedFuture<V, X> makeChecked(      ListenableFuture<V> future, Function<? super Exception, X> mapper) {    return new MappingCheckedFuture<V, X>(checkNotNull(future), mapper);  }
public static Element makeCheckmark(SVGPlot svgp) {    Element checkmark = svgp.svgElement(SVGConstants.SVG_PATH_TAG);    checkmark.setAttribute(SVGConstants.SVG_D_ATTRIBUTE, SVG_CHECKMARK_PATH);    checkmark.setAttribute(SVGConstants.SVG_FILL_ATTRIBUTE, SVGConstants.CSS_BLACK_VALUE);    checkmark.setAttribute(SVGConstants.SVG_STROKE_ATTRIBUTE, SVGConstants.CSS_NONE_VALUE);    return checkmark;  }
final TypeCheck makeTypeCheck(AbstractCompiler compiler) {    return new TypeCheck(            compiler,            compiler.getReverseAbstractInterpreter(),            compiler.getTypeRegistry(),            topScope,            typedScopeCreator)        .reportUnknownTypes(options.enables(DiagnosticGroup.forType(TypeCheck.UNKNOWN_EXPR_TYPE)))        .reportMissingProperties(            !options.disables(DiagnosticGroup.forType(TypeCheck.INEXISTENT_PROPERTY)));  }
public static void makeSecurityCheck( final File    file,                                          final File    base )    {        if( ! file.getAbsolutePath().startsWith( base.getAbsolutePath() ) )        {            throw new IllegalArgumentException( "Illegal file path [" + file + "]" );        }    }
private Collection<Node> check(final Collection<Selector> parts) throws NodeSelectorException {Collection<Node> result = new LinkedHashSet<Node>();result.add(root);boolean initialPart=true;for (Selector selector : parts) {Checker<Node> checker = new TagChecker<Node>(helper, selector, initialPart);result = checker.check(result);if (selector.hasSpecifiers())for (Specifier specifier : selector.getSpecifiers()) {switch (specifier.getType()) {case ATTRIBUTE:checker = new AttributeSpecifierChecker<Node>(helper, (AttributeSpecifier) specifier);break;case PSEUDO:if (specifier instanceof PseudoClassSpecifier)checker = new PseudoClassSpecifierChecker<Node>(helper, (PseudoClassSpecifier) specifier);else if (specifier instanceof PseudoNthSpecifier)checker = new PseudoNthSpecifierChecker<Node>(helper, (PseudoNthSpecifier) specifier);else if (specifier instanceof PseudoContainsSpecifier)checker = new PseudoContainsSpecifierChecker<Node>(helper, (PseudoContainsSpecifier) specifier);break;case NEGATION:final Collection<Node> negationNodes = checkNegationSpecifier((NegationSpecifier) specifier);checker = new Checker<Node>() {@Overridepublic List<Node> check(final Collection<Node> nodes) {Collection<Node> set = new LinkedHashSet<Node>(nodes);set.removeAll(negationNodes);return new ArrayList<Node>(set);}};break;}result = checker.check(result);if (result.isEmpty())// Bail out early.return result;}initialPart=false;}return result;}
private Set<Node> check(List<Selector> parts) throws NodeSelectorException {        Set<Node> result = new LinkedHashSet<Node>();        result.add(root);        for (Selector selector : parts) {            NodeTraversalChecker checker = new TagChecker(selector);            result = checker.check(result, root);            if (selector.hasSpecifiers()) {                for (Specifier specifier : selector.getSpecifiers()) {                    switch (specifier.getType()) {                    case ATTRIBUTE:                        checker = new AttributeSpecifierChecker((AttributeSpecifier) specifier);                        break;                    case PSEUDO:                        if (specifier instanceof PseudoClassSpecifier) {                            checker = new PseudoClassSpecifierChecker((PseudoClassSpecifier) specifier);                        } else if (specifier instanceof PseudoNthSpecifier) {                            checker = new PseudoNthSpecifierChecker((PseudoNthSpecifier) specifier);                        }                                                break;                    case NEGATION:                        final Set<Node> negationNodes = checkNegationSpecifier((NegationSpecifier) specifier);                        checker = new NodeTraversalChecker() {                            @Override                            public Set<Node> check(Set<Node> nodes, Node root) throws NodeSelectorException {                                Set<Node> set = new LinkedHashSet<Node>(nodes);                                set.removeAll(negationNodes);                                return set;                            }                        };                                                break;                    }                                        result = checker.check(result, root);                    if (result.isEmpty()) {                        // Bail out early.                        return result;                    }                }            }        }                return result;    }
@Overridepublic Collection<Node> check(final Collection<Node> nodes) {Assert.notNull(nodes, "nodes is null!");this.nodes = nodes;result = new LinkedHashSet<Node>();switch (selector.getCombinator()) {case DESCENDANT:addDescendantElements();break;case CHILD:addChildElements();break;case ADJACENT_SIBLING:addAdjacentSiblingElements();break;case GENERAL_SIBLING:addGeneralSiblingElements();break;}return result;}
public void check(final int api) {        if (api == Opcodes.ASM4) {            if (visibleTypeAnnotations != null                    && visibleTypeAnnotations.size() > 0) {                throw new RuntimeException();            }            if (invisibleTypeAnnotations != null                    && invisibleTypeAnnotations.size() > 0) {                throw new RuntimeException();            }            for (FieldNode f : fields) {                f.check(api);            }            for (MethodNode m : methods) {                m.check(api);            }        }    }
@Override    public Set<Node> check(Set<Node> nodes, Node root) throws NodeSelectorException {        Assert.notNull(nodes, "nodes is null!");        this.nodes = nodes;        //Document doc = (root instanceof Document) ? (Document) root : DOMHelper.getOwnerDocument(root);        caseSensitive = false;  //!doc.createElement("a").isEqualNode(doc.createElement("A"));        result = new LinkedHashSet<Node>();        switch (selector.getCombinator()) {        case DESCENDANT:            addDescendantElements();            break;        case CHILD:            addChildElements();            break;        case ADJACENT_SIBLING:            addAdjacentSiblingElements();            break;        case GENERAL_SIBLING:            addGeneralSiblingElements();            break;        }                return result;    }
@Overridepublic Collection<Node> check(final Collection<Node> nodes)  {Assert.notNull(nodes, "nodes is null!");this.nodes = nodes;result = new LinkedHashSet<Node>();String value = specifier.getValue();if ("nth-child".equals(value))addNthChild(false);else if ("nth-last-child".equals(value))addNthLastChild(false);else if ("nth-of-type".equals(value))addNthChild(true);else if ("nth-last-of-type".equals(value))addNthLastChild(false);elsethrow new RuntimeException("Unknown pseudo nth class: " + value);return result;}

initializing array
public static JsonArray array(String... strings) {    if (strings == null) {      throw new NullPointerException("values is null");    }    JsonArray array = new JsonArray();    for (String value : strings) {      array.add(value);    }    return array;  }
public INDArray array() {        List<INDArray> retList = new ArrayList<>(list.size());        for(X x : list) {            INDArray arr = x.array();            retList.add(arr.reshape(1, arr.length()));        }        return Nd4j.concat(0,retList.toArray(new INDArray[retList.size()]));    }
public static <T> QueryParameterValue array(T[] array, Class<T> clazz) {    return array(array, classToType(clazz));  }
public static <T> QueryParameterValue array(T[] array, StandardSQLTypeName type) {    List<QueryParameterValue> listValues = new ArrayList<>();    for (T obj : array) {      listValues.add(QueryParameterValue.of(obj, type));    }    return QueryParameterValue.newBuilder()        .setArrayValues(listValues)        .setType(StandardSQLTypeName.ARRAY)        .setArrayType(type)        .build();  }
@Override  public Object[] array() {    DataType dt = data.dataType();    Object[] list = new Object[length];    try {      for (int i = 0; i < length; i++) {        if (!data.isNullAt(offset + i)) {          list[i] = get(i, dt);        }      }      return list;    } catch(Exception e) {      throw new RuntimeException("Could not get the array", e);    }  }
public static Array array(Object array) {        if (array instanceof Object[]) {            return array((Object[]) array);        }        switch (tId(array.getClass())) {            case I_BOOLEAN:     return array((boolean[]) array);            case I_BYTE:        return array((byte[]) array);            case I_CHARACTER:   return array((char[]) array);            case I_DOUBLE:      return array((double[]) array);            case I_FLOAT:       return array((float[]) array);            case I_INTEGER:     return array((int[]) array);            case I_LONG:        return array((long[]) array);            case I_SHORT:       return array((short[]) array);        }        throw new IllegalArgumentException("No array: " + array);    }
public static Type array(Type elementType) {    Preconditions.checkNotNull(elementType);    switch (elementType.getCode()) {      case BOOL:        return TYPE_ARRAY_BOOL;      case INT64:        return TYPE_ARRAY_INT64;      case FLOAT64:        return TYPE_ARRAY_FLOAT64;      case STRING:        return TYPE_ARRAY_STRING;      case BYTES:        return TYPE_ARRAY_BYTES;      case TIMESTAMP:        return TYPE_ARRAY_TIMESTAMP;      case DATE:        return TYPE_ARRAY_DATE;      default:        return new Type(Code.ARRAY, elementType, null);    }  }
Expr array() {if (peek().sym != Sym.LBRACK) {return atom();}move();if (peek().sym == Sym.RBRACK) {move();return new Array(ExprList.NULL_EXPR_ARRAY, location);}ExprList exprList = exprList();if (exprList.length() == 1 && peek().sym == Sym.RANGE) {move();Expr end = expr();match(Sym.RBRACK);return new RangeArray(exprList.getExprArray()[0], end, location);}match(Sym.RBRACK);return new Array(exprList.getExprArray(), location);}
public JSONWriter array() throws JSONException {    if (this.mode == 'i' || this.mode == 'o' || this.mode == 'a') {      this.push(null);      this.append("[");      this.comma = false;      return this;    }    throw new JSONException("Misplaced array.");  }
@Override    public CompoundSelection<Object[]> array(Selection<?>... arg0)    {        return new DefaultCompoundSelection<Object[]>(Arrays.asList(arg0), Object.class);    }

how to reverse a string
private static String reverseString(String source) {    int i;    int len = source.length();    StringBuffer dest = new StringBuffer();    for (i = (len - 1); i >= 0; i--) {      dest.append(source.charAt(i));    }    return dest.toString();  }
public static String string(byte[] bytes) {    if (bytes == null) {      return null;    }    try {      return new String(bytes, ENCODING);    } catch (UnsupportedEncodingException e) {      log.error("UnsupportedEncodingException ", e);      throw new RuntimeException(e);    }  }
public static Pattern string(final String string) {    return new Pattern() {      @Override public int match(CharSequence src, int begin, int end) {        if ((end - begin) < string.length()) return MISMATCH;        return matchString(string, src, begin, end);      }      @Override public String toString() {        return string;      }    };  }
public static KeyValuePair<byte[], byte[]> string(KeyValuePair<byte[], ?> raw, byte[] value) {        KeyStringValueString kv = new KeyStringValueString();        copy(raw, kv);        kv.setValue(value);        return kv;    }
public static BatchedKeyStringValueString string(KeyValuePair<byte[], ?> raw, byte[] value, int batch, boolean last) {        BatchedKeyStringValueString kv = new BatchedKeyStringValueString();        copy(raw, kv, batch, last);        kv.setValue(value);        return kv;    }
public Table string(String s, String fileExtension) {DataReader<?> reader = registry.getReaderForExtension(fileExtension);try {            return reader.read(Source.fromString(s));} catch (IOException e) {    throw new IllegalStateException(e);}    }
public String string(StringCondition condition) {        String description;        if (condition.getContext() != null && condition.getContext().get(CONTEXT_PROPERTY_DESCRIPTION) != null) {            description = condition.getContext().get(CONTEXT_PROPERTY_DESCRIPTION);        } else {            description = condition.getDataId();        }        StringCondition.Operator operator = condition.getOperator();        switch (operator) {            case STARTS_WITH:                description += "starts with ";                break;            case CONTAINS:                description += "contains ";                break;            case ENDS_WITH:                description += "ends with ";                break;            case EQUAL:                description += "is equal to ";                break;            case NOT_EQUAL:                description += "is not equal to ";                break;            case MATCH:                description += "matches to ";                break;            default:                throw new IllegalArgumentException(operator.name());        }        description += condition.getPattern();        if (condition.isIgnoreCase()) {            description += " (ignore case)";        }        return description;    }
static List<String> string(String name, @Nullable String value) {    if (!Strings.isNullOrEmpty(value)) {      return Arrays.asList("--" + name, value);    }    return Collections.emptyList();  }
private String string(JsonObject node, String key, String default_) {    JsonElement value = node.get(key);    if (value != null && value.isJsonPrimitive()) {      return value.getAsString();    }    return default_;  }
public static String string(ByteBuffer buffer, int position, int length) throws CharacterCodingException    {        return string(buffer, position, length, StandardCharsets.UTF_8);    }

read properties file
private void readPropertiesFile(final String custConfFileName) {        final Properties p = new Properties();        LOGGER.log(READ_CONF_FILE, custConfFileName);        try (InputStream is = ClasspathUtility.loadInputStream(custConfFileName)) {            // Read the properties file            p.load(is);            for (final Map.Entry<Object, Object> entry : p.entrySet()) {                if (this.propertiesParametersMap.containsKey(entry.getKey())) {                    LOGGER.log(UPDATE_PARAMETER, entry.getKey(), entry.getValue());                } else {                    LOGGER.log(STORE_PARAMETER, entry.getKey(), entry.getValue());                }                storePropertiesParameter(entry);            }        } catch (final IOException e) {            LOGGER.error(CONF_READING_ERROR, custConfFileName);        }    }
private void readPropertiesFile(final String rbFilename) {        final File rbFile = new File(rbFilename);        final String rbName = rbFile.getName().substring(0, rbFile.getName().lastIndexOf(".properties"));        if (rbName == null || rbName.isEmpty()) {            LOGGER.error(JRebirthMarkers.MESSAGE, "Resource Bundle must be not null and not empty");        } else {            LOGGER.info(JRebirthMarkers.MESSAGE, "Store ResourceBundle : {} ", rbName);            try {                this.resourceBundles.add(ResourceBundle.getBundle(rbName));            } catch (final MissingResourceException e) {                LOGGER.error(JRebirthMarkers.MESSAGE, "{} Resource Bundle not found", rbName);            }        }    }
public static SimpleFeatureCollection readPropertiesfile( String path ) throws IOException {        OmsPropertiesFeatureReader reader = new OmsPropertiesFeatureReader();        reader.file = path;        reader.readFeatureCollection();        return reader.geodata;    }
private void readPropertiesFiles() {        if (this.messageFileWildcard.isEmpty() || !CoreParameters.LOG_RESOLUTION.get()) {            // Skip configuration loading            LOGGER.info(JRebirthMarkers.MESSAGE, "Messages Loading is skipped");        } else {            // Assemble the regex pattern            final Pattern filePattern = Pattern.compile(this.messageFileWildcard + "\\.properties");            // Retrieve all resources from default classpath            final Collection<String> list = ClasspathUtility.getClasspathResources(filePattern);            LOGGER.info(JRebirthMarkers.MESSAGE, "{} Messages file{} found.", list.size(), list.size() > 1 ? "s" : "");            for (final String rbFilename : list) {                readPropertiesFile(rbFilename);            }        }    }
private void readPropertiesFiles() {        if (this.configurationFileWildcard.isEmpty() || this.configurationFileExtension.isEmpty()) {            // Skip configuration loading            LOGGER.log(SKIP_CONF_LOADING);        } else {            // Assemble the regex pattern            final Pattern filePattern = Pattern.compile(this.configurationFileWildcard + "\\." + this.configurationFileExtension);            // Retrieve all resources from default classpath            final Collection<String> list = ClasspathUtility.getClasspathResources(filePattern);            LOGGER.log(CONFIG_FOUND, list.size(), list.size() > 1 ? "s" : "");            for (final String confFilename : list) {                readPropertiesFile(confFilename);            }        }    }
public static Properties readPropertiesFromFile(String _fileName, Properties _props) {        Properties props = _props == null ? new Properties() : _props;        LOGGER.debug("Trying to read properties from file: " + _fileName);        Properties newProperties = readProperties(new File(_fileName));        if (newProperties != null) {            LOGGER.debug("Successfully read properties from file: " + _fileName);            props.putAll(newProperties);        }        return props;    }
public Map readProperties()      throws PropertyException, IOException   {      Properties props = new Properties();            // load each specified property file      for (int i=0; i<filenames.length; i++) {         loadProperties(props, filenames[i]);      }      return props;   }
public static Properties readProperties(String resourceName)            throws Exception {        Properties defaultProps = new Properties();        try {            // Apparently hardcoded slashes are OK here            // jdk1.1/docs/guide/misc/resources.html            //      defaultProps.load(ClassLoader.getSystemResourceAsStream(resourceName));            defaultProps.load((new Utils()).getClass().getClassLoader().getResourceAsStream(resourceName));        } catch (Exception ex) {            /*      throw new Exception("Problem reading default properties: "            + ex.getMessage()); */            System.err.println("Warning, unable to load properties file from "                    + "system resource (Utils.java)");        }        // Hardcoded slash is OK here        // eg: see jdk1.1/docs/guide/misc/resources.html        int slInd = resourceName.lastIndexOf('/');        if (slInd != -1) {            resourceName = resourceName.substring(slInd + 1);        }        // Allow a properties file in the home directory to override        Properties userProps = new Properties(defaultProps);        File propFile = new File(System.getProperties().getProperty("user.home")                + File.separatorChar                + resourceName);        if (propFile.exists()) {            try {                userProps.load(new FileInputStream(propFile));            } catch (Exception ex) {                throw new Exception("Problem reading user properties: " + propFile);            }        }        // Allow a properties file in the current directory to override        Properties localProps = new Properties(userProps);        propFile = new File(resourceName);        if (propFile.exists()) {            try {                localProps.load(new FileInputStream(propFile));            } catch (Exception ex) {                throw new Exception("Problem reading local properties: " + propFile);            }        }        return localProps;    }
public static Properties readProperties(String fileOrResource) throws IOException {        InputStream in = Util.class.getResourceAsStream(fileOrResource);        Properties props = new Properties();        if (in != null) {            props.load(in);        } else {            FileInputStream fin = new FileInputStream(fileOrResource);            props.load(fin);            fin.close();        }        return props;    }
public static Properties readProperties(String strFileName){Properties properties = new Properties();File fileProperties = new File(strFileName);try{if (!fileProperties.exists())fileProperties.createNewFile();InputStream inStream = new FileInputStream(fileProperties);properties.load(inStream);inStream.close();} catch (IOException ex){ex.printStackTrace();}return properties;}

copy to clipboard
public static <T> List<T> nCopies(int n, T o) {        if (n < 0)            throw new IllegalArgumentException("List length = " + n);        return new CopiesList<>(n, o);    }
public static DistCopier getCopier(final Configuration conf,      final Arguments args) throws IOException {    DistCopier dc = new DistCopier(conf, args);    dc.setupJob();    if (dc.getJobConf() != null) {      return dc;    } else {      return null;    }  }
public <C> CacheManagerBuilder<T> withCopier(Class<C> clazz, Class<? extends Copier<C>> copier) {    DefaultCopyProviderConfiguration service = configBuilder.findServiceByClass(DefaultCopyProviderConfiguration.class);    if (service == null) {      service = new DefaultCopyProviderConfiguration();      service.addCopierFor(clazz, copier);      return new CacheManagerBuilder<>(this, configBuilder.addService(service));    } else {      DefaultCopyProviderConfiguration newConfig = new DefaultCopyProviderConfiguration(service);      newConfig.addCopierFor(clazz, copier, true);      return new CacheManagerBuilder<>(this, configBuilder.removeService(service).addService(newConfig));    }  }
public <T> DefaultCopyProviderConfiguration addCopierFor(Class<T> clazz, Class<? extends Copier<T>> copierClass) {    return addCopierFor(clazz, copierClass, false);  }
public <T> DefaultCopyProviderConfiguration addCopierFor(Class<T> clazz, Class<? extends Copier<T>> copierClass, boolean overwrite) {    if (clazz == null) {      throw new NullPointerException("Copy target class cannot be null");    }    if (copierClass == null) {      throw new NullPointerException("Copier class cannot be null");    }    if (!overwrite && getDefaults().containsKey(clazz)) {      throw new IllegalArgumentException("Duplicate copier for class : " + clazz);    }    getDefaults().put(clazz, new DefaultCopierConfiguration<>(copierClass));    return this;  }
@Override    public void onCopiedFrom(Item src) {        super.onCopiedFrom(src);        //noinspection unchecked        TemplateDrivenMultiBranchProject<P, B> projectSrc = (TemplateDrivenMultiBranchProject<P, B>) src;        /*         * onLoad should have been invoked already, so there should be an         * empty template.  Just update by XML and that's it.         */        try {            template.updateByXml((Source) new StreamSource(projectSrc.getTemplate().getConfigFile().readRaw()));        } catch (IOException e) {            LOGGER.log(Level.WARNING, "Failed to copy template from " + src.getName() + " into " + getName(), e);        }    }
public UserManagedCacheBuilder<K, V, T> withKeyCopier(Copier<K> keyCopier) {    if (keyCopier == null) {      throw new NullPointerException("Null key copier");    }    UserManagedCacheBuilder<K, V, T> otherBuilder = new UserManagedCacheBuilder<>(this);    otherBuilder.keyCopier = keyCopier;    otherBuilder.useKeySerializingCopier = false;    return otherBuilder;  }
public boolean addCopiedFile(File sourceFilePath, File destinationFilePath, int percentage) {    if (null == sourceFilePath || null == destinationFilePath) {      return false;    }    return copiedFiles.add(new CopiedOrMovedFile(sourceFilePath, destinationFilePath, percentage));  }
public CacheConfigurationBuilder<K, V> withKeyCopier(Copier<K> keyCopier) {    return withCopier(new DefaultCopierConfiguration<>(requireNonNull(keyCopier, "Null key copier"), DefaultCopierConfiguration.Type.KEY));  }
public CacheConfigurationBuilder<K, V> withKeyCopier(Class<? extends Copier<K>> keyCopierClass) {    return withCopier(new DefaultCopierConfiguration<>(requireNonNull(keyCopierClass, "Null key copier class"), DefaultCopierConfiguration.Type.KEY));  }

convert html to pdf
public byte[] convertXhtmlToPdf(CmsObject cms, byte[] xhtmlData, String uri) throws Exception {        Document doc = readDocument(xhtmlData);        ITextRenderer renderer = new ITextRenderer();        CmsPdfUserAgent userAgent = new CmsPdfUserAgent(cms);        userAgent.setSharedContext(renderer.getSharedContext());        renderer.getSharedContext().setUserAgentCallback(userAgent);        renderer.setDocument(doc, uri);        renderer.layout();        ByteArrayOutputStream out = new ByteArrayOutputStream();        renderer.createPDF(out);        return out.toByteArray();    }
public String convertHTML(        String filename,        String inString,        String startPattern,        String endPattern,        Hashtable properties) {        m_tempString = new StringBuffer();        m_write = true;        m_filename = filename.replace('\\', '/');        Reader in = new StringReader(inString);        Writer out = new StringWriter();        convertHTML(in, out, startPattern, endPattern, properties);        return out.toString();    }
public void convertHTML(Reader input, Writer output, String startPattern, String endPattern, Hashtable properties) {        /* local variables */        StringBuffer htmlString = new StringBuffer();        Node node;        String outString = "";        try {            /* write InputStream input in StringBuffer htmlString */            int c;            while ((c = input.read()) != -1) {                htmlString.append((char)c);            }        } catch (IOException e) {            if (CmsLog.INIT.isWarnEnabled()) {                CmsLog.INIT.warn(                    Messages.get().getBundle().key(                        Messages.LOG_HTMLIMPORT_CONVERSION_ERROR_0,                        e.getLocalizedMessage()));            }            return;        }        outString = htmlString.toString();        // extract from html if even both patterns are defined        if (CmsStringUtil.isNotEmpty(startPattern) && CmsStringUtil.isNotEmpty(endPattern)) {            String extractMain = extractHtml(outString, startPattern, endPattern);            if (extractMain.length() != outString.length()) {                String extractHead = extractHtml(outString, "<html>", CmsStringUtil.BODY_START_REGEX);                //String extractHead = extractHtml(extractMain, "<html>", CmsStringUtil.C_BODY_START_REGEX);                StringBuffer buffer = new StringBuffer(extractHead.length() + extractMain.length() + 255);                buffer.append("<html>");                buffer.append(extractHead);                buffer.append("<body>");                buffer.append(extractMain);                buffer.append("</body></html>");                outString = buffer.toString();            }        }        /* convert htmlString in InputStream for parseDOM */        InputStream in;        try {            in = new ByteArrayInputStream(outString.getBytes(CmsEncoder.ENCODING_UTF_8));        } catch (UnsupportedEncodingException e) {            // this should never happen since UTF-8 is always supported            in = new ByteArrayInputStream(outString.getBytes());        }        m_tidy.setInputEncoding(CmsEncoder.ENCODING_UTF_8);        m_tidy.setOutputEncoding(CmsEncoder.ENCODING_UTF_8);        // hold tidy error information into a new PrintWriter Object        PrintWriter errorLog = new PrintWriter(new ByteArrayOutputStream(), true);        m_tidy.setErrout(errorLog);        node = m_tidy.parseDOM(in, null);        /* check if html code has errors */        if (m_tidy.getParseErrors() != 0) {            if (CmsLog.INIT.isWarnEnabled()) {                CmsLog.INIT.warn(Messages.get().getBundle().key(Messages.LOG_HTMLIMPORT_CONVERSION_ERROR_0));            }        }        /* second step: create transformed output with printDocument from DOM */        printDocument(node, properties);        try {            String content = m_tempString.toString();            content = CmsStringUtil.substitute(content, "<br></br>", "<br>");            content = CmsStringUtil.substitutePerl(content, "</a>(\\w+)", "</a> $1", "g");            output.write(content);            output.close();        } catch (IOException e) {            if (CmsLog.INIT.isWarnEnabled()) {                CmsLog.INIT.warn(                    Messages.get().getBundle().key(                        Messages.LOG_HTMLIMPORT_CONVERSION_ERROR_1,                        e.getLocalizedMessage()));            }            return;        }    }
private void convertHTMLCode(ArrayList<ArrayList<TextPiece>> wordsByPage) {DocInfo docInfo = new DocInfo();String[] html2Char = docInfo.getHtml2CharMapping(); // Only define this    // mapping string    // when we detect    // the files in HTML    // codesint pageNum = 0;for (ArrayList<TextPiece> wordsOfAPage : wordsByPage) {    pageNum++;    for (int i = 0; i < wordsOfAPage.size(); i++) {TextPiece currentWord = wordsOfAPage.get(i);String realText = "";String textinHTMLCode = currentWord.getText();    }}    }
static String convertFromHtml(final String textToConvert) {        //LinkedHashmap since the order matters        final Map<String, String> regexps = new LinkedHashMap<>();        regexps.put("< *a *href=[\'\"](.*?)[\'\"] *>(.*?)</ *a *>","$2 ($1)");        regexps.put("< *a *href=[\'\"](.*?)[\'\"] *>(.*?)< *a */>","$2 ($1)");        regexps.put("</ *(br|p|table|h[1-4]|pre|hr|li|ul) *>","\n");        regexps.put("< *(br|p|table|h[1-4]|pre|hr|li|ul) */>","\n");        regexps.put("< *(p|table|h[1-4]|ul|pre) *>","\n");        regexps.put("<li>", " - ");        regexps.put("</th>", "\t");        regexps.put("<\\w*?>", "");        return regexps.entrySet().stream().sequential()                .reduce(textToConvert, (string, entrySet) -> string.replaceAll(entrySet.getKey(), entrySet.getValue()), (a, b) -> b);    }
private String convertOutputToHtml(String content) {        if (content.length() == 0) {            return "";        }        StringBuilder buffer = new StringBuilder();        for (String line : content.split("\n")) {            buffer.append(CmsEncoder.escapeXml(line) + "<br>");        }        return buffer.toString();    }
public String html() {        if (html != null) {            return html;        }        if (content == null) {            return null;        }        if (charset == null) {            charset = CharsetDetector.guessEncoding(content());        }        try {            html = new String(content, charset);        } catch (UnsupportedEncodingException e) {            LOG.info("Exception when decoding "+ key(),e);            return null;        }        return html;    }
public String html(String htmlSource) {        String cleanSource = htmlCleaner.cleanupPreFormatted(htmlSource);        return "<div>" + StringEscapeUtils.unescapeHtml4(cleanSource) + "</div>";    }
protected DCTree html() {        int p = bp;        nextChar();        if (isIdentifierStart(ch)) {            Name name = readIdentifier();            List<DCTree> attrs = htmlAttrs();            if (attrs != null) {                boolean selfClosing = false;                if (ch == '/') {                    nextChar();                    selfClosing = true;                }                if (ch == '>') {                    nextChar();                    DCTree dctree = m.at(p).newStartElementTree(name, attrs, selfClosing).setEndPos(bp);                    return dctree;                }            }        } else if (ch == '/') {            nextChar();            if (isIdentifierStart(ch)) {                Name name = readIdentifier();                skipWhitespace();                if (ch == '>') {                    nextChar();                    return m.at(p).newEndElementTree(name);                }            }        } else if (ch == '!') {            nextChar();            if (ch == '-') {                nextChar();                if (ch == '-') {                    nextChar();                    while (bp < buflen) {                        int dash = 0;                        while (ch == '-') {                            dash++;                            nextChar();                        }                        // Strictly speaking, a comment should not contain "--"                        // so dash > 2 is an error, dash == 2 implies ch == '>'                        // See http://www.w3.org/TR/html-markup/syntax.html#syntax-comments                        // for more details.                        if (dash >= 2 && ch == '>') {                            nextChar();                            return m.at(p).newCommentTree(newString(p, bp));                        }                        nextChar();                    }                }            }        }        bp = p + 1;        ch = buf[bp];        return erroneous("dc.malformed.html", p);    }
protected void html() {        int p = bp;        nextChar();        if (isIdentifierStart(ch)) {            String name = readIdentifier();            checkHtmlTag(name);            htmlAttrs();            if (ch == '/') {                nextChar();            }            if (ch == '>') {                nextChar();                return;            }        } else if (ch == '/') {            nextChar();            if (isIdentifierStart(ch)) {                readIdentifier();                skipWhitespace();                if (ch == '>') {                    nextChar();                    return;                }            }        } else if (ch == '!') {            nextChar();            if (ch == '-') {                nextChar();                if (ch == '-') {                    nextChar();                    while (bp < buflen) {                        int dash = 0;                        while (ch == '-') {                            dash++;                            nextChar();                        }                        // Strictly speaking, a comment should not contain "--"                        // so dash > 2 is an error, dash == 2 implies ch == '>'                        // See http://www.w3.org/TR/html-markup/syntax.html#syntax-comments                        // for more details.                        if (dash >= 2 && ch == '>') {                            nextChar();                            return;                        }                        nextChar();                    }                }            }        }        bp = p + 1;        ch = buf[bp];    }

json to xml conversion
public String jsonToXml(String json){        String xml = "";        // 處理直接以陣列開頭的JSON，並指定給予 row 的 tag        if ( "[".equals( json.substring(0,1) ) ){            xml = XML.toString(new JSONArray(json), "row");        }else{            xml = XML.toString(new JSONObject(json));        }        return xml;    }
public static String json(Object obj, boolean writeClass,                              Converter<Object, Map<String, Object>> mc) throws IOException {        if (obj == null)            return NULL;        StringWriter sw = new StringWriter();        try {            json(obj, sw, writeClass, mc);            return sw.getBuffer().toString();        } finally {            sw.close();        }    }
public static void json(Object obj, final String[] properties,                            Writer writer, boolean writeClass,                            Converter<Object, Map<String, Object>> mc) throws IOException {        if (obj == null)            writer.write(NULL);        else            json(obj, properties, new JSONWriter(writer), writeClass, mc);    }
public final Result json(Object obj) {        final Result response = ok().contentType(MediaType.APPLICATION_JSON).renderable(obj);        holder.setControllerResult(response);        return response;    }
public static SpinJsonNode JSON(Object input) {    return SpinFactory.INSTANCE.createSpin(input, DataFormats.json());  }
public JSONResource json(JSONPathQuery path) throws Exception {Object jsonValue = path.eval(this);return json(jsonValue.toString());}
public JSONResource json(XPathQuery path) throws Exception {String uri = path.eval(this, String.class);return json(uri);}
public JSONResource json(URI anUri, AbstractContent requestContent) throws IOException {return doPOSTOrPUT(anUri, requestContent, createJSONResource());}
private byte[] json(Object object) {        try {            return mapper.writeValueAsBytes(object);        } catch (JsonProcessingException e) {            throw new ZendeskException(e.getMessage(), e);        }    }
public static JSONResponse json(Object value) {JSONResponse response = new JSONResponse();response.entity(value);return response;}

how to randomly pick a number
public boolean number(TextProvider textProvider)            {        clearLastToken(textProvider);        clearLeadingSpaces(textProvider);        mark(textProvider);        if (m_debug)        debug("testing",textProvider);        StringBuilder sb = new StringBuilder();        boolean hasDecimal = false;        while (true)        {            char c = getNextChar(textProvider);            if (c == 'L')            {                remark(textProvider);                sb.append(c);                break;            }            if (c == 'D')            {                remark(textProvider);                sb.append(c);                break;            }            if (c == 'F')            {                remark(textProvider);                sb.append(c);                break;            }            if (!Character.isDigit(c) && c != '.')            {                break;            }            if (c == '.')            {                if (hasDecimal)                {                    break;                }                else                {                    hasDecimal = true;                }            }            remark(textProvider);            sb.append(c);        }        reset(textProvider); // removes last char        String s = sb.toString().trim();        if (s.length() == 0) return false;        textProvider.setLastToken(s);        debug(textProvider);        return true;    }
public ScriptBuilder number(int index, long num) {        if (num == -1) {            return op(index, OP_1NEGATE);        } else if (num >= 0 && num <= 16) {            return smallNum(index, (int) num);        } else {            return bigNum(index, num);        }    }
public int number(CharSequence seq) {        StateInfo info = getStateInfo(seq);        return info.isInFinalState() ? info.getHash() : -1;    }
public static Expression number(long value) {    Preconditions.checkArgument(        IntegerNode.isInRange(value), "Number is outside JS safe integer range: %s", value);    return Leaf.create(Long.toString(value), /* isCheap= */ true);  }
protected Expression number(int opPos) throws TransformerException  {    return compileUnary(new org.apache.xpath.operations.Number(), opPos);  }
public long number(ImapRequestLineReader request) throws ProtocolException {        String digits = consumeWord(request, new DigitCharValidator());        return Long.parseLong(digits);    }
Rule Number() {        return FirstOf(                Sequence(Optional('-'), Digit0(), '.', Digit1()),                Sequence(Optional('-'), Digit1())        );    }
public final void mNUMBER() throws RecognitionException {        try {            int _type = NUMBER;            int _channel = DEFAULT_TOKEN_CHANNEL;            // EventFilter.g:198:5: ( ( '+' | '-' )? ( '0' .. '9' )+ ( '.' ( '0' .. '9' )* ( EXPONENT )? )? | ( '+' | '-' )? '.' ( '0' .. '9' )+ ( EXPONENT )? | ( '+' | '-' )? ( '0' .. '9' )+ EXPONENT )            int alt11=3;            alt11 = dfa11.predict(input);            switch (alt11) {                case 1 :                    // EventFilter.g:198:9: ( '+' | '-' )? ( '0' .. '9' )+ ( '.' ( '0' .. '9' )* ( EXPONENT )? )?                    {                    // EventFilter.g:198:9: ( '+' | '-' )?                    int alt1=2;                    int LA1_0 = input.LA(1);                    if ( (LA1_0=='+'||LA1_0=='-') ) {                        alt1=1;                    }                    switch (alt1) {                        case 1 :                            // EventFilter.g:                            {                            if ( input.LA(1)=='+'||input.LA(1)=='-' ) {                                input.consume();                            }                            else {                                MismatchedSetException mse = new MismatchedSetException(null,input);                                recover(mse);                                throw mse;                            }                            }                            break;                    }                    // EventFilter.g:198:20: ( '0' .. '9' )+                    int cnt2=0;                    loop2:                    do {                        int alt2=2;                        int LA2_0 = input.LA(1);                        if ( ((LA2_0 >= '0' && LA2_0 <= '9')) ) {                            alt2=1;                        }                        switch (alt2) {                    case 1 :                        // EventFilter.g:                        {                        if ( (input.LA(1) >= '0' && input.LA(1) <= '9') ) {                            input.consume();                        }                        else {                            MismatchedSetException mse = new MismatchedSetException(null,input);                            recover(mse);                            throw mse;                        }                        }                        break;                    default :                        if ( cnt2 >= 1 ) break loop2;                                EarlyExitException eee =                                    new EarlyExitException(2, input);                                throw eee;                        }                        cnt2++;                    } while (true);                    // EventFilter.g:198:32: ( '.' ( '0' .. '9' )* ( EXPONENT )? )?                    int alt5=2;                    int LA5_0 = input.LA(1);                    if ( (LA5_0=='.') ) {                        alt5=1;                    }                    switch (alt5) {                        case 1 :                            // EventFilter.g:198:33: '.' ( '0' .. '9' )* ( EXPONENT )?                            {                            match('.');                             // EventFilter.g:198:37: ( '0' .. '9' )*                            loop3:                            do {                                int alt3=2;                                int LA3_0 = input.LA(1);                                if ( ((LA3_0 >= '0' && LA3_0 <= '9')) ) {                                    alt3=1;                                }                                switch (alt3) {                            case 1 :                                // EventFilter.g:                                {                                if ( (input.LA(1) >= '0' && input.LA(1) <= '9') ) {                                    input.consume();                                }                                else {                                    MismatchedSetException mse = new MismatchedSetException(null,input);                                    recover(mse);                                    throw mse;                                }                                }                                break;                            default :                                break loop3;                                }                            } while (true);                            // EventFilter.g:198:49: ( EXPONENT )?                            int alt4=2;                            int LA4_0 = input.LA(1);                            if ( (LA4_0=='E'||LA4_0=='e') ) {                                alt4=1;                            }                            switch (alt4) {                                case 1 :                                    // EventFilter.g:198:49: EXPONENT                                    {                                    mEXPONENT();                                     }                                    break;                            }                            }                            break;                    }                    }                    break;                case 2 :                    // EventFilter.g:199:9: ( '+' | '-' )? '.' ( '0' .. '9' )+ ( EXPONENT )?                    {                    // EventFilter.g:199:9: ( '+' | '-' )?                    int alt6=2;                    int LA6_0 = input.LA(1);                    if ( (LA6_0=='+'||LA6_0=='-') ) {                        alt6=1;                    }                    switch (alt6) {                        case 1 :                            // EventFilter.g:                            {                            if ( input.LA(1)=='+'||input.LA(1)=='-' ) {                                input.consume();                            }                            else {                                MismatchedSetException mse = new MismatchedSetException(null,input);                                recover(mse);                                throw mse;                            }                            }                            break;                    }                    match('.');                     // EventFilter.g:199:24: ( '0' .. '9' )+                    int cnt7=0;                    loop7:                    do {                        int alt7=2;                        int LA7_0 = input.LA(1);                        if ( ((LA7_0 >= '0' && LA7_0 <= '9')) ) {                            alt7=1;                        }                        switch (alt7) {                    case 1 :                        // EventFilter.g:                        {                        if ( (input.LA(1) >= '0' && input.LA(1) <= '9') ) {                            input.consume();                        }                        else {                            MismatchedSetException mse = new MismatchedSetException(null,input);                            recover(mse);                            throw mse;                        }                        }                        break;                    default :                        if ( cnt7 >= 1 ) break loop7;                                EarlyExitException eee =                                    new EarlyExitException(7, input);                                throw eee;                        }                        cnt7++;                    } while (true);                    // EventFilter.g:199:36: ( EXPONENT )?                    int alt8=2;                    int LA8_0 = input.LA(1);                    if ( (LA8_0=='E'||LA8_0=='e') ) {                        alt8=1;                    }                    switch (alt8) {                        case 1 :                            // EventFilter.g:199:36: EXPONENT                            {                            mEXPONENT();                             }                            break;                    }                    }                    break;                case 3 :                    // EventFilter.g:200:9: ( '+' | '-' )? ( '0' .. '9' )+ EXPONENT                    {                    // EventFilter.g:200:9: ( '+' | '-' )?                    int alt9=2;                    int LA9_0 = input.LA(1);                    if ( (LA9_0=='+'||LA9_0=='-') ) {                        alt9=1;                    }                    switch (alt9) {                        case 1 :                            // EventFilter.g:                            {                            if ( input.LA(1)=='+'||input.LA(1)=='-' ) {                                input.consume();                            }                            else {                                MismatchedSetException mse = new MismatchedSetException(null,input);                                recover(mse);                                throw mse;                            }                            }                            break;                    }                    // EventFilter.g:200:20: ( '0' .. '9' )+                    int cnt10=0;                    loop10:                    do {                        int alt10=2;                        int LA10_0 = input.LA(1);                        if ( ((LA10_0 >= '0' && LA10_0 <= '9')) ) {                            alt10=1;                        }                        switch (alt10) {                    case 1 :                        // EventFilter.g:                        {                        if ( (input.LA(1) >= '0' && input.LA(1) <= '9') ) {                            input.consume();                        }                        else {                            MismatchedSetException mse = new MismatchedSetException(null,input);                            recover(mse);                            throw mse;                        }                        }                        break;                    default :                        if ( cnt10 >= 1 ) break loop10;                                EarlyExitException eee =                                    new EarlyExitException(10, input);                                throw eee;                        }                        cnt10++;                    } while (true);                    mEXPONENT();                     }                    break;            }            state.type = _type;            state.channel = _channel;        }        finally {        // do for sure before leaving        }    }
private static Object toNumber( String value)    {    Object number;    try      {      number = toExternalNumber( new BigDecimal( value));      }    catch( Exception e)      {      number = null;      }    return number;    }
public long nzNumber(ImapRequestLineReader request) throws ProtocolException {        long number = number(request);        if (number == 0) {            throw new ProtocolException("Zero value not permitted.");        }        return number;    }

normal distribution
public static double normalDistribution(Double x, AssociativeArray params) {        double mean= params.getDouble("mean");        double variance= params.getDouble("variance");        //standardize the x value        double z=(x-mean)/Math.sqrt(variance);        return ContinuousDistributions.gaussCdf(z);    }
public static double logNormalDistribution(double sigma, double x) {        return Math.log(1.0 / (sqrt(2.0 * PI) * sigma)) + (-0.5 * pow(x / sigma, 2));    }
public void setNormalDistribution(NormalDistributionType newNormalDistribution) {((FeatureMap.Internal)getMixed()).set(BpsimPackage.Literals.DOCUMENT_ROOT__NORMAL_DISTRIBUTION, newNormalDistribution);}
public void setLogNormalDistribution(LogNormalDistributionType newLogNormalDistribution) {((FeatureMap.Internal)getMixed()).set(BpsimPackage.Literals.DOCUMENT_ROOT__LOG_NORMAL_DISTRIBUTION, newLogNormalDistribution);}
public NotificationChain basicSetNormalDistribution(NormalDistributionType newNormalDistribution, NotificationChain msgs) {return ((FeatureMap.Internal)getMixed()).basicAdd(BpsimPackage.Literals.DOCUMENT_ROOT__NORMAL_DISTRIBUTION, newNormalDistribution, msgs);}
public static AssociativeArray normalDistributionGetParams(FlatDataCollection flatDataCollection) {        AssociativeArray params = new AssociativeArray();        params.put("mean", Descriptives.mean(flatDataCollection));        params.put("variance", Descriptives.variance(flatDataCollection, true));        return params;    }
public NotificationChain basicSetLogNormalDistribution(LogNormalDistributionType newLogNormalDistribution, NotificationChain msgs) {return ((FeatureMap.Internal)getMixed()).basicAdd(BpsimPackage.Literals.DOCUMENT_ROOT__LOG_NORMAL_DISTRIBUTION, newLogNormalDistribution, msgs);}
public void setTruncatedNormalDistribution(TruncatedNormalDistributionType newTruncatedNormalDistribution) {((FeatureMap.Internal)getMixed()).set(BpsimPackage.Literals.DOCUMENT_ROOT__TRUNCATED_NORMAL_DISTRIBUTION, newTruncatedNormalDistribution);}
public NotificationChain basicSetTruncatedNormalDistribution(TruncatedNormalDistributionType newTruncatedNormalDistribution, NotificationChain msgs) {return ((FeatureMap.Internal)getMixed()).basicAdd(BpsimPackage.Literals.DOCUMENT_ROOT__TRUNCATED_NORMAL_DISTRIBUTION, newTruncatedNormalDistribution, msgs);}
public static double inverseCumulativeNormalDistribution_Wichura(double p) {double zero = 0.e+00, one = 1.e+00, half = 0.5e+00;double split1 = 0.425e+00, split2 = 5.e+00;double const1 = 0.180625e+00, const2 = 1.6e+00;//  coefficients for p close to 0.5double a0 = 3.3871328727963666080e+00;double a1 = 1.3314166789178437745e+02;double a2 = 1.9715909503065514427e+03;double a3 = 1.3731693765509461125e+04;double a4 = 4.5921953931549871457e+04;double a5 = 6.7265770927008700853e+04;double a6 = 3.3430575583588128105e+04;double a7 = 2.5090809287301226727e+03;double b1 = 4.2313330701600911252e+01;double b2 = 6.8718700749205790830e+02;double b3 = 5.3941960214247511077e+03;double b4 = 2.1213794301586595867e+04;double b5 = 3.9307895800092710610e+04;double b6 = 2.8729085735721942674e+04;double b7 = 5.2264952788528545610e+03;//  hash sum ab 55.8831928806149014439//  coefficients for p not close to 0, 0.5 or 1.double c0 = 1.42343711074968357734e+00;double c1 = 4.63033784615654529590e+00;double c2 = 5.76949722146069140550e+00;double c3 = 3.64784832476320460504e+00;double c4 = 1.27045825245236838258e+00;double c5 = 2.41780725177450611770e-01;double c6 = 2.27238449892691845833e-02;double c7 = 7.74545014278341407640e-04;double d1 = 2.05319162663775882187e+00;double d2 = 1.67638483018380384940e+00;double d3 = 6.89767334985100004550e-01;double d4 = 1.48103976427480074590e-01;double d5 = 1.51986665636164571966e-02;double d6 = 5.47593808499534494600e-04;double d7 = 1.05075007164441684324e-09;//  hash sum cd 49.33206503301610289036//  coefficients for p near 0 or 1.double e0 = 6.65790464350110377720e+00;double e1 = 5.46378491116411436990e+00;double e2 = 1.78482653991729133580e+00;double e3 = 2.96560571828504891230e-01;double e4 = 2.65321895265761230930e-02;double e5 = 1.24266094738807843860e-03;double e6 = 2.71155556874348757815e-05;double e7 = 2.01033439929228813265e-07;double f1 = 5.99832206555887937690e-01;double f2 = 1.36929880922735805310e-01;double f3 = 1.48753612908506148525e-02;double f4 = 7.86869131145613259100e-04;double f5 = 1.84631831751005468180e-05;double f6 = 1.42151175831644588870e-07;double f7 = 2.04426310338993978564e-15;//  hash sum ef 47.52583 31754 92896 71629double q = p - half;double r, ppnd16;if (Math.abs(q) <= split1) {r = const1 - q * q;return q* (((((((a7 * r + a6) * r + a5) * r + a4) * r + a3) * r + a2) * r + a1) * r + a0)/ (((((((b7 * r + b6) * r + b5) * r + b4) * r + b3) * r + b2) * r + b1) * r + one);} else {if (q < zero) {r = p;} else {r = one - p;}if (r <= zero) {return zero;}r = Math.sqrt(-Math.log(r));if (r <= split2) {r -= const2;ppnd16 =(((((((c7 * r + c6) * r + c5) * r + c4) * r + c3) * r + c2) * r + c1) * r + c0)/ (((((((d7 * r + d6) * r + d5) * r + d4) * r + d3) * r + d2) * r + d1) * r + one);} else {r -= split2;ppnd16 =(((((((e7 * r + e6) * r + e5) * r + e4) * r + e3) * r + e2) * r + e1) * r + e0)/ (((((((f7 * r + f6) * r + f5) * r + f4) * r + f3) * r + f2) * r + f1) * r + one);}if (q < zero) {ppnd16 = -ppnd16;}return ppnd16;}}

nelder mead optimize
public List<com.ibm.wsspi.security.wim.model.AddressType> getHomeAddress() {        if (homeAddress == null) {            homeAddress = new ArrayList<com.ibm.wsspi.security.wim.model.AddressType>();        }        return this.homeAddress;    }
@XmlElementDecl(namespace = "http://www.ibm.com/websphere/wim", name = "homeAddress")    public JAXBElement<AddressType> createHomeAddress(AddressType value) {        return new JAXBElement<AddressType>(_HomeAddress_QNAME, AddressType.class, null, value);    }
public static Buffer consumeAddressSpec(final Buffer buffer) throws IndexOutOfBoundsException, IOException,            SipParseException {        buffer.markReaderIndex();        int count = 0;        int state = 0; // zero is to look for colon, everything else is to find        // the end        boolean done = false;        while (buffer.hasReadableBytes() && !done) {            ++count;            final byte b = buffer.readByte();            // emergency breaks...            if (state == 0 && count > 99) {                throw new SipParseException(buffer.getReaderIndex(), "No scheme found after 100 bytes, giving up");            } else if (count > MAX_LOOK_AHEAD) {                throw new SipParseException(buffer.getReaderIndex(),                        "Have not been able to find the entire addr-spec after " + count + " bytes, giving up");            } else if (state == 0 && b == COLON) {                state = 1;            } else if (state == 1 && (b == RAQUOT || b == SP || b == HTAB || b == CR || b == LF)) {                done = true;                --count;            }        }        buffer.resetReaderIndex();        // didn't find the scheme portion        if (state == 0) {            throw new SipParseException(buffer.getReaderIndex(), "No scheme found");        }        if (count > 0) {            return buffer.readBytes(count);        }        return null;    }

hash set for counting distinct elements
public Integer setElement(String title, String image_url, String subtitle)    {        HashMap<String, Object> element = new HashMap<String, Object>();        element.put("title", title);        element.put("image_url", image_url);        element.put("subtitle", subtitle);        this.elements.add(element);        return this.elements.size() - 1;    }
public void setElement(String title, String subtitle, String quantity, String price, String currency, String image_url)    {        HashMap<String, String> element = new HashMap<String, String>();        element.put("title", title);        element.put("subtitle", subtitle);        element.put("quantity", quantity);        element.put("price", price);        element.put("currency", currency);        element.put("image_url", image_url);        this.elements.add(element);    }
public final void setElement(final WebElement element) {if (element == null) {throw new IllegalArgumentException(String.format(ErrorMessages.ERROR_TEMPLATE_VARIABLE_NULL,"element"));}this.element = element;validateElementTag();validateAttributes();}
public void setElement(int treap_node_index, int newElement) {if (m_comparator != null)m_comparator.onSetImpl_(this, treap_node_index);setElement_(treap_node_index, newElement);}
void setElement(Object aElement, int column) {        if (reserved[column]) throw new IllegalArgumentException("setElement - position already taken");                cells[column] = aElement;        if (aElement != null) {            reserved[column] = true;        }    }
public void setElement(RuleElement newElement)  {    if (newElement != element)    {      NotificationChain msgs = null;      if (element != null)        msgs = ((InternalEObject)element).eInverseRemove(this, EOPPOSITE_FEATURE_BASE - SimpleAntlrPackage.ELEMENT_WITH_CARDINALITY__ELEMENT, null, msgs);      if (newElement != null)        msgs = ((InternalEObject)newElement).eInverseAdd(this, EOPPOSITE_FEATURE_BASE - SimpleAntlrPackage.ELEMENT_WITH_CARDINALITY__ELEMENT, null, msgs);      msgs = basicSetElement(newElement, msgs);      if (msgs != null) msgs.dispatch();    }    else if (eNotificationRequired())      eNotify(new ENotificationImpl(this, Notification.SET, SimpleAntlrPackage.ELEMENT_WITH_CARDINALITY__ELEMENT, newElement, newElement));  }
public void setElement(JvmOperation newElement){JvmOperation oldElement = element;element = newElement;if (eNotificationRequired())eNotify(new ENotificationImpl(this, Notification.SET, XAnnotationsPackage.XANNOTATION_ELEMENT_VALUE_PAIR__ELEMENT, oldElement, element));}
public D4Cursor    setElements(D4Cursor[] instances)    {        if(!(getScheme() == Scheme.SEQARRAY                || getScheme() == Scheme.STRUCTARRAY))            throw new IllegalStateException("Adding element to !(structure|sequence array) object");        DapVariable var = (DapVariable) getTemplate();        this.elements = instances;        return this;    }
public synchronized void setElementAt(E obj, int index) {        if (index >= elementCount) {            throw new ArrayIndexOutOfBoundsException(index + " >= " +                                                     elementCount);        }        elementData[index] = obj;    }
public static URI setElementID(final URI relativePath, final String id) {        String topic = getTopicID(relativePath);        if (topic != null) {            return setFragment(relativePath, topic + (id != null ? SLASH + id : ""));        } else if (id == null) {            return stripFragment(relativePath);        } else {            throw new IllegalArgumentException(relativePath.toString());        }    }

how to get database table name
public static String getTableName(Class<? extends Entity> cls) {String name = TABLE_NAMES.get(cls);if (name == null) {TableAnn ann = getTableAnn(cls);if (ann != null) {name = ann.name;}if (isEmpty(name)) {name = cls.getSimpleName();}TABLE_NAMES.put(cls, name);}return name;}
public static String getTableName(String className, String prefix) {        boolean hasPrefix = prefix != null && prefix.trim().length() > 0;        return hasPrefix ? English.plural(prefix + "_" + AnimaUtils.toUnderline(className), 2) : English.plural(AnimaUtils.toUnderline(className), 2);    }
protected String getTableName() throws SQLException   {      try      {         String dialect = getDialect();         String quote = "\"";         if (dialect.startsWith(DBConstants.DB_DIALECT_MYSQL))            quote = "`";         return quote + lockManagerEntry.getParameterValue(ISPNCacheableLockManagerImpl.INFINISPAN_JDBC_TABLE_NAME)            + "_" + "L" + workspaceEntry.getUniqueName().replace("_", "").replace("-", "_") + quote;      }      catch (RepositoryConfigurationException e)      {         throw new SQLException(e);      }   }
@Nullable    public static String getTableName(Path rootPath, Path path) {        path = qualified(rootPath, path);        if (rootPath.equals(path)) {            // Path is root, no table            return null;        }        Path tablePath;        Path parent = path.getParent();        if (Objects.equals(parent, rootPath)) {            // The path itself represents a table (e.g.; emodb://ci.us/mytable)            tablePath = path;        } else if (parent != null && Objects.equals(parent.getParent(), rootPath)) {            // The path is a split (e.g.; emodb://ci.us/mytable/split-id)            tablePath = parent;        } else {            throw new IllegalArgumentException(                    format("Path does not represent a table, split, or root (path=%s, root=%s)", path, rootPath));        }        return decode(tablePath.getName());    }
public String getTableName()    {        getEntityType();        return this.entityType != null && !StringUtils.isBlank(((AbstractManagedType) this.entityType).getTableName()) ? ((AbstractManagedType) this.entityType)                .getTableName() : tableName;    }
public String getTableName(final int column) throws SQLException {    if (returnTableAlias) {      return getColumnInformation(column).getTable();    } else {      return getColumnInformation(column).getOriginalTable();    }  }
private static <T> String getTableName(Class<T> clazz) {Table tableAnno = clazz.getAnnotation(Table.class);if(tableAnno != null){if(tableAnno.catalog() != null){return tableAnno.catalog() + "." + tableAnno.name();}return tableAnno.name();}//if Table annotation is nullString className = clazz.getName();return IdUtils.toUnderscore(className.substring(className.lastIndexOf(".")+1));}
String getTableName() {        if (opType == OpTypes.MULTICOLUMN) {            return tableName;        }        if (opType == OpTypes.COLUMN) {            if (rangeVariable == null) {                return tableName;            }            return rangeVariable.getTable().getName().name;        }        return "";    }
public String getTableName(int column) throws SQLException {        checkColumn(column);        String name = resultMetaData.columns[--column].getTableNameString();        return name == null ? ""                            : name;    }
protected Optional<String> getTableName(Path path) {    if (!this.props.contains(HIVE_TABLE_NAME) && !this.props.contains(HIVE_TABLE_REGEX)) {      return Optional.<String> absent();    }    return Optional.<String> of(        this.tableNamePrefix + getDatabaseOrTableName(path, HIVE_TABLE_NAME, HIVE_TABLE_REGEX, this.tableNamePattern)            + this.tableNameSuffix);  }

deserialize json
public static INDArray deserializeRawJson(String serializedRawArray) {        //String cleanedRawArray = serializedRawArray.replaceAll("(?<=[\\d])(,)(?=[\\d])", "");        String cleanedRawArray = serializedRawArray;        JsonArray jsonArray = JSON_PARSER.parse(cleanedRawArray).getAsJsonArray();        List<Integer> dimensions = new ArrayList<>();        dimensions.add(jsonArray.size());        getSizeMultiDimensionalArray(jsonArray, dimensions);        return buildArray(dimensions, cleanedRawArray);    }
public CRestBuilder deserializeJsonWith(Class<? extends Deserializer> deserializer) {        return deserializeJsonWith(deserializer, Collections.<String, Object>emptyMap());    }
public CRestBuilder deserializeJsonWith(Class<? extends Deserializer> deserializer, Map<String, Object> config) {        this.jsonDeserializer = deserializer;        this.jsonDeserializerConfig.clear();        this.jsonDeserializerConfig.putAll(config);        return this;    }
public static String json(Object obj, boolean writeClass,                              Converter<Object, Map<String, Object>> mc) throws IOException {        if (obj == null)            return NULL;        StringWriter sw = new StringWriter();        try {            json(obj, sw, writeClass, mc);            return sw.getBuffer().toString();        } finally {            sw.close();        }    }
public static void json(Object obj, final String[] properties,                            Writer writer, boolean writeClass,                            Converter<Object, Map<String, Object>> mc) throws IOException {        if (obj == null)            writer.write(NULL);        else            json(obj, properties, new JSONWriter(writer), writeClass, mc);    }
public final Result json(Object obj) {        final Result response = ok().contentType(MediaType.APPLICATION_JSON).renderable(obj);        holder.setControllerResult(response);        return response;    }
public static SpinJsonNode JSON(Object input) {    return SpinFactory.INSTANCE.createSpin(input, DataFormats.json());  }
public JSONResource json(JSONPathQuery path) throws Exception {Object jsonValue = path.eval(this);return json(jsonValue.toString());}
public JSONResource json(XPathQuery path) throws Exception {String uri = path.eval(this, String.class);return json(uri);}
public JSONResource json(URI anUri, AbstractContent requestContent) throws IOException {return doPOSTOrPUT(anUri, requestContent, createJSONResource());}

find int in string
protected String findString(String expr, String field, String errorMsg) {    if (expr == null) {      throw fieldError(field, errorMsg, null);    } else {      return findString(expr);    }  }
public String findString(String uri) throws IOException {        String fullUri = path + uri;        URL resource = getResource(fullUri);        if (resource == null) {            throw new IOException("Could not find a resource in : " + fullUri);        }        return readContents(resource);    }
public List<String> findAllStrings(String uri) throws IOException {        String fulluri = path + uri;        List<String> strings = new ArrayList<>();        Enumeration<URL> resources = getResources(fulluri);        while (resources.hasMoreElements()) {            URL url = resources.nextElement();            String string = readContents(url);            strings.add(string);        }        return strings;    }
private Method findFromString(Class<?> cls) {        // find in declared methods        Method[] methods = cls.getDeclaredMethods();        Method matched = null;        for (Method method : methods) {            if (!method.isBridge() && !method.isSynthetic()) {                FromString fromString = method.getAnnotation(FromString.class);                if (fromString != null) {                    if (matched != null) {                        throw new IllegalStateException("Two methods are annotated with @FromString: " + cls.getName());                    }                    matched = method;                }            }        }        // check for factory        FromStringFactory factory = cls.getAnnotation(FromStringFactory.class);        if (factory != null) {            if (matched != null) {                throw new IllegalStateException("Class annotated with @FromString and @FromStringFactory: " + cls.getName());            }            Method[] factoryMethods = factory.factory().getDeclaredMethods();            for (Method method : factoryMethods) {                if (!method.isBridge() && !method.isSynthetic()) {                    // handle factory containing multiple FromString for different types                    if (cls.isAssignableFrom(method.getReturnType())) {                        FromString fromString = method.getAnnotation(FromString.class);                        if (fromString != null) {                            if (matched != null) {                                throw new IllegalStateException("Two methods are annotated with @FromString on the factory: " + factory.factory().getName());                            }                            matched = method;                        }                    }                }            }        }        return matched;    }
protected String findStringInFile(String regexp, File fileToSearch) throws Exception {        String foundString = null;        List<String> matches = findStringsInFileCommon(regexp, true, -1, fileToSearch);        if (matches != null && !matches.isEmpty()) {            foundString = matches.get(0);        }        return foundString;    }
private String findSearchStrings(final int start) {String longestMatch = null;// Loop for each stringfor (int i = 0; i < search.length; i++) {// No point checking a String that's too longif (start + search[i].length() > bufferLen) {continue;}boolean found = true;// Loop for each character in rangefor (int j = 0; j < search[i].length() && (start + j < bufferLen); j++) {int diff = buffer[start + j] - search[i].charAt(j);if (diff < 0) {// Since the strings are all sorted, we can abort if// the character is less than the corresponding character in// the current search string.return longestMatch;} else if (diff != 0) {found = false;break;}}if (found && (longestMatch == null || longestMatch.length() < search[i].length())) {longestMatch = search[i];}}return longestMatch;}
private Method findToStringMethod(Class<?> cls) {        Method matched = null;        // find in superclass hierarchy        Class<?> loopCls = cls;        while (loopCls != null && matched == null) {            Method[] methods = loopCls.getDeclaredMethods();            for (Method method : methods) {                if (!method.isBridge() && !method.isSynthetic()) {                    ToString toString = method.getAnnotation(ToString.class);                    if (toString != null) {                        if (matched != null) {                            throw new IllegalStateException("Two methods are annotated with @ToString: " + cls.getName());                        }                        matched = method;                    }                }            }            loopCls = loopCls.getSuperclass();        }        // find in immediate parent interfaces        if (matched == null) {            for (Class<?> loopIfc : eliminateEnumSubclass(cls).getInterfaces()) {                Method[] methods = loopIfc.getDeclaredMethods();                for (Method method : methods) {                    if (!method.isBridge() && !method.isSynthetic()) {                        ToString toString = method.getAnnotation(ToString.class);                        if (toString != null) {                            if (matched != null) {                                throw new IllegalStateException("Two methods are annotated with @ToString on interfaces: " + cls.getName());                            }                            matched = method;                        }                    }                }            }        }        return matched;    }
private Method findToStringMethod(Class<?> cls, String methodName) {        Method m;        try {            m = cls.getMethod(methodName);        } catch (NoSuchMethodException ex) {            throw new IllegalArgumentException(ex);        }        if (Modifier.isStatic(m.getModifiers())) {            throw new IllegalArgumentException("Method must not be static: " + methodName);        }        return m;    }
@Override    public final RootDocument findByFileAndString(            final String filename, final String string) {        final Query searchQuery = new Query(Criteria.where("string").is(string)                .and("filename").is(filename));        final RootDocument rootDocument = mongoTemplate.findOne(searchQuery,                RootDocumentMongo.class);        if (rootDocument == null) {            return null;        }        final Root root =                (Root) toObjConverter.createRoot(rootDocument, finder);        rootDocument.setGedObject(root);        return rootDocument;    }
@Override    public final HeadDocument findByFileAndString(            final String filename, final String string) {        final Query searchQuery = new Query(Criteria.where("string").is(string)                .and("filename").is(filename));        final HeadDocument headDocument =                mongoTemplate.findOne(searchQuery, HeadDocumentMongo.class);        if (headDocument == null) {            return null;        }        final Head head =                (Head) toObjConverter.createGedObject(null, headDocument);        headDocument.setGedObject(head);        return headDocument;    }

get current process id
public Long getProcessId(String procname) throws Exception {        Process proc = ProcessCache.getProcess(procname, 0);        if (proc == null)            throw new DataAccessException(0, "Cannot find process with name "                    + procname + ", version 0");        return proc.getId();    }
public static int getProcessId() {    RuntimeMXBean runtimeMxBean = ManagementFactory.getRuntimeMXBean();    String runtimeMxBeanName = runtimeMxBean.getName();    Throwable cause = null;    if (hasText(runtimeMxBeanName)) {      int atSignIndex = runtimeMxBeanName.indexOf('@');      if (atSignIndex > 0) {        try {          return Integer.parseInt(runtimeMxBeanName.substring(0, atSignIndex));        }        catch (NumberFormatException e) {          cause = e;        }      }    }    throw new PidUnknownException(String.format("Process ID (PID) unknown [%s]", runtimeMxBeanName), cause);  }
public static String getProcessPid( Session session, String userName, String grep1, String grep2 )            throws JSchException, IOException {        String command = "ps aux | grep \"" + grep1 + "\" | grep -v grep";        String remoteResponseStr = launchACommand(session, command);        if (remoteResponseStr.length() == 0) {            return null;        }        List<String> pidsList = new ArrayList<>();        String[] linesSplit = remoteResponseStr.split("\n");        for( String line : linesSplit ) {            if (!line.contains(grep2)) {                continue;            }            String[] psSplit = line.split("\\s+");            if (psSplit.length < 3) {                throw new JSchException("Could not retrieve process data. Result was: " + line);            }            String user = psSplit[0];            if (userName != null && !user.equals(userName)) {                continue;            }            String pid = psSplit[1];            try {                Integer.parseInt(pid);            } catch (Exception e) {                throw new JSchException("The pid is invalid: " + pid);            }            pidsList.add(pid);        }        if (pidsList.size() > 1) {            throw new JSchException("More than one process was identified with the given filters. Check your filters.");        } else if (pidsList.size() == 0) {            return null;        }        return pidsList.get(0);    }
public String getProcessInstanceId() {    Execution execution = associationManager.getExecution();    return execution != null ? execution.getProcessInstanceId() : null;  }
@VisibleForTesting  static ProcessIdentifier getProcessIdentifier(String jvmName, Timestamp censusTimestamp) {    String hostname;    int pid;    // jvmName should be something like '<pid>@<hostname>', at least in Oracle and OpenJdk JVMs    int delimiterIndex = jvmName.indexOf('@');    if (delimiterIndex < 1) {      // Not the expected format, generate a random number.      try {        hostname = InetAddress.getLocalHost().getHostName();      } catch (UnknownHostException e) {        hostname = "localhost";      }      // Generate a random number as the PID.      pid = new SecureRandom().nextInt();    } else {      hostname = jvmName.substring(delimiterIndex + 1, jvmName.length());      try {        pid = Integer.parseInt(jvmName.substring(0, delimiterIndex));      } catch (NumberFormatException e) {        // Generate a random number as the PID if format is unexpected.        pid = new SecureRandom().nextInt();      }    }    return ProcessIdentifier.newBuilder()        .setHostName(hostname)        .setPid(pid)        .setStartTimestamp(MetricsProtoUtils.toTimestampProto(censusTimestamp))        .build();  }
public static Long getProcessInstanceId(Command<?> command) {if (command instanceof ProcessInstanceIdCommand) {return ((ProcessInstanceIdCommand) command).getProcessInstanceId();}         return null;}
private Long getMinTransformedProcessId(Long loadedProcessId) {        ProcessMonitor processMonitor = ArbitrateFactory.getInstance(getPipelineId(), ProcessMonitor.class);        List<Long> processIds = processMonitor.getCurrentProcessIds();        // 如果需要当前node处理当前process的load时，rpc请求一定会将对应的stage状态发到这机器上，并保存到progress中        if (!CollectionUtils.isEmpty(processIds) && !CollectionUtils.isEmpty(progress)) {            // 上一次load成功的在当前的processId中不存在，可能有两种情况:            // 1. zk还未将数据通知过来，当前current processIds还是为老版本的值            // 2. processId已经被删除，比如好久没有数据同步了，定时触发时发觉列表一直为空            // if (loadedProcessId != null && !processIds.contains(loadedProcessId)) {            // // 强制刷新一次，不过也可能是刷到老版本的值，杭州leader还没同步到美国            // processIds = processMonitor.getCurrentProcessIds(true);            // }            Long result = null;            // 做的一个优化，如果上一个processId load成功是在本机，直接忽略            // 因为存在一个问题：比如两个process，都先完成了T模块，然后逐个触发L模块，此时第二个process需要等zookeeper回调watcher时才会被触发            for (Long processId : processIds) {                if (loadedProcessId == null || processId > loadedProcessId) {                    result = processId;                    break;                }            }            // 如果不存在符合>loadedProcessId的记录，直接假设下一个processId就是上一个id+1            // 因为processId目前的机制永远只会递增            if (result == null) {                result = loadedProcessId + 1;            }            if (result != null) {                StageProgress stage = progress.get(result);                if (stage != null && stage.getStage().isTransform()) {                    return result;                } else {                    logger.info("rpc compute [{}] but stage [{}]", result, stage == null ? null : stage.getStage());                    return null;                }            }        }        return null;    }
public Collection<ProcessDefinition> getProcessesByDeploymentId(String deploymentId, QueryContext queryContext) {    deploymentId = getLatestDeploymentId(requireNonNull(deploymentId, DEPLOYMENT_ID_MUST_NOT_BE_NULL));        List<ProcessDefinition> outputCollection = new ArrayList<ProcessDefinition>();        CollectionUtils.select(availableProcesses, new ByDeploymentIdPredicate(deploymentId, identityProvider.getRoles()), outputCollection);        applySorting(outputCollection, queryContext);        return applyPaginition(outputCollection, queryContext);    }
private synchronized Long getMinTransformedProcessId() {        if (!CollectionUtils.isEmpty(progress)) {            Long processId = Collections.min(progress.keySet());            StageProgress stage = progress.get(processId);            // stage可能为空，针对select未完成时，对应的值就为null            if (stage != null && stage != nullProgress && stage.getStage().isTransform()) {                return processId;            }        }        return null;    }
public List<TaskSummary> getTasksByStatusByProcessInstanceId(long processInstanceId, List<Status> status, String language) {return executor.execute(new GetTasksByStatusByProcessInstanceIdCommand(processInstanceId, status));}

regex case insensitive
@NonNull    public Expression regex(@NonNull Expression expression) {        if (expression == null) {            throw new IllegalArgumentException("expression cannot be null.");        }        return new BinaryExpression(this, expression, BinaryExpression.OpType.RegexLike);    }
public static Builder regex(final Builder pBuilder) {        Builder builder = new Builder();        //Using created StringBuilder        builder.prefixes.append(pBuilder.prefixes);        builder.source.append(pBuilder.source);        builder.suffixes.append(pBuilder.suffixes);        builder.modifiers = pBuilder.modifiers;        return builder;    }
public Concatenator REGEX(String regex) {getBooleanOp().setOperator(Operator.REGEX);return this.operateOn(regex);}
public static EquivalentFragmentSet regex(VarProperty varProperty, Variable resourceType, String regex) {        return new AutoValue_RegexFragmentSet(varProperty, resourceType, regex);    }
public Criteria regex(Pattern pattern) {        notNull(pattern, "pattern can not be null");        this.criteriaType = RelationalOperator.REGEX;        this.right = ValueNode.toValueNode(pattern);        return this;    }
public static Pattern regex(String s) {    return regex(java.util.regex.Pattern.compile(s));  }
public static Pattern regex(final java.util.regex.Pattern p) {    return new Pattern() {      @Override      public int match(CharSequence src, int begin, int end) {        if (begin > end)          return MISMATCH;        Matcher matcher = p.matcher(src.subSequence(begin, end));        if (matcher.lookingAt())          return matcher.end();        return MISMATCH;      }    };  }
private String regExp(String htmlInput) {        String parsedHtml = htmlInput.trim();        if (m_modeWord) {            // process all cleanup regular expressions            for (int i = 0; i < m_cleanupPatterns.length; i++) {                parsedHtml = m_clearStyle[i].matcher(parsedHtml).replaceAll("");            }        }        // process all replace regular expressions        for (int i = 0; i < m_replacePatterns.length; i++) {            parsedHtml = m_replaceStyle[i].matcher(parsedHtml).replaceAll(m_replaceValues[i]);        }        return parsedHtml;    }
protected int toRegex(PatternAPI regex, Locale locale, String flags, char padding, int width, int precision, String formatString, int position) {        throw new UnsupportedOperationException("Explicit width matching not supported.");    }
public static String toRegex(String glob, String separators) {    return new GlobToRegex(glob, separators).convert();  }

custom http error response
protected void doErrorResponse(SipServletResponse response)            throws ServletException, IOException {        //The receiver of the message probably dropped off. Remove         //him from the list.        String receiver = response.getTo().toString();        removeUser(receiver);    }
@Override  public RetryDecision onErrorResponse(      @NonNull Request request, @NonNull CoordinatorException error, int retryCount) {    RetryDecision decision =        (error instanceof ReadFailureException || error instanceof WriteFailureException)            ? RetryDecision.RETHROW            : RetryDecision.RETRY_NEXT;    if (decision == RetryDecision.RETRY_NEXT && LOG.isTraceEnabled()) {      LOG.trace(RETRYING_ON_ERROR, logPrefix, retryCount, error);    }    return decision;  }
protected CodeReviewAuditResponseV2 getErrorResponse(CollectorItem repoItem, String scmBranch, String scmUrl) {        CodeReviewAuditResponseV2 noPRsCodeReviewAuditResponse = new CodeReviewAuditResponseV2();        noPRsCodeReviewAuditResponse.addAuditStatus(CodeReviewAuditStatus.COLLECTOR_ITEM_ERROR);        noPRsCodeReviewAuditResponse.setLastUpdated(repoItem.getLastUpdated());        noPRsCodeReviewAuditResponse.setBranch(scmBranch);        noPRsCodeReviewAuditResponse.setUrl(scmUrl);        noPRsCodeReviewAuditResponse.setErrorMessage(repoItem.getErrors() == null ? null : repoItem.getErrors().get(0).getErrorMessage());        return noPRsCodeReviewAuditResponse;    }
protected CodeReviewAuditResponse getErrorResponse(CollectorItem repoItem, String scmBranch, String scmUrl) {        CodeReviewAuditResponse noPRsCodeReviewAuditResponse = new CodeReviewAuditResponse();        noPRsCodeReviewAuditResponse.addAuditStatus(COLLECTOR_ITEM_ERROR);        noPRsCodeReviewAuditResponse.setLastUpdated(repoItem.getLastUpdated());        noPRsCodeReviewAuditResponse.setScmBranch(scmBranch);        noPRsCodeReviewAuditResponse.setScmUrl(scmUrl);        noPRsCodeReviewAuditResponse.setErrorMessage(repoItem.getErrors().get(0).getErrorMessage());        return noPRsCodeReviewAuditResponse;    }
public static String getErrorResponse(HttpURLConnection connection, boolean isZipped) throws IOException {if (connection != null) {InputStream is = null;try {is = connection.getErrorStream();if (is != null) {if (isZipped) {is = new GZIPInputStream(is);}}return Util.readStringFromInputStream(is, "UTF-8");} finally {Util.ensureClosed(is);}}return null;}
public ResponseOnSingeRequest genErrorResponse(Exception t) {        ResponseOnSingeRequest sshResponse = new ResponseOnSingeRequest();        String displayError = PcErrorMsgUtils.replaceErrorMsg(t.toString());        sshResponse.setStackTrace(PcStringUtils.printStackTrace(t));        sshResponse.setErrorMessage(displayError);        sshResponse.setFailObtainResponse(true);        logger.error("error in exec SSH. \nIf exection is JSchException: "                + "Auth cancel and using public key. "                + "\nMake sure 1. private key full path is right (try sshMeta.getPrivKeyAbsPath()). "                + "\n2. the user name and key matches  " + t);        return sshResponse;    }
public static CompletableFuture<Void> sendErrorResponse(ChannelHandlerContext channelHandlerContext,HttpRequest httpRequest,ErrorResponseBody errorMessage,HttpResponseStatus statusCode,Map<String, String> headers) {return sendErrorResponse(channelHandlerContext,HttpHeaders.isKeepAlive(httpRequest),errorMessage,statusCode,headers);}
public static CompletableFuture<Void> sendErrorResponse(ChannelHandlerContext channelHandlerContext,boolean keepAlive,ErrorResponseBody errorMessage,HttpResponseStatus statusCode,Map<String, String> headers) {StringWriter sw = new StringWriter();try {mapper.writeValue(sw, errorMessage);} catch (IOException e) {// this should never happenLOG.error("Internal server error. Could not map error response to JSON.", e);return sendResponse(channelHandlerContext,keepAlive,"Internal server error. Could not map error response to JSON.",HttpResponseStatus.INTERNAL_SERVER_ERROR,headers);}return sendResponse(channelHandlerContext,keepAlive,sw.toString(),statusCode,headers);}
public static void sendErrorResponse(SipApplicationDispatcher sipApplicationDispatcher, int errorCode, SipServletRequestImpl sipServletRequest, SipProvider sipProvider) {if(logger.isDebugEnabled()) {logger.debug("sendErrorResponse - errorCode=" + errorCode + ", sipServletRequest=" + sipServletRequest);}MessageDispatcher.sendErrorResponse(sipApplicationDispatcher, errorCode, (ServerTransaction) sipServletRequest.getTransaction(), (Request) sipServletRequest.getMessage(), sipProvider);if(sipServletRequest.getSipSession() != null) {if(logger.isDebugEnabled()) {logger.debug("sendErrorResponse - sip session is not null");}sipServletRequest.getSipSession().updateStateOnResponse((SipServletResponseImpl)sipServletRequest.createResponse(SipServletResponseImpl.SC_SERVER_INTERNAL_ERROR), false);}}
public static HttpFailure sendErrorResponse(int code, String body) {    return new HttpFailure(new MockResponse().setResponseCode(code).setBody(body));  }

how to determine a string is a valid word
@Private Object word(String name) {    Object p = words.apply(name);    Checks.checkArgument(p != null, "token %s unavailable", name);    return p;  }
private void word(int dir, State lp, State rp) {        assert dir == AHEAD || dir == BEHIND;        cloneouts(nfa, wordchrs, lp, rp, dir);    /* (no need for special attention to \n) */    }
public void word (Color color, String... words) {for (String word : words) {addRule(new WordHighlightRule(color, word));}}
private int calcCountSubstringsWords(String str, HashSet<String> words) {    int wordCount = 0;    int N = str.length();    for (int i = 0; i < N - 1; i++)      for (int j = i + 2; j < N + 1; j++) {        if (words.contains(str.substring(i, j)))          wordCount += 1;      }    return wordCount;  }
public List<VocabularyWord> words() {        List<VocabularyWord> vocab = new ArrayList<>(vocabulary.values());        Collections.sort(vocab, new Comparator<VocabularyWord>() {            @Override            public int compare(VocabularyWord o1, VocabularyWord o2) {                return Integer.compare(o2.getCount(), o1.getCount());            }        });        return vocab;    }
private boolean isWord(String token) {    boolean isWord = true;    if (StringUtils.isNumericSpace(token)) {      isWord = false;    } else if (token.length() == 1) {      char c = token.charAt(0);      if (!Character.isLetter(c)) {        isWord = false;      }    }    return isWord;  }
public static boolean isWord(String wordString) {        return Optional.ofNullable(wordPattern)                .orElseGet(() -> wordPattern = Pattern.compile(WordPattern))                .matcher(wordString).matches();    }
public Word<I> toWord(int fromIndex, int toIndex) {        if (fromIndex < 0 || toIndex > length) {            throw new IndexOutOfBoundsException();        }        int len = toIndex - fromIndex;        lock = true;        return new SharedWord<>(array, fromIndex, len);    }
private boolean ywordc() throws IOException {        if(!YWORDC[parser.buffer.buffer[parser.cursor] & 0xFF]) return false;        parser.cursor++;        while(true) {            if(parser.cursor == parser.limit) parser.read();            if(!YWORDC[parser.buffer.buffer[parser.cursor] & 0xFF]) return true;            parser.cursor++;        }    }
private boolean isWord(String token) {    if (token.length() == 1) {      char c = token.charAt(0);      if (!Character.isLetter(c)) {        return false;      }    }    return true;  }

html entities replace
public static String decodeHtmlEntities(String input, String encoding) {        Matcher matcher = ENTITIY_PATTERN.matcher(input);        StringBuffer result = new StringBuffer(input.length());        Charset charset = Charset.forName(encoding);        CharsetEncoder encoder = charset.newEncoder();        while (matcher.find()) {            String entity = matcher.group();            String value = entity.substring(2, entity.length() - 1);            int c = Integer.valueOf(value).intValue();            if (c < 128) {                // first 128 chars are contained in almost every charset                entity = new String(new char[] {(char)c});                // this is intended as performance improvement since                // the canEncode() operation appears quite CPU heavy            } else if (encoder.canEncode((char)c)) {                // encoder can encode this char                entity = new String(new char[] {(char)c});            }            matcher.appendReplacement(result, entity);        }        matcher.appendTail(result);        return result.toString();    }
public static String encodeHtmlEntities(String input, String encoding) {        StringBuffer result = new StringBuffer(input.length() * 2);        CharBuffer buffer = CharBuffer.wrap(input.toCharArray());        Charset charset = Charset.forName(encoding);        CharsetEncoder encoder = charset.newEncoder();        for (int i = 0; i < buffer.length(); i++) {            int c = buffer.get(i);            if (c < 128) {                // first 128 chars are contained in almost every charset                result.append((char)c);                // this is intended as performance improvement since                // the canEncode() operation appears quite CPU heavy            } else if (encoder.canEncode((char)c)) {                // encoder can encode this char                result.append((char)c);            } else {                // append HTML entity reference                result.append(ENTITY_PREFIX);                result.append(c);                result.append(";");            }        }        return result.toString();    }
private static String decodeHTMLEntities(String string) {if (string == null) {return null;}try {return URLDecoder.decode(string, Charset.defaultCharset().displayName());} catch (UnsupportedEncodingException exception) {return string;}}
private static String encodeHTMLEntities(String string) {if (string == null) {return null;}try {return URLEncoder.encode(string, Charset.defaultCharset().displayName());} catch (UnsupportedEncodingException exception) {return string;}}
public static String replaceHtmlEntities(String content, Map<String, Character> map) {        for (Entry<String, Character> entry : escapeStrings.entrySet()) {            if (content.indexOf(entry.getKey()) != -1) {        content = content.replace(entry.getKey(), String.valueOf(entry.getValue()));      }          }        return content;  }
public static List<Entity> toEntities(AppEngineTransaction transaction,com.google.appengine.api.datastore.Key parent) {List<Entity> entities = new ArrayList<Entity>();com.google.appengine.api.datastore.Key key = Keys.create(parent, TRANSACTION_KIND, transaction.id());entities.add(new Entity(key));for (Log log : transaction.logs()) {Entity entity = new Entity(Keys.create(key, LOG_KIND, log.sequence()));entity.setUnindexedProperty(OPERATION_PROPERTY, log.operation().name());entity.setUnindexedProperty(CLASS_PROPERTY, log.entity().getClass().getName());List<Blob> blobs = new ArrayList<Blob>();entity.setUnindexedProperty(PROTO_PROPERTY, blobs);entities.add(entity);for (Entity e : toEntities(log.entity())) {EntityProto proto = EntityTranslator.convertToPb(e);byte[] bytes = proto.toByteArray();blobs.add(new Blob(bytes));}}return entities;}
public static List<Entity> toEntities(com.google.appengine.api.datastore.Key parent, Object entity) {List<Entity> entities = new ArrayList<Entity>();Class<?> clazz = entity.getClass();if (!clazz.isAnnotationPresent(org.eiichiro.acidhouse.Entity.class)) {throw new IllegalArgumentException("Entity [" + clazz+ "] must be annotated with @org.eiichiro.acidhouse.Entity");}Entity e = new Entity(Keys.create(parent, toKind(clazz), Entities.keyValue(entity)));entities.add(e);for (Field field : clazz.getDeclaredFields()) {if (field.isAnnotationPresent(Key.class)) {continue;}if (field.isAnnotationPresent(Transient.class)) {continue;}try {field.setAccessible(true);Object object = field.get(entity);if (object == null) {continue;}Class<?> type = field.getType();boolean unindexed = field.isAnnotationPresent(Unindexed.class);if (field.isAnnotationPresent(Referential.class)) {com.google.appengine.api.datastore.Key reference = Keys.create(toKind(type), Entities.keyValue(object));setProperty(e, field.getName(), reference, unindexed);continue;}if (isCoreValue(type)) {setProperty(e, field.getName(), object, unindexed);} else if (isCollection(type)) {Collection<?> collection = (Collection<?>) object;Class<?> element = (Class<?>) ((ParameterizedType) field.getGenericType()).getActualTypeArguments()[0];if (isCoreValue(element)) {setProperty(e, field.getName(), collection, unindexed);} else if (isEntity(element)) {for (Object o : collection) {entities.addAll(toEntities(e.getKey(), o));}} else {logger.warning("Collection of non-core value type / non-entity type translation "+ "is not supported: field [" + field + "]");}} else if (isArray(type)) {logger.warning("Array type translation is not supported: field [" + field + "]; Use Collection type instead");} else if (isEntity(type)) {entities.addAll(toEntities(e.getKey(), object));} else if (isEmbedded(type)) {for (Field f : type.getDeclaredFields()) {if (f.isAnnotationPresent(Transient.class)) {continue;}f.setAccessible(true);Object o = f.get(object);if (o == null) {continue;}Class<?> t = f.getType();if (isCoreValue(t) || (isCollection(t) && isCoreValue((Class<?>) ((ParameterizedType) f.getGenericType()).getActualTypeArguments()[0]))) {setProperty(e, field.getName() + "." + f.getName(), o, f.isAnnotationPresent(Unindexed.class));} else {logger.warning("Type translation other than core value type / collection of core value type "+ "is not supported in an embedded type: field [" + f + "]");}}} else {logger.warning("User defined type translation is not supported: field [" + field + "]");}} catch (Exception exception) {throw new UncheckedException(exception);}}return entities;}
@Override    public Set<EntityType<?>> getEntities()    {        Set<EntityType<?>> entities = null;        if (entityTypes != null)        {            entities = new HashSet<EntityType<?>>(entityTypes.values());        }        return entities;    }
public static List<GraphEntity> getEntities(Graph g, String typeName)            throws NullEntity {        GraphEntity[] ge = g.getEntities();        List<GraphEntity> result = new ArrayList<>();        for (int k = 0; k < ge.length; k++) {            if (ge[k].getType().equals(typeName)) {                result.add(ge[k]);            }        }        return result;    }
@Override    public List<EntityDeclaration> getEntities()    {        if (mEntities == null && (mSubset != null)) {            /* Better make a copy, so that caller can not modify list             * DTD has, which may be shared (since DTD subset instances             * are cached and reused)             */            mEntities = new ArrayList<EntityDeclaration>(mSubset.getGeneralEntityList());        }        return mEntities;    }

set file attrib hidden
public void setFile(File file) throws IOException {        if(!file.isFile())            throw new IllegalArgumentException(file+" must be a file.");        else {            if(file.getName().endsWith("gz"))                initGzReader(file);            else                initReader(file);        }    }
public void setFile(String file) {        if (file != null) {            m_file = file.toLowerCase();        } else {            m_file = null;        }    }
public void setFile(File file) throws FileNotFoundException{this.setInputStream(new BufferedInputStream(new FileInputStream(file)), file.length());this.isUploadFile = true;}
public void setFile(InputStream inputStream, String filename, long fileSize) {        this.setFile(inputStream, filename);        this.fileSize = fileSize;    }
public void setFile(File file, String attachmentFilename, String contentType) {        this.file = file;        this.attachmentFilename = attachmentFilename;        this.contentType = contentType;    }
void setFile(IFile file, int offset, int length) {        this.file = file;        this.offset = offset;        this.length = length;    }
public void setFile(File file) {if(file != null) {this.file = file;// Replace the label by the file's name.this.setLabel(file.getName());// Change the icon, depending if the file is a folder or not.this.updateIcon();}}
public void setFiles(java.util.Collection<File> files) {        if (files == null) {            this.files = null;            return;        }        this.files = new java.util.ArrayList<File>(files);    }
private void setupFile() {        if (!new File(directory).exists() && !new File(directory).mkdirs()) {            try {                throw new IOException("Unable to create output directory");            } catch (IOException e) {                log.info(e);            }        }        if (!file.exists()) {            try {                if (!file.createNewFile()) {                    throw new IOException("Unable to create output file");                }            } catch (IOException e) {                log.error(e);            }        }    }
private void resetFile(String file) {    File f = new File(file);    if (f.exists()) {      JMetalLogger.logger.info("Already existing file " + file);      if (f.isDirectory()) {        JMetalLogger.logger.info("Deleting directory " + file);        if (f.delete()) {          JMetalLogger.logger.info("Directory successfully deleted.");        } else {          JMetalLogger.logger.info("Error deleting directory.");        }      } else {        JMetalLogger.logger.info("Deleting file " + file);        if (f.delete()) {          JMetalLogger.logger.info("File successfully deleted.");        } else {          JMetalLogger.logger.info("Error deleting file.");        }      }    } else {      JMetalLogger.logger.info("File " + file + " does NOT exist.");    }  }

sorting multiple arrays based on another arrays sorted order
@SuppressWarnings("unchecked")    public static <T> T[] jsonArrayToArray(final JSONArray jsonArray, final Class<? extends T[]> newType) {        if (null == jsonArray) {            return (T[]) new Object[]{};        }        final int newLength = jsonArray.length();        final Object[] original = new Object[newLength];        for (int i = 0; i < newLength; i++) {            original[i] = jsonArray.opt(i);        }        return Arrays.copyOf(original, newLength, newType);    }
public static byte[] intArrayToByteArray(int[] intArray) {        byte[] byteArray = new byte[intArray.length];        for (int i = 0; i < intArray.length; i++) {            byteArray[i] = intToByte(intArray[i]);        }        return byteArray;    }
public static JsonArray array(String... strings) {    if (strings == null) {      throw new NullPointerException("values is null");    }    JsonArray array = new JsonArray();    for (String value : strings) {      array.add(value);    }    return array;  }
public INDArray array() {        List<INDArray> retList = new ArrayList<>(list.size());        for(X x : list) {            INDArray arr = x.array();            retList.add(arr.reshape(1, arr.length()));        }        return Nd4j.concat(0,retList.toArray(new INDArray[retList.size()]));    }
@Override  public Object[] array() {    DataType dt = data.dataType();    Object[] list = new Object[length];    try {      for (int i = 0; i < length; i++) {        if (!data.isNullAt(offset + i)) {          list[i] = get(i, dt);        }      }      return list;    } catch(Exception e) {      throw new RuntimeException("Could not get the array", e);    }  }
public static Type array(Type elementType) {    Preconditions.checkNotNull(elementType);    switch (elementType.getCode()) {      case BOOL:        return TYPE_ARRAY_BOOL;      case INT64:        return TYPE_ARRAY_INT64;      case FLOAT64:        return TYPE_ARRAY_FLOAT64;      case STRING:        return TYPE_ARRAY_STRING;      case BYTES:        return TYPE_ARRAY_BYTES;      case TIMESTAMP:        return TYPE_ARRAY_TIMESTAMP;      case DATE:        return TYPE_ARRAY_DATE;      default:        return new Type(Code.ARRAY, elementType, null);    }  }
public static Array array(Object array) {        if (array instanceof Object[]) {            return array((Object[]) array);        }        switch (tId(array.getClass())) {            case I_BOOLEAN:     return array((boolean[]) array);            case I_BYTE:        return array((byte[]) array);            case I_CHARACTER:   return array((char[]) array);            case I_DOUBLE:      return array((double[]) array);            case I_FLOAT:       return array((float[]) array);            case I_INTEGER:     return array((int[]) array);            case I_LONG:        return array((long[]) array);            case I_SHORT:       return array((short[]) array);        }        throw new IllegalArgumentException("No array: " + array);    }
public static <T> QueryParameterValue array(T[] array, Class<T> clazz) {    return array(array, classToType(clazz));  }
public static <T> QueryParameterValue array(T[] array, StandardSQLTypeName type) {    List<QueryParameterValue> listValues = new ArrayList<>();    for (T obj : array) {      listValues.add(QueryParameterValue.of(obj, type));    }    return QueryParameterValue.newBuilder()        .setArrayValues(listValues)        .setType(StandardSQLTypeName.ARRAY)        .setArrayType(type)        .build();  }
Expr array() {if (peek().sym != Sym.LBRACK) {return atom();}move();if (peek().sym == Sym.RBRACK) {move();return new Array(ExprList.NULL_EXPR_ARRAY, location);}ExprList exprList = exprList();if (exprList.length() == 1 && peek().sym == Sym.RANGE) {move();Expr end = expr();match(Sym.RBRACK);return new RangeArray(exprList.getExprArray()[0], end, location);}match(Sym.RBRACK);return new Array(exprList.getExprArray(), location);}

string similarity levenshtein
public static double stringSimilarity(String... strings) {        if (strings == null)            return 0;        Counter<String> counter = new Counter<>();        Counter<String> counter2 = new Counter<>();        for (int i = 0; i < strings[0].length(); i++)            counter.incrementCount(String.valueOf(strings[0].charAt(i)), 1.0f);        for (int i = 0; i < strings[1].length(); i++)            counter2.incrementCount(String.valueOf(strings[1].charAt(i)), 1.0f);        Set<String> v1 = counter.keySet();        Set<String> v2 = counter2.keySet();        Set<String> both = SetUtils.intersection(v1, v2);        double sclar = 0, norm1 = 0, norm2 = 0;        for (String k : both)            sclar += counter.getCount(k) * counter2.getCount(k);        for (String k : v1)            norm1 += counter.getCount(k) * counter.getCount(k);        for (String k : v2)            norm2 += counter2.getCount(k) * counter2.getCount(k);        return sclar / Math.sqrt(norm1 * norm2);    }
public static String string(byte[] bytes) {    if (bytes == null) {      return null;    }    try {      return new String(bytes, ENCODING);    } catch (UnsupportedEncodingException e) {      log.error("UnsupportedEncodingException ", e);      throw new RuntimeException(e);    }  }
public static Pattern string(final String string) {    return new Pattern() {      @Override public int match(CharSequence src, int begin, int end) {        if ((end - begin) < string.length()) return MISMATCH;        return matchString(string, src, begin, end);      }      @Override public String toString() {        return string;      }    };  }
public static KeyValuePair<byte[], byte[]> string(KeyValuePair<byte[], ?> raw, byte[] value) {        KeyStringValueString kv = new KeyStringValueString();        copy(raw, kv);        kv.setValue(value);        return kv;    }
public static BatchedKeyStringValueString string(KeyValuePair<byte[], ?> raw, byte[] value, int batch, boolean last) {        BatchedKeyStringValueString kv = new BatchedKeyStringValueString();        copy(raw, kv, batch, last);        kv.setValue(value);        return kv;    }
public Table string(String s, String fileExtension) {DataReader<?> reader = registry.getReaderForExtension(fileExtension);try {            return reader.read(Source.fromString(s));} catch (IOException e) {    throw new IllegalStateException(e);}    }
public String string(StringCondition condition) {        String description;        if (condition.getContext() != null && condition.getContext().get(CONTEXT_PROPERTY_DESCRIPTION) != null) {            description = condition.getContext().get(CONTEXT_PROPERTY_DESCRIPTION);        } else {            description = condition.getDataId();        }        StringCondition.Operator operator = condition.getOperator();        switch (operator) {            case STARTS_WITH:                description += "starts with ";                break;            case CONTAINS:                description += "contains ";                break;            case ENDS_WITH:                description += "ends with ";                break;            case EQUAL:                description += "is equal to ";                break;            case NOT_EQUAL:                description += "is not equal to ";                break;            case MATCH:                description += "matches to ";                break;            default:                throw new IllegalArgumentException(operator.name());        }        description += condition.getPattern();        if (condition.isIgnoreCase()) {            description += " (ignore case)";        }        return description;    }
static List<String> string(String name, @Nullable String value) {    if (!Strings.isNullOrEmpty(value)) {      return Arrays.asList("--" + name, value);    }    return Collections.emptyList();  }
private String string(JsonObject node, String key, String default_) {    JsonElement value = node.get(key);    if (value != null && value.isJsonPrimitive()) {      return value.getAsString();    }    return default_;  }
public static String string(ByteBuffer buffer, int position, int length) throws CharacterCodingException    {        return string(buffer, position, length, StandardCharsets.UTF_8);    }

how to get html of website
public String html() {        if (html != null) {            return html;        }        if (content == null) {            return null;        }        if (charset == null) {            charset = CharsetDetector.guessEncoding(content());        }        try {            html = new String(content, charset);        } catch (UnsupportedEncodingException e) {            LOG.info("Exception when decoding "+ key(),e);            return null;        }        return html;    }
public String html(String htmlSource) {        String cleanSource = htmlCleaner.cleanupPreFormatted(htmlSource);        return "<div>" + StringEscapeUtils.unescapeHtml4(cleanSource) + "</div>";    }
protected DCTree html() {        int p = bp;        nextChar();        if (isIdentifierStart(ch)) {            Name name = readIdentifier();            List<DCTree> attrs = htmlAttrs();            if (attrs != null) {                boolean selfClosing = false;                if (ch == '/') {                    nextChar();                    selfClosing = true;                }                if (ch == '>') {                    nextChar();                    DCTree dctree = m.at(p).newStartElementTree(name, attrs, selfClosing).setEndPos(bp);                    return dctree;                }            }        } else if (ch == '/') {            nextChar();            if (isIdentifierStart(ch)) {                Name name = readIdentifier();                skipWhitespace();                if (ch == '>') {                    nextChar();                    return m.at(p).newEndElementTree(name);                }            }        } else if (ch == '!') {            nextChar();            if (ch == '-') {                nextChar();                if (ch == '-') {                    nextChar();                    while (bp < buflen) {                        int dash = 0;                        while (ch == '-') {                            dash++;                            nextChar();                        }                        // Strictly speaking, a comment should not contain "--"                        // so dash > 2 is an error, dash == 2 implies ch == '>'                        // See http://www.w3.org/TR/html-markup/syntax.html#syntax-comments                        // for more details.                        if (dash >= 2 && ch == '>') {                            nextChar();                            return m.at(p).newCommentTree(newString(p, bp));                        }                        nextChar();                    }                }            }        }        bp = p + 1;        ch = buf[bp];        return erroneous("dc.malformed.html", p);    }
protected void html() {        int p = bp;        nextChar();        if (isIdentifierStart(ch)) {            String name = readIdentifier();            checkHtmlTag(name);            htmlAttrs();            if (ch == '/') {                nextChar();            }            if (ch == '>') {                nextChar();                return;            }        } else if (ch == '/') {            nextChar();            if (isIdentifierStart(ch)) {                readIdentifier();                skipWhitespace();                if (ch == '>') {                    nextChar();                    return;                }            }        } else if (ch == '!') {            nextChar();            if (ch == '-') {                nextChar();                if (ch == '-') {                    nextChar();                    while (bp < buflen) {                        int dash = 0;                        while (ch == '-') {                            dash++;                            nextChar();                        }                        // Strictly speaking, a comment should not contain "--"                        // so dash > 2 is an error, dash == 2 implies ch == '>'                        // See http://www.w3.org/TR/html-markup/syntax.html#syntax-comments                        // for more details.                        if (dash >= 2 && ch == '>') {                            nextChar();                            return;                        }                        nextChar();                    }                }            }        }        bp = p + 1;        ch = buf[bp];    }
public static HtmlTree HTML(String lang, Content head, Content body) {        HtmlTree htmltree = new HtmlTree(HtmlTag.HTML, nullCheck(head), nullCheck(body));        htmltree.addAttr(HtmlAttr.LANG, nullCheck(lang));        return htmltree;    }
public String html(String text) {        if (text == null || text.isEmpty()) {            return text;        }        return StringEscapeUtils.escapeHtml4(text);    }
public String html() {        StringBuilder sb = StringUtil.borrowBuilder();        try {            html(sb, (new Document("")).outputSettings()); // output settings a bit funky, but this html() seldom used        } catch (IOException e) { // ought never happen            throw new SerializationException(e);        }        return StringUtil.releaseBuilder(sb);    }
public String html() {        StringBuilder accum = StringUtil.borrowBuilder();        html(accum);        String html = StringUtil.releaseBuilder(accum);        return NodeUtils.outputSettings(this).prettyPrint() ? html.trim() : html;    }
public static String html(String html) {        StringBuilder sb = createStringBuilder(html.length());        html(sb, html);        return sb.toString();    }
public String html() {        StringBuilder sb = StringUtil.borrowBuilder();        for (Element element : this) {            if (sb.length() != 0)                sb.append("\n");            sb.append(element.html());        }        return StringUtil.releaseBuilder(sb);    }

buffered file reader read text
public static ArrayList<double[]> readText(String featuresFileName, int featureLength) throws Exception {ArrayList<double[]> features = new ArrayList<double[]>();BufferedReader in = new BufferedReader(new FileReader(new File(featuresFileName)));String line;while ((line = in.readLine()) != null) {String[] stringVals = line.split(",");if (stringVals.length != featureLength) {in.close();throw new Exception("Line contains " + stringVals.length+ " comma separated values instead of " + featureLength + "\n" + line);}double[] vals = new double[featureLength];for (int j = 0; j < featureLength; j++) {vals[j] = Double.parseDouble(stringVals[j]);}features.add(vals);}in.close();return features;}
public static String readText(final BufferedReader breader) {    String line;    final StringBuilder sb = new StringBuilder();    try {      while ((line = breader.readLine()) != null) {        sb.append(line).append(LINE_BREAK);      }    } catch (final IOException e) {      e.printStackTrace();    }    String text = sb.toString();    text = buildText(text);    return text;  }
protected String readText(Postcard postcard, String path, boolean html, boolean filesystem, OptionalThing<Locale> receiverLocale,            OptionalThing<Object> dynamicData) {        if (dynamicData.isPresent()) {            final OptionalThing<String> assisted = assistDynamicText(postcard, path, html, filesystem, receiverLocale, dynamicData.get());            if (assisted.isPresent()) {                return assisted.get();            }        }        final String cacheKey = generateCacheKey(path, filesystem, receiverLocale);        final String cached = textCacheMap.get(cacheKey);        if (cached != null) {            return cached;        }        synchronized (this) {            final String retried = textCacheMap.get(cacheKey);            if (retried != null) {                return retried;            }            final String read = doReadText(postcard, path, filesystem, receiverLocale);            if (read == null) { // just in case                String msg = "Not found the text from the path: " + path + ", filesystem=" + filesystem;                throw new SMailIllegalStateException(msg);            }            textCacheMap.put(cacheKey, read);            return textCacheMap.get(cacheKey);        }    }
public int readText(char []charBuffer, int charOffset, int charLength)    throws IOException  {    byte []byteBuffer = _is.buffer();    int byteOffset = _is.offset();    int byteLength = _is.length();    if (byteLength <= byteOffset || length() == 0) {      if (! fillFrameBuffer()) {        return -1;      }      byteOffset = _is.offset();      byteLength = _is.length();    }    int charEnd = charOffset + charLength;    int i = charOffset;    int byteBegin = byteOffset;    int byteEnd = (int) Math.min(byteLength, byteOffset + length());    while (i < charEnd && byteOffset < byteEnd) {      int d1 = byteBuffer[byteOffset++] & 0xff;      char ch;      if (d1 < 0x80) {        ch = (char) d1;      }      else if ((d1 & 0xe0) == 0xc0) {        int d2 = byteBuffer[byteOffset++] & 0xff;        ch = (char) (((d1 & 0x1f) << 6) + (d2 & 0x3f));        if (d2 < 0) {          closeError(CloseCodes.NOT_CONSISTENT, "illegal utf-8");          ch = UTF8_ERROR;        }        else if ((d2 & 0xc0) != 0x80) {          closeError(CloseCodes.NOT_CONSISTENT, "illegal utf-8");          ch = UTF8_ERROR;        }        else if (ch < 0x80) {          closeError(CloseCodes.NOT_CONSISTENT, "illegal utf-8");          ch = UTF8_ERROR;        }      }      else if ((d1 & 0xf0) == 0xe0){        int d2 = byteBuffer[byteOffset++] & 0xff;        int d3 = byteBuffer[byteOffset++] & 0xff;        ch = (char) (((d1 & 0x0f) << 12) + ((d2 & 0x3f) << 6) + (d3 & 0x3f));        if (d3 < 0) {          closeError(CloseCodes.NOT_CONSISTENT, "illegal utf-8");          ch = UTF8_ERROR;        }        else if ((d2 & 0xc0) != 0x80) {          closeError(CloseCodes.NOT_CONSISTENT, "illegal utf-8");          ch = UTF8_ERROR;        }        else if ((d3 & 0xc0) != 0x80) {          closeError(CloseCodes.NOT_CONSISTENT, "illegal utf-8");          ch = UTF8_ERROR;        }        else if (ch < 0x800) {          closeError(CloseCodes.NOT_CONSISTENT, "illegal utf-8");          ch = UTF8_ERROR;        }        else if (0xd800 <= ch && ch <= 0xdfff) {          closeError(CloseCodes.NOT_CONSISTENT, "illegal utf-8");          ch = UTF8_ERROR;        }      }      else if ((d1 & 0xf8) == 0xf0){        int d2 = byteBuffer[byteOffset++] & 0xff;        int d3 = byteBuffer[byteOffset++] & 0xff;        int d4 = byteBuffer[byteOffset++] & 0xff;        int cp = (((d1 & 0x7) << 18)                   + ((d2 & 0x3f) << 12)                   + ((d3 & 0x3f) << 6)                   + ((d4 & 0x3f)));        cp -= 0x10000;        char h = (char) (0xd800 + ((cp >> 10) & 0x3ff));        charBuffer[i++] = h;        ch = (char) (0xdc00 + (cp & 0x3ff));        if (d4 < 0) {          closeError(CloseCodes.NOT_CONSISTENT, "illegal utf-8");          ch = UTF8_ERROR;        }        else if ((d2 & 0xc0) != 0x80) {          closeError(CloseCodes.NOT_CONSISTENT, "illegal utf-8");          ch = UTF8_ERROR;        }        else if ((d3 & 0xc0) != 0x80) {          closeError(CloseCodes.NOT_CONSISTENT, "illegal utf-8");          ch = UTF8_ERROR;        }        else if ((d4 & 0xc0) != 0x80) {          closeError(CloseCodes.NOT_CONSISTENT, "illegal utf-8");          ch = UTF8_ERROR;        }        else if (cp < 0x0) {          closeError(CloseCodes.NOT_CONSISTENT, "illegal utf-8");          ch = UTF8_ERROR;        }        else if (cp >= 0x100000) {          closeError(CloseCodes.NOT_CONSISTENT, "illegal utf-8");          ch = UTF8_ERROR;        }      }      else {        closeError(CloseCodes.NOT_CONSISTENT, "illegal utf-8");        ch = UTF8_ERROR;      }      charBuffer[i++] = ch;    }    _is.offset(byteOffset);    _length -= (byteOffset - byteBegin);    return i - charOffset;  }
public static String readText(Reader reader) {        BufferedReader in = new BufferedReader(reader);        StringBuilder out = new StringBuilder(100);        try {            try {                char[] buf = new char[8192];                int n;                while ((n = in.read(buf)) >= 0) {                    out.append(buf, 0, n);                }            } finally {                in.close();            }        } catch (IOException e) {            String msg = "The IOException occurred: reader=" + reader;            throw new IllegalStateException(msg, e);        }        return out.toString();    }
protected Iterable<String> readtext(String name, boolean unescapeNewlines) throws IOException {    ArrayList<String> res = new ArrayList<>(50);    BufferedReader br = _reader.getTextFile(name);    try {      String line;      while (true) {        line = br.readLine();        if (line == null) break;        if (unescapeNewlines)          line = StringEscapeUtils.unescapeNewlines(line);        res.add(line.trim());      }      br.close();    } finally {      try { br.close(); } catch (IOException e) { /* ignored */ }    }    return res;  }
public String readToText() {        Charset charset = getCharset();        try (InputStream in = body();             Reader reader = new InputStreamReader(in, charset)) {            return Readers.readAll(reader);        } catch (IOException e) {            throw new RequestsException(e);        } finally {            close();        }    }
public static String readTextURI(final URI source, final String encoding,                                     final String accept, final String acceptLanguage)            throws XIncludeFatalException, XIncludeResourceException    {        try        {            final URL url = source.toURL();            final URLConnection urlConnection = url.openConnection();            if (null != accept)            {                urlConnection.setRequestProperty(HttpHeaders.ACCEPT, accept);            }            if (null != acceptLanguage)            {                urlConnection.setRequestProperty(HttpHeaders.ACCEPT_LANGUAGE, acceptLanguage);            }            final InputStream urlInputStream = urlConnection.getInputStream();            final byte[] inputBytes = ByteStreams.toByteArray(urlInputStream);            urlInputStream.close();            final BOMInputStream bomInputStream = new BOMInputStream(new ByteArrayInputStream(inputBytes));            if (bomInputStream.hasBOM())            {                final Readable reader = new InputStreamReader(new BufferedInputStream(bomInputStream));                return CharStreams.toString(reader);            }            else            {                final ByteSource supplier = ByteSource.wrap(inputBytes);                final Charset charset = (null == encoding) ? EncodingUtils.getCharset(supplier.openBufferedStream()) : Charset.forName(encoding);                return CharStreams.toString(new InputStreamReader(supplier.openStream(), charset));            }        }        catch (MalformedURLException | UnsupportedEncodingException e)        {            throw new XIncludeFatalException(e.getMessage());        } catch (IOException e)        {            throw new XIncludeResourceException(e.getMessage());        }    }
public JournalEntryContext readContext(XMLEventReader reader)            throws JournalException, XMLStreamException {        JournalEntryContext context = new JournalEntryContext();        XMLEvent event = reader.nextTag();        if (!isStartTagEvent(event, QNAME_TAG_CONTEXT)) {            throw getNotStartTagException(QNAME_TAG_CONTEXT, event);        }        context.setPassword(readContextPassword(reader));        context.setNoOp(readContextNoOp(reader));        context.setNow(readContextNow(reader));        context                .setEnvironmentAttributes(convertStringMap(readMultiMap(reader,                                                       CONTEXT_MAPNAME_ENVIRONMENT)));        context.setSubjectAttributes(readMultiMap(reader,                                                  CONTEXT_MAPNAME_SUBJECT));        context                .setActionAttributes(convertStringMap(readMultiMap(reader,                                                  CONTEXT_MAPNAME_ACTION)));        context.setResourceAttributes(convertStringMap(readMultiMap(reader,                                                   CONTEXT_MAPNAME_RESOURCE)));        context.setRecoveryAttributes(convertStringMap(readMultiMap(reader,                                                   CONTEXT_MAPNAME_RECOVERY)));        event = reader.nextTag();        if (!isEndTagEvent(event, QNAME_TAG_CONTEXT)) {            throw getNotEndTagException(QNAME_TAG_CONTEXT, event);        }        decipherPassword(context);        return context;    }
public DataStreamSource<String> readTextFile(String filePath, String charsetName) {Preconditions.checkArgument(!StringUtils.isNullOrWhitespaceOnly(filePath), "The file path must not be null or blank.");TextInputFormat format = new TextInputFormat(new Path(filePath));format.setFilesFilter(FilePathFilter.createDefaultFilter());TypeInformation<String> typeInfo = BasicTypeInfo.STRING_TYPE_INFO;format.setCharsetName(charsetName);return readFile(format, filePath, FileProcessingMode.PROCESS_ONCE, -1, typeInfo);}

encrypt aes ctr mode
public DistanceMatrixApiRequest mode(TravelMode mode) {    if (TravelMode.DRIVING.equals(mode)        || TravelMode.WALKING.equals(mode)        || TravelMode.BICYCLING.equals(mode)        || TravelMode.TRANSIT.equals(mode)) {      return param("mode", mode);    }    throw new IllegalArgumentException(        "Distance Matrix API travel modes must be Driving, Transit, Walking or Bicycling");  }
public static int Mode( int[] values ){        int mode = 0, curMax = 0;        for ( int i = 0, length = values.length; i < length; i++ )        {            if ( values[i] > curMax )            {                curMax = values[i];                mode = i;            }        }        return mode;    }
@SafeVarargs    public static <T> T mode(final T... items) {        if (ArrayUtils.isNotEmpty(items)) {            final HashMap<T, MutableInt> occurrences = new HashMap<>(items.length);            for (final T t : items) {                final MutableInt count = occurrences.get(t);                if (count == null) {                    occurrences.put(t, new MutableInt(1));                } else {                    count.increment();                }            }            T result = null;            int max = 0;            for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {                final int cmp = e.getValue().intValue();                if (cmp == max) {                    result = null;                } else if (cmp > max) {                    max = cmp;                    result = e.getKey();                }            }            return result;        }        return null;    }
Rule Mode() {return FirstOf(Major(), Lydian(), Ionian(), Mixolydian(),Dorian(), Aeolian(), Phrygian(), Locrian(),Explicit(), Minor()).label(Mode);}
public static FlatDataCollection mode(FlatDataCollection flatDataCollection) {        AssociativeArray frequencies = frequencies(flatDataCollection);                int maxCounter=0;                FlatDataList modeList = new FlatDataList();                for(Map.Entry<Object, Object> entry : frequencies.entrySet()) {            Object key = entry.getKey();            int count = ((Number)entry.getValue()).intValue();            if(maxCounter==count) {                modeList.add(key);            }            else if(maxCounter<count) {                maxCounter=count;                modeList.clear();                modeList.add(key);            }        }                return modeList.toFlatDataCollection();    }
public static double mode(double[] values) {        if (values.length == 0)            throw new IllegalArgumentException("No mode in an empty array");                Counter<Double> c = new ObjectCounter<Double>();        for (double d : values)            c.count(d);        return c.max();    }
public static <T extends Number> T mode(Collection<T> values) {        if (values.isEmpty())            throw new IllegalArgumentException(                "No mode in an empty collection");        Counter<T> c = new ObjectCounter<T>();        for (T n : values)            c.count(n);        return c.max();    }
public static int mode(int[] values) {        if (values.length == 0)            throw new IllegalArgumentException("No mode in an empty array");                Counter<Integer> c = new ObjectCounter<Integer>();        for (int i : values)            c.count(i);        return c.max();    }
public static <T> Collector<T, ?, Optional<T>> mode() {        return mode0(seq -> seq.maxBy(t -> t.v2).map(t -> t.v1));    }
public static int mode(File f) throws PosixException {        if(Functions.isWindows())   return -1;        try {            if (Util.NATIVE_CHMOD_MODE) {                return PosixAPI.jnr().stat(f.getPath()).mode();            } else {                return Util.permissionsToMode(Files.getPosixFilePermissions(fileToPath(f)));            }        } catch (IOException cause) {            PosixException e = new PosixException("Unable to get file permissions", null);            e.initCause(cause);            throw e;        }    }

matrix multiply
public static void checkMatrixMultiplication() {        DoubleMatrix A = new DoubleMatrix(new double[][]{                    {1.0, 2.0, 3.0},                    {4.0, 5.0, 6.0},                    {7.0, 8.0, 9.0}                });        DoubleMatrix E = new DoubleMatrix(new double[][]{                    {0.0, 0.0, 1.0},                    {0.0, 1.0, 0.0},                    {1.0, 0.0, 0.0}                });        DoubleMatrix B = new DoubleMatrix(new double[][]{                    {3.0, 2.0, 1.0},                    {6.0, 5.0, 4.0},                    {9.0, 8.0, 7.0}                });        check("checking matrix multiplication", A.mmul(E).equals(B));    }
public float[] matrix() {float[] matrix = new float[8];float cosX = (float) Math.cos(rotationRadians);float sinX = (float) Math.sin(rotationRadians);matrix[AX] = plainWidth * cosX;matrix[AY] = plainWidth * sinX;matrix[BX] = (-plainHeight) * sinX;matrix[BY] = plainHeight * cosX;if (rotationRadians < Math.PI / 2f) {matrix[CX] = matrix[BX];matrix[CY] = 0;matrix[DX] = matrix[AX];matrix[DY] = matrix[AY] + matrix[BY];} else if (rotationRadians < Math.PI) {matrix[CX] = matrix[AX] + matrix[BX];matrix[CY] = matrix[BY];matrix[DX] = 0;matrix[DY] = matrix[AY];} else if (rotationRadians < Math.PI * 1.5f) {matrix[CX] = matrix[AX];matrix[CY] = matrix[AY] + matrix[BY];matrix[DX] = matrix[BX];matrix[DY] = 0;} else {matrix[CX] = 0;matrix[CY] = matrix[AY];matrix[DX] = matrix[AX] + matrix[BX];matrix[DY] = matrix[BY];}return matrix;}
public static DenseMatrix matrix(double[] A) {        if (nlmatrixZeros != null) {            try {                return (DenseMatrix) nlmatrixArray.newInstance(A);            } catch (Exception e) {                logger.error("Failed to call NLMatrix(double[]): {}", e);            }        }        return new JMatrix(A);    }
public static DenseMatrix matrix(double[][] A) {        if (nlmatrixZeros != null) {            try {                return (DenseMatrix) nlmatrixArray2D.newInstance((Object) A);            } catch (Exception e) {                logger.error("Failed to call NLMatrix(double[][]): {}", e);            }        }        return new JMatrix(A);    }
public static DenseMatrix matrix(int nrows, int ncols, double value) {        if (nlmatrixOnes != null) {            try {                return (DenseMatrix) nlmatrixOnes.newInstance(nrows, ncols, value);            } catch (Exception e) {                logger.error("Failed to call NLMatrix(int, int, double): {}", e);            }        }        return new JMatrix(nrows, ncols, value);    }
public static DenseMatrix matrix(int nrows, int ncols) {        if (nlmatrixZeros != null) {            try {                return (DenseMatrix) nlmatrixZeros.newInstance(nrows, ncols);            } catch (Exception e) {                logger.error("Failed to call NLMatrix(int, int): {}", e);            }        }        return new JMatrix(nrows, ncols);    }
@GET  @Path("search/matrix")  @Produces("text/plain")  public StreamingOutput matrix(    final @QueryParam("q") String query,    final @QueryParam("corpora") String rawCorpusNames,    @QueryParam("metakeys") String rawMetaKeys,    @DefaultValue("false") @QueryParam("csv") String rawCsv)  {    requiredParameter(query, "q", "AnnisQL query");    requiredParameter(rawCorpusNames, "corpora",      "comma separated list of corpus names");    final boolean outputCsv = Boolean.parseBoolean(rawCsv);        Subject user = SecurityUtils.getSubject();    List<String> corpusNames = splitCorpusNamesFromRaw(rawCorpusNames);    for (String c : corpusNames)    {      user.checkPermission("query:matrix:" + c);    }    final QueryData data = queryDataFromParameters(query, rawCorpusNames);    MatrixQueryData ext = new MatrixQueryData();    if(rawMetaKeys != null)    {      ext.setMetaKeys(splitMatrixKeysFromRaw(rawMetaKeys));    }    if(ext.getMetaKeys() != null && ext.getMetaKeys().isEmpty())    {      ext.setMetaKeys(null);    }    data.addExtension(ext);    StreamingOutput result = new StreamingOutput()    {      @Override      public void write(OutputStream output) throws IOException, WebApplicationException      {        long start = new Date().getTime();        queryDao.matrix(data, outputCsv, output);        long end = new Date().getTime();        logQuery("MATRIX", query, splitCorpusNamesFromRaw(rawCorpusNames),          end - start);      }    };    return result;  }
public static DMatrixRMaj toMatrix(GeoTuple3D_F64 in, DMatrixRMaj out) {if( out == null )out = new DMatrixRMaj(3,1);else if( out.getNumElements() != 3 )throw new IllegalArgumentException("Vector with 3 elements expected");out.data[0] = in.x;out.data[1] = in.y;out.data[2] = in.z;return out;}
public static Matrix toMatrix(INDArray arr) {        if (!arr.isMatrix()) {            throw new IllegalArgumentException("passed in array must be a matrix");        }        // if arr is a view - we have to dup anyway        if (arr.isView()) {            return Matrices.dense(arr.rows(), arr.columns(), arr.dup('f').data().asDouble());        } else // if not a view - we must ensure data is F ordered            return Matrices.dense(arr.rows(), arr.columns(),                            arr.ordering() == 'f' ? arr.data().asDouble() : arr.dup('f').data().asDouble());    }
public static INDArray toMatrix(Matrix arr) {        // we assume that Matrix always has F order        return Nd4j.create(arr.toArray(), new int[] {arr.numRows(), arr.numCols()}, 'f');    }

print model summary
private Table summarize(TableSliceGroup group) {        List<Table> results = new ArrayList<>();        ArrayListMultimap<String, AggregateFunction<?, ?>> reductionMultimap = getAggregateFunctionMultimap();        for (String name : reductionMultimap.keys()) {            List<AggregateFunction<?, ?>> reductions = reductionMultimap.get(name);            results.add(group.aggregate(name, reductions.toArray(new AggregateFunction<?, ?>[0])));        }        return combineTables(results);    }
public static <R extends Tuple, T extends Tuple> R summarize(DataSet<T> input) throws Exception {if (!input.getType().isTupleType()) {throw new IllegalArgumentException("summarize() is only implemented for DataSet's of Tuples");}final TupleTypeInfoBase<?> inType = (TupleTypeInfoBase<?>) input.getType();DataSet<TupleSummaryAggregator<R>> result = input.mapPartition(new MapPartitionFunction<T, TupleSummaryAggregator<R>>() {@Overridepublic void mapPartition(Iterable<T> values, Collector<TupleSummaryAggregator<R>> out) throws Exception {TupleSummaryAggregator<R> aggregator = SummaryAggregatorFactory.create(inType);for (Tuple value : values) {aggregator.aggregate(value);}out.collect(aggregator);}}).reduce(new ReduceFunction<TupleSummaryAggregator<R>>() {@Overridepublic TupleSummaryAggregator<R> reduce(TupleSummaryAggregator<R> agg1, TupleSummaryAggregator<R> agg2) throws Exception {agg1.combine(agg2);return agg1;}});return result.collect().get(0).result();}
private void summarize(MetricDatum datum, Map<String, MetricDatum> uniqueMetrics) {        Double value = datum.getValue();        if (value == null) {            return;        }        List<Dimension> dims = datum.getDimensions();        Collections.sort(dims, DimensionComparator.INSTANCE);        String metricName = datum.getMetricName();        String key = metricName + Jackson.toJsonString(dims);        MetricDatum statDatum = uniqueMetrics.get(key);        if (statDatum == null) {            statDatum = new MetricDatum()                .withDimensions(datum.getDimensions())                .withMetricName(metricName)                .withUnit(datum.getUnit())                .withStatisticValues(new StatisticSet()                    .withMaximum(value)                    .withMinimum(value)                    .withSampleCount(0.0)                    .withSum(0.0))                ;            uniqueMetrics.put(key, statDatum);        }        StatisticSet stat = statDatum.getStatisticValues();        stat.setSampleCount(stat.getSampleCount() + 1.0);        stat.setSum(stat.getSum() + value);        if (value > stat.getMaximum()) {            stat.setMaximum(value);        } else if (value < stat.getMinimum()) {            stat.setMinimum(value);        }    }
@javax.annotation.Nonnull  public String summarize(final int maxLog, @javax.annotation.Nonnull final String string) {    if (string.length() > maxLog * 2) {      @javax.annotation.Nonnull final String left = string.substring(0, maxLog);      @javax.annotation.Nonnull final String right = string.substring(string.length() - maxLog);      final String link = String.format(file(string, "\n...skipping %s bytes...\n"), string.length() - 2 * maxLog);      return left + link + right;    }    else {      return string;    }  }
@javax.annotation.Nonnull  public String summarize(@javax.annotation.Nonnull String logSrc, final int maxLog) {    if (logSrc.length() > maxLog * 2) {      @javax.annotation.Nonnull final String prefix = logSrc.substring(0, maxLog);      logSrc = prefix + String.format(        (prefix.endsWith("\n") ? "" : "\n") + "~```\n~..." + file(logSrc, "skipping %s bytes") + "...\n~```\n",        logSrc.length() - 2 * maxLog) + logSrc.substring(logSrc.length() - maxLog);    }    return logSrc;  }
public String summarize()    {        return String.format(SUMMARY_FORMAT,            action, grantType, clientId, subject, Utils.join(scopes, " "),            accessToken, tokenType, expiresIn, expiresAt, refreshToken);    }
public String summarize()    {        return String.format(SUMMARY_FORMAT,            action, clientId, subject,            Utils.join(scopes, " "),            Utils.join(claims, " "),            token,            Utils.stringifyProperties(properties),            clientIdAlias,            clientIdAliasUsed);    }
public String summarize()    {        return String.format(SUMMARY_FORMAT,                action, responseContent, accessToken, accessTokenExpiresAt,                accessTokenDuration, idToken, authorizationCode, jwtAccessToken);    }
public String summarize()    {        return String.format(SUMMARY_FORMAT, action, accessToken,                accessTokenExpiresAt, Utils.join(scopes, " "), tokenType);    }
public String summarize()    {        return String.format(SUMMARY_FORMAT,                action, clientId, subject, existent, usable,                sufficient, refreshable, expiresAt,                Utils.join(scopes, " "),                Utils.stringifyProperties(properties),                clientIdAlias, clientIdAliasUsed,                certificateThumbprint);    }

unique elements
public int addUniqueElement(int element, int treap) {int treap_;if (treap == -1) {if (m_defaultTreap == nullNode())m_defaultTreap = createTreap(-1);treap_ = m_defaultTreap;} else {treap_ = treap;}return addElement_(element, 1, treap_);}
@Override    public final T element() {        // Short circuit using read-lock        if (this.isEmpty()) {            throw new NoSuchElementException();        }        final T e = this.peek();        if (e == null) {            throw new NoSuchElementException();        }        return e;    }
Rule Element() {return FirstOf(Tuplet(), SlurBegin(), SlurEnd(),WSPS().label(Space), ChordOrText(),NthRepeat(), EndNthRepeat(),Barline(), Gracing(), BrokenRhythm(),//.| = dashed barline, no staccato barline//+>+ = Gracing, > = BrokenRhythm//!fermata! before f, e and a parsed into notesStem(), Rest(), GraceNotes(), MultiMeasureRest(), MeasureRepeat(),Rollback(), InlineField(), UnusedChar()).label(Element);}
public int element(int i) throws InvalidRangeException {    if (i < 0)      throw new InvalidRangeException("i must be >= 0");    if (i >= length)      throw new InvalidRangeException("i must be < length");    return first + i * stride;  }
public JSONArray element( Collection value, JsonConfig jsonConfig ) {      if( value instanceof JSONArray ){         elements.add( value );         return this;      }else{         return element( _fromCollection( value, jsonConfig ) );      }   }
public JSONArray element( Map value, JsonConfig jsonConfig ) {      if( value instanceof JSONObject ){         elements.add( value );         return this;      }else{         return element( JSONObject.fromObject( value, jsonConfig ) );      }   }
public JSONArray element( String value, JsonConfig jsonConfig ) {      if( value == null ) {         this.elements.add("");      } else if( JSONUtils.hasQuotes( value )) {         this.elements.add(value);      } else if( JSONNull.getInstance().equals( value )) {         this.elements.add( JSONNull.getInstance() );      } else if( JSONUtils.isJsonKeyword(value,jsonConfig)) {         if( jsonConfig.isJavascriptCompliant() && "undefined".equals( value )){            this.elements.add( JSONNull.getInstance() );         }else{            this.elements.add(value);         }      } else if( JSONUtils.mayBeJSON( value ) ){         try{            this.elements.add( JSONSerializer.toJSON( value, jsonConfig ) );         }catch( JSONException jsone ){            this.elements.add( value );         }      } else {         this.elements.add(value);      }      return this;   }
public JSONArray element( double value ) {      Double d = new Double( value );      JSONUtils.testValidity( d );      return element( d );   }
public JSONArray element( int index, Collection value, JsonConfig jsonConfig ) {      if( value instanceof JSONArray ){         if( index < 0 ){            throw new JSONException( "JSONArray[" + index + "] not found." );         }         if( index < size() ){            elements.set( index, value );         }else{            while( index != size() ){               element( JSONNull.getInstance() );            }            element( value, jsonConfig );         }         return this;      }else{         return element( index, _fromCollection( value, jsonConfig ) );      }   }
public JSONArray element( int index, Map value, JsonConfig jsonConfig ) {      if( value instanceof JSONObject ){         if( index < 0 ){            throw new JSONException( "JSONArray[" + index + "] not found." );         }         if( index < size() ){            elements.set( index, value );         }else{            while( index != size() ){               element( JSONNull.getInstance() );            }            element( value, jsonConfig );         }         return this;      }else{         return element( index, JSONObject.fromObject( value, jsonConfig ) );      }   }

extract data from html content
public void addMetadataContent( org.jdom2.Element mdataJdomElement, Object contentObject )  {    // convert to JDOM element    //Element mdataJdomElement = builder.build( mdataElement );    ArrayList catGenConfigList = (ArrayList) contentObject;    Iterator iter = catGenConfigList.iterator();    while ( iter.hasNext())    {      CatalogGenConfig cgc = (CatalogGenConfig) iter.next();      mdataJdomElement.addContent( createCatGenConfigElement( cgc));    }  }
@NotNull    public final EnhancedMimeType getDataContentType() {        if (dataContentType == null) {            dataContentType = EnhancedMimeType.create(dataContentTypeStr);        }        return dataContentType;    }
public Object readMetadataContent(InvDataset dataset, org.jdom2.Element mdataElement) {    InvMetadata m = readMetadata(dataset.getParentCatalog(), (InvDatasetImpl) dataset, mdataElement);    return m.getThreddsMetadata();  }
public Object readMetadataContent( InvDataset dataset, org.jdom2.Element mdataElement )  {    log.debug( "readMetadataContent(): ." );    // convert to JDOM element    //Element mdataElement = builder.build( mdataDomElement );    return readMetadataContentJdom( dataset, mdataElement );  }
public String data() {        StringBuilder sb = new StringBuilder();        datas.forEach((k, v) -> sb.append("&").append(k).append("=").append(String.valueOf(v)));        return sb.toString().substring(1);    }
public String data(boolean useUrlencode, String charset) {        StringBuilder sb = new StringBuilder();        if (useUrlencode) {            datas.forEach((k, v) -> sb.append("&").append(k).append("=")                .append(urlencode(String.valueOf(v), charset)));        } else {            datas.forEach((k, v) -> sb.append("&").append(k).append("=").append(String.valueOf(v)));        }        return sb.toString().substring(1);    }
public String data() {        StringBuilder sb = StringUtil.borrowBuilder();        for (Node childNode : childNodes) {            if (childNode instanceof DataNode) {                DataNode data = (DataNode) childNode;                sb.append(data.getWholeData());            } else if (childNode instanceof Comment) {                Comment comment = (Comment) childNode;                sb.append(comment.getData());            } else if (childNode instanceof Element) {                Element element = (Element) childNode;                String elementData = element.data();                sb.append(elementData);            } else if (childNode instanceof CDataNode) {                // this shouldn't really happen because the html parser won't see the cdata as anything special when parsing script.                // but incase another type gets through.                CDataNode cDataNode = (CDataNode) childNode;                sb.append(cDataNode.getWholeText());            }        }        return StringUtil.releaseBuilder(sb);    }
Iterator<Row> data(IteratorType type) {    Iterator<Row> itr;    switch(type) {      case EXPECTED_DATA:        itr = data.getRows().iterator();        break;      case ERRORS_EXPECTED:        itr = delta.deleted();        break;      case ERRORS_ACTUAL:        itr = delta.inserted();        break;      default:        throw new InternalErrorException("Unexpected case!");          }    return itr;  }
@Override    public T data(Object... values) {        if (values == null || values.length == 0) {            return (T) this;        }        if (this.data == null) {            if (this.type == AxisType.category) {                data = new ArrayList<Object>();            } else {                throw new RuntimeException("数据轴不能添加类目信息!");            }        }        this.data.addAll(Arrays.asList(values));        return (T) this;    }
public byte []data()  {    ByteArrayOutputStream bos = new ByteArrayOutputStream();        try {      toData(bos);    } catch (IOException e) {      throw new RuntimeException(e);    }        return bos.toByteArray();  }

heatmap from 3d coordinates
public static FieldCoordinates coordinates(GraphQLFieldsContainer parentType, GraphQLFieldDefinition fieldDefinition) {        return new FieldCoordinates(parentType.getName(), fieldDefinition.getName());    }
public static FieldCoordinates coordinates(String parentType, String fieldName) {        assertValidName(parentType);        assertValidName(fieldName);        return new FieldCoordinates(parentType, fieldName);    }
public static Stream<MutableIntTuple> coordinates(        Order order, IntTuple arraySize)    {        if (order == Order.COLEXICOGRAPHICAL)        {            return colexicographicalCoordinates(arraySize);        }        return lexicographicalCoordinates(arraySize);    }
private boolean isCoordinate(Variable v) {    if (v == null) return false;    String name = v.getShortName();    return (latVE != null && latVE.axisName.equals(name)) ||            (lonVE != null && lonVE.axisName.equals(name)) ||            (altVE != null && altVE.axisName.equals(name)) ||            (stnAltVE != null && stnAltVE.axisName.equals(name)) ||            (timeVE != null && timeVE.axisName.equals(name)) ||            (nomTimeVE != null && nomTimeVE.axisName.equals(name));  }
public void setCoordinate(Coordinate coordinate) {if (coordinate == null) {throw new IllegalArgumentException("Can't snap to a null coordinate.");}this.coordinate = coordinate;bounds = new Bbox(coordinate.getX() - rule.getDistance(), coordinate.getY() - rule.getDistance(), rule.getDistance() * 2, rule.getDistance() * 2);distance = Double.MAX_VALUE;snappedCoordinate = coordinate;}
private LinkedHashMap<Integer, Coordinate> getCoordinate( int nStaz, SimpleFeatureCollection collection, String idField )            throws Exception {        LinkedHashMap<Integer, Coordinate> id2CoordinatesMap = new LinkedHashMap<Integer, Coordinate>();        FeatureIterator<SimpleFeature> iterator = collection.features();        Coordinate coordinate = null;        try {            while( iterator.hasNext() ) {                SimpleFeature feature = iterator.next();                int name = ((Number) feature.getAttribute(idField)).intValue();                coordinate = ((Geometry) feature.getDefaultGeometry()).getCentroid().getCoordinate();                double z = 0;                if (fPointZ != null) {                    try {                        z = ((Number) feature.getAttribute(fPointZ)).doubleValue();                    } catch (NullPointerException e) {                        pm.errorMessage(msg.message("kriging.noPointZ"));                        throw new Exception(msg.message("kriging.noPointZ"));                    }                }                coordinate.z = z;                id2CoordinatesMap.put(name, coordinate);            }        } finally {            iterator.close();        }        return id2CoordinatesMap;    }
public Coordinate getCoordinate(Geometry geometry) {LineString lineString = getLineString(geometry);if (lineString != null && coordinateIndex >= 0) {return lineString.getCoordinateN(coordinateIndex);}return null;}
public void addCoordinate(Coordinate coordinate) {Coordinate[] newCoords = new Coordinate[coordinates.length + 1];System.arraycopy(coordinates, 0, newCoords, 0, coordinates.length);newCoords[coordinates.length] = coordinate;setCoordinates(newCoords);}
@Override   @ManagedAttribute(description = "Indicates whether this node is coordinator", displayName = "Is coordinator?", displayType = DisplayType.SUMMARY)   public boolean isCoordinator() {      Transport t = getTransport();      return t != null && t.isCoordinator();   }
private List<Coordinate> getCoordinates(Geometry[] geometries) {List<Coordinate> coordinates = new ArrayList<Coordinate>();for (Geometry geometry : geometries) {addCoordinateArrays(geometry, coordinates);}return coordinates;}

get all parents of xml node
public DependencyTreeNode getNode(int position) {        if (position < 0 || position >= nodes.size())            throw new IndexOutOfBoundsException("Invalid node: " + position);        return nodes.get(position);    }
public Node getNode(final String name) {        if (name == null) {            return null;        }        for (final Node node : nodeList) {            if (name.equals(node.settings().get(NODE_NAME))) {                return node;            }        }        return null;    }
public Node getNode(final int i) {        if (i < 0 || i >= nodeList.size()) {            return null;        }        return nodeList.get(i);    }
public INode getNode(final INode node, String path) {final List<String> split = Strings.split(path, '/');INode result = node;for (String string : split) {String trimmed = string.trim();if (trimmed.length() > 0) {if ("..".equals(trimmed)) {if (result.getParent() == null)throw new IllegalStateException("node has no parent");result = result.getParent();} else {int index = Integer.parseInt(string);if (index >= 0) {INode child = ((ICompositeNode) result).getFirstChild();while(index > 0) {child = child.getNextSibling();index--;}result = child;}}}}return result;}
public int getNode(Source source)  {//    if (source instanceof DOMSource)//      return ((DOMSource) source).getNode();    // TODO: Not sure if the BaseID is really the same thing as the ID.    String url = source.getSystemId();    if (null == url)      return DTM.NULL;    int n = m_sourceTree.size();    // System.out.println("getNode: "+n);    for (int i = 0; i < n; i++)    {      SourceTree sTree = (SourceTree) m_sourceTree.elementAt(i);      // System.out.println("getNode -         url: "+url);      // System.out.println("getNode - sTree.m_url: "+sTree.m_url);      if (url.equals(sTree.m_url))        return sTree.m_root;    }    // System.out.println("getNode - returning: "+node);    return DTM.NULL;  }
public DependencyTreeNode getNode(int position) {        if (position < length - 1)            return original.getNode(position);        // Check that the request isn't for an invalid index        else if (position > length)            throw new IllegalArgumentException("invalid node: " + position);        else            return last();    }
private au.csiro.ontology.Node getNode(OWLClass oc) {        final Object id = getId(oc);        final au.csiro.ontology.Node n;        if(id instanceof String) {            n = getTaxonomy().getNode((String)id);        } else if(NamedConcept.TOP.equals(id)) {            n = getTaxonomy().getTopNode();        } else if(NamedConcept.BOTTOM.equals(id)) {            n = getTaxonomy().getBottomNode();        } else {            throw new RuntimeException("Unexpected id "+id);        }        return n;    }
public Node getNode(String id) throws NoResponseException, XMPPErrorException, NotConnectedException, InterruptedException, NotAPubSubNodeException {        Node node = nodeMap.get(id);        if (node == null) {            DiscoverInfo info = new DiscoverInfo();            info.setTo(pubSubService);            info.setNode(id);            DiscoverInfo infoReply = connection().createStanzaCollectorAndSend(info).nextResultOrThrow();            if (infoReply.hasIdentity(PubSub.ELEMENT, "leaf")) {                node = new LeafNode(this, id);            }            else if (infoReply.hasIdentity(PubSub.ELEMENT, "collection")) {                node = new CollectionNode(this, id);            }            else {                throw new PubSubException.NotAPubSubNodeException(id, infoReply);            }            nodeMap.put(id, node);        }        return node;    }
public Node getNode(int nodeHandle)  {    int identity = makeNodeIdentity(nodeHandle);    return (Node) m_nodes.elementAt(identity);  }
@CheckForNull    public Node getNode(String name) {        return name == null ? null : nodes.get(name);    }

how to extract zip file recursively
private static void zipFile(final File srcFile, final String destPath, final ZipOutputStream out) throws IOException {        final byte[] buf = new byte[1024];        try (final InputStream in = new BufferedInputStream(new FileInputStream(srcFile))) {            final ZipEntry zipEntry = new ZipEntry(concatPathAndFilename(destPath, srcFile.getName(), File.separator));            zipEntry.setTime(srcFile.lastModified());            out.putNextEntry(zipEntry);            int len;            while ((len = in.read(buf)) > 0) {                out.write(buf, 0, len);            }            out.closeEntry();        }    }
@SuppressWarnings({ "rawtypes", "unchecked" })    public static void zipFile(String folderToZip, String zipFile, String[] filesToInclude)        throws FileNotFoundException, IOException {        Logger logger = Logger.getLogger(Utils.class);        logger.debug("zipFile: "+folderToZip);        ZipOutputStream zipOut = new ZipOutputStream(new FileOutputStream(zipFile));            boolean excludeContainingFolder = false;        File srcFile = new File(folderToZip);        if(excludeContainingFolder && srcFile.isDirectory()) {            for(String fileName : srcFile.list()) {                addToZip("", folderToZip + "/" + fileName, zipOut, filesToInclude);            }        } else {            addToZip("", folderToZip, zipOut, filesToInclude);        }        zipOut.flush();        zipOut.close();        logger.debug("Successfully created zipFile: " + zipFile);    }
@SuppressWarnings("checkstyle:npathcomplexity")public static void zipFile(File input, OutputStream output) throws IOException {try (ZipOutputStream zos = new ZipOutputStream(output)) {if (input == null) {return;}final LinkedList<File> candidates = new LinkedList<>();candidates.add(input);final byte[] buffer = new byte[BUFFER_SIZE];int len;File file;File relativeFile;String zipFilename;final File rootDirectory = (input.isDirectory()) ? input : input.getParentFile();while (!candidates.isEmpty()) {file = candidates.removeFirst();assert file != null;if (file.getAbsoluteFile().equals(rootDirectory.getAbsoluteFile())) {relativeFile = null;} else {relativeFile = makeRelative(file, rootDirectory, false);}if (file.isDirectory()) {if (relativeFile != null) {zipFilename = fromFileStandardToURLStandard(relativeFile) + URL_PATH_SEPARATOR;final ZipEntry zipEntry = new ZipEntry(zipFilename);zos.putNextEntry(zipEntry);zos.closeEntry();}candidates.addAll(Arrays.asList(file.listFiles()));} else if (relativeFile != null) {try (FileInputStream fis = new FileInputStream(file)) {zipFilename = fromFileStandardToURLStandard(relativeFile);final ZipEntry zipEntry = new ZipEntry(zipFilename);zos.putNextEntry(zipEntry);while ((len = fis.read(buffer)) > 0) {zos.write(buffer, 0, len);}zos.closeEntry();}}}}}
public static void zipFile(File input, File output) throws IOException {try (FileOutputStream fos = new FileOutputStream(output)) {zipFile(input, fos);}}
public static final void zipFiles(String dirPath,String outFile,FileFilter filter) throws Exception{if(dirPath==null){throw new IllegalArgumentException("dir ==null");}File dir=new File(dirPath);if(dir.isFile()){throw new IllegalArgumentException("dir "+dir+" is not a dir");}if(!dir.exists()){throw new IllegalArgumentException("dir "+dir+" not found");}ZipOutputStream zos = new ZipOutputStream(new CheckedOutputStream(new FileOutputStream(outFile), new CRC32()));try {String rootDir=dir.getPath();Stack<File> dirs = new Stack<File>();dirs.push(dir);while (!dirs.isEmpty()) {File path = dirs.pop();File[] fs = path.listFiles(filter);for (File subFile : fs) {String subPath=subFile.getPath().replace(rootDir+File.separator,"");byte[] data=new byte[] {};if (subFile.isDirectory()) {//文件夹dirs.push(subFile);subPath+="/";}else{if(subFile.getPath().equals(new File(outFile).getPath())){continue;}data=Files.readAllBytes(Paths.get(subFile.getPath()));}System.out.println("添加压缩文件:"+subPath);ZipEntry entry = new ZipEntry(subPath);zos.putNextEntry(entry);zos.write(data);}}zos.flush();} finally {zos.close();}}
public static void zipFiles(List<File> files, OutputStream outputStream) throws IOException {        ZipOutputStream zos = new ZipOutputStream(outputStream);        for (File file : files) {            if (file.isDirectory()) {   //if it's a folder                addFolderToZip("", file, zos);            } else {                addFileToZip("", file, zos);            }        }        zos.finish();    }
public static void zipFiles(List<File> files, File zipFile) throws IOException {        OutputStream os = new BufferedOutputStream(new FileOutputStream(zipFile));        try {            zipFiles(files, os);        } finally {            IOUtils.closeQuietly(os);        }    }
public static boolean isZipFile(File zipFile) {    try {      ZipFile zf = new ZipFile(zipFile);      boolean isZip = zf.getEntries().hasMoreElements();      zf.close();      return isZip;    } catch (IOException e) {      return false;    }  }
String unzipFile(File downloadedCompressedFile, String extractedToFilePath, BinaryType possibleFilenames) throws IOException, ExpectedFileNotFoundException {        LOG.debug("Attempting to extract binary from .zip file...");        ArrayList<String> filenamesWeAreSearchingFor = new ArrayList<String>(possibleFilenames.getBinaryFilenames());        ZipFile zip = new ZipFile(downloadedCompressedFile);        try {            Enumeration<ZipArchiveEntry> zipFile = zip.getEntries();            if (filenamesWeAreSearchingFor.get(0).equals("*")) {                filenamesWeAreSearchingFor.remove(0);                LOG.debug("Extracting full archive");                return this.unzipFolder(zip, extractedToFilePath, filenamesWeAreSearchingFor);            } else {                while (zipFile.hasMoreElements()) {                    ZipArchiveEntry zipFileEntry = zipFile.nextElement();                    for (String aFilenameWeAreSearchingFor : filenamesWeAreSearchingFor) {                        if (zipFileEntry.getName().endsWith(aFilenameWeAreSearchingFor)) {                            LOG.debug("Found: " + zipFileEntry.getName());                            return copyFileToDisk(zip.getInputStream(zipFileEntry), extractedToFilePath, aFilenameWeAreSearchingFor);                        }                    }                }            }        } finally {            zip.close();        }        throw new ExpectedFileNotFoundException("Unable to find any expected files for " + possibleFilenames.getBinaryTypeAsString());    }
public static void unzipFile(InputStream input, File output) throws IOException {if (output == null) {return;}output.mkdirs();if (!output.isDirectory()) {throw new IOException(Locale.getString("E3", output)); //$NON-NLS-1$}try (ZipInputStream zis = new ZipInputStream(input)) {final byte[] buffer = new byte[BUFFER_SIZE];int len;ZipEntry zipEntry = zis.getNextEntry();while (zipEntry != null) {final String name = zipEntry.getName();final File outFile = new File(output, name).getCanonicalFile();if (zipEntry.isDirectory()) {outFile.mkdirs();} else {outFile.getParentFile().mkdirs();try (FileOutputStream fos = new FileOutputStream(outFile)) {while ((len = zis.read(buffer)) > 0) {fos.write(buffer, 0, len);}}}zipEntry = zis.getNextEntry();}}}

underline text in label widget
public String[] contextLabels(String primaryKey) {        // Get the mapping from primarykeys to context descriptors.        List<Assignment> primaryAssignments = assignmentMap.get(primaryKey);        // Return an empty array if one does not exist.        if (primaryAssignments == null)            return new String[0];        // Copy the label assignments for each context id recorded.  Here we        // assume that the largest_context_id == (#id's_recorded - 1).        String[] labels = new String[primaryAssignments.size()];        for (Assignment assignment : primaryAssignments)            labels[assignment.id] = assignment.key;        return labels;    }
@Override    public Set<String> getContextLabels() {        final Set<String> labels = new HashSet<>();        for (final Pair<String, Object> pair : contextValues) {            labels.add(pair.getKey());        }        return labels;    }
public void text(String openId, String text, String from) {        Map<String, Object> request = initMessage(openId, "text", from);        request.put("text", new Text(text));        String url = WxEndpoint.get("url.care.message.send");        wxClient.post(url, JsonMapper.defaultMapper().toJson(request));    }
public String text() {        String previousText = null;        StringBuilder buffer = null;        for (Object child : this) {            String text = null;            if (child instanceof String) {                text = (String) child;            } else if (child instanceof Node) {                text = ((Node) child).text();            }            if (text != null) {                if (previousText == null) {                    previousText = text;                } else {                    if (buffer == null) {                        buffer = new StringBuilder();                        buffer.append(previousText);                    }                    buffer.append(text);                }            }        }        if (buffer != null) {            return buffer.toString();        }        if (previousText != null) {            return previousText;        }        return "";    }
public List<String> text(String content, String selector) {Element body = parseContent(content);List<Element> elements = body.select(selector);List<String> texts = new ArrayList<String>();for (Element element : elements) {texts.add(element.text());}return texts;}
public String text() {        final StringBuilder sb = new StringBuilder();        for (Object child : this.children) {            if (child instanceof Node) {                sb.append(((Node) child).text());            } else {                sb.append(child);            }        }        return sb.toString();    }
public String text() {        if (value instanceof String) {            return (String) value;        }        if (value instanceof NodeList) {            return ((NodeList) value).text();        }        if (value instanceof Collection) {            Collection coll = (Collection) value;            String previousText = null;            StringBuilder sb = null;            for (Object child : coll) {                String childText = null;                if (child instanceof String) {                    childText = (String) child;                } else if (child instanceof Node) {                    childText = ((Node) child).text();                }                if (childText != null) {                    if (previousText == null) {                        previousText = childText;                    } else {                        if (sb == null) {                            sb = new StringBuilder();                            sb.append(previousText);                        }                        sb.append(childText);                    }                }            }            if (sb != null) {                return sb.toString();            } else {                if (previousText != null) {                    return previousText;                }                return "";            }        }        return "" + value;    }
public QRSCT text(String text) {if (text != null && text.length() <= 140) {this.reference = ""; //$NON-NLS-1$this.text = checkValidSigns(text);return this;}throw new IllegalArgumentException("supplied text [" + text //$NON-NLS-1$+ "] not valid: has to be not null and of max length 140"); //$NON-NLS-1$}
@Override    public String text( Locale locale,                        Object... arguments ) {        try {            String rawText = rawText(locale == null ? Locale.getDefault() : locale);            return StringUtil.createString(rawText, arguments);        } catch (IllegalArgumentException err) {            throw new IllegalArgumentException(CommonI18n.i18nRequiredToSuppliedParameterMismatch.text(id,                                                                                                       i18nClass,                                                                                                       err.getMessage()));        } catch (SystemFailureException err) {            return '<' + err.getMessage() + '>';        }    }
public long text(List<String> openIds, String text) {return send(new Filter(false, null), openIds, "text", text);}

unzipping large files
String unzipFile(File downloadedCompressedFile, String extractedToFilePath, BinaryType possibleFilenames) throws IOException, ExpectedFileNotFoundException {        LOG.debug("Attempting to extract binary from .zip file...");        ArrayList<String> filenamesWeAreSearchingFor = new ArrayList<String>(possibleFilenames.getBinaryFilenames());        ZipFile zip = new ZipFile(downloadedCompressedFile);        try {            Enumeration<ZipArchiveEntry> zipFile = zip.getEntries();            if (filenamesWeAreSearchingFor.get(0).equals("*")) {                filenamesWeAreSearchingFor.remove(0);                LOG.debug("Extracting full archive");                return this.unzipFolder(zip, extractedToFilePath, filenamesWeAreSearchingFor);            } else {                while (zipFile.hasMoreElements()) {                    ZipArchiveEntry zipFileEntry = zipFile.nextElement();                    for (String aFilenameWeAreSearchingFor : filenamesWeAreSearchingFor) {                        if (zipFileEntry.getName().endsWith(aFilenameWeAreSearchingFor)) {                            LOG.debug("Found: " + zipFileEntry.getName());                            return copyFileToDisk(zip.getInputStream(zipFileEntry), extractedToFilePath, aFilenameWeAreSearchingFor);                        }                    }                }            }        } finally {            zip.close();        }        throw new ExpectedFileNotFoundException("Unable to find any expected files for " + possibleFilenames.getBinaryTypeAsString());    }
public static void unzipFile(InputStream input, File output) throws IOException {if (output == null) {return;}output.mkdirs();if (!output.isDirectory()) {throw new IOException(Locale.getString("E3", output)); //$NON-NLS-1$}try (ZipInputStream zis = new ZipInputStream(input)) {final byte[] buffer = new byte[BUFFER_SIZE];int len;ZipEntry zipEntry = zis.getNextEntry();while (zipEntry != null) {final String name = zipEntry.getName();final File outFile = new File(output, name).getCanonicalFile();if (zipEntry.isDirectory()) {outFile.mkdirs();} else {outFile.getParentFile().mkdirs();try (FileOutputStream fos = new FileOutputStream(outFile)) {while ((len = zis.read(buffer)) > 0) {fos.write(buffer, 0, len);}}}zipEntry = zis.getNextEntry();}}}
public static void unzipFile(File input, File output) throws IOException {try (FileInputStream fis = new FileInputStream(input)) {unzipFile(fis, output);}}
public static void unZipFiles(File zipFile, File outputFolder) throws IOException {        InputStream is = new BufferedInputStream(new FileInputStream(zipFile));        try {            unZipFiles(is, outputFolder);        } finally {            IOUtils.closeQuietly(is);        }    }
public static void unZipFiles(InputStream inputStream, File outputFolder) throws IOException {        ZipInputStream zis = new ZipInputStream(inputStream);        ZipEntry ze = zis.getNextEntry();        while (ze != null) {            File file = new File(outputFolder, ze.getName());            OutputStream os = new BufferedOutputStream(FileUtils.openOutputStream(file));            try {                IOUtils.copy(zis, os);            } finally {                IOUtils.closeQuietly(os);            }            zis.closeEntry();            ze = zis.getNextEntry();        }    }
public static File unzipUniqueFile(File inFile) throws IOException {        File outFile = File.createTempFile(inFile.getName(), "tmp");        try {            BufferedOutputStream out = null;            ZipInputStream in = new ZipInputStream(new BufferedInputStream(                    new FileInputStream(inFile)));            in.getNextEntry();            int count;            byte data[] = new byte[1024];            out = new BufferedOutputStream(new FileOutputStream(outFile), 1024);            while ((count = in.read(data, 0, 1024)) != -1) {                out.write(data, 0, count);            }            out.flush();            out.close();            in.close();        } catch (Exception e) {            e.printStackTrace();        }        return outFile;    }
public static boolean unzipFileOrFolder(File zipFile, String unzippedFolder){InputStream is;ArchiveInputStream in = null;OutputStream out  = null;if(!zipFile.isFile()){return false;}if(unzippedFolder == null){unzippedFolder = FilenameUtils.removeExtension(zipFile.getAbsolutePath());}try {is = new FileInputStream(zipFile);new File(unzippedFolder).mkdir();in = new ArchiveStreamFactory().createArchiveInputStream(ArchiveStreamFactory.ZIP, is);ZipArchiveEntry entry = (ZipArchiveEntry)in.getNextEntry();while(entry != null){if(entry.isDirectory()){new File(unzippedFolder,entry.getName()).mkdir();}else{out = new FileOutputStream(new File(unzippedFolder, entry.getName()));IOUtils.copy(in, out);out.close();out = null;}entry = (ZipArchiveEntry)in.getNextEntry();}} catch (FileNotFoundException e) {e.printStackTrace();return false;} catch (ArchiveException e) {e.printStackTrace();return false;} catch (IOException e) {e.printStackTrace();return false;}finally{if(out != null){try {out.close();} catch (IOException e) {}}if(in != null){try {in.close();} catch (IOException e) {}}}return true;}
public Table file(File file) throws IOException {String extension = Files.getFileExtension(file.getCanonicalPath());DataReader<?> reader = registry.getReaderForExtension(extension);return reader.read(new Source(file));    }
@Deprecated    public WaitFileConditionBuilder file(String filePath) {        FileCondition condition = new FileCondition();        condition.setFilePath(filePath);        container.setCondition(condition);        this.buildAndRun();        return new WaitFileConditionBuilder(condition, this);    }
@Deprecated    public WaitFileConditionBuilder file(File file) {        FileCondition condition = new FileCondition();        condition.setFile(file);        container.setCondition(condition);        this.buildAndRun();        return new WaitFileConditionBuilder(condition, this);    }

copying a file to a path
public boolean addCopiedFile(File sourceFilePath, File destinationFilePath, int percentage) {    if (null == sourceFilePath || null == destinationFilePath) {      return false;    }    return copiedFiles.add(new CopiedOrMovedFile(sourceFilePath, destinationFilePath, percentage));  }
public Table file(File file) throws IOException {String extension = Files.getFileExtension(file.getCanonicalPath());DataReader<?> reader = registry.getReaderForExtension(extension);return reader.read(new Source(file));    }
@Deprecated    public WaitFileConditionBuilder file(String filePath) {        FileCondition condition = new FileCondition();        condition.setFilePath(filePath);        container.setCondition(condition);        this.buildAndRun();        return new WaitFileConditionBuilder(condition, this);    }
@Deprecated    public WaitFileConditionBuilder file(File file) {        FileCondition condition = new FileCondition();        condition.setFile(file);        container.setCondition(condition);        this.buildAndRun();        return new WaitFileConditionBuilder(condition, this);    }
public WaitFileConditionBuilder file() {        FileCondition condition = new FileCondition();        container.setCondition(condition);        return new WaitFileConditionBuilder(condition, this);    }
public void file(final String fileName) throws Exception {        String in = thisDir.getAbsolutePath();        File out = outDir.getAbsoluteFile();        //noinspection ResultOfMethodCallIgnored        out.mkdirs();        File inputFile = dirHelper.rel2abs(in, fileName);        File outputFile = dirHelper.subdir(out, inputFile.getName());        Counts result = runner.run(inputFile, outputFile);        appendResults(row, inputFile.getName(), result);        row.getTable().getCounts().tally(result);    }
@Deprecated    public static Part<InputStream> file(String name, String fileName, InputStream in) {        return new Part<>(name, fileName, in, CONTENT_TYPE_BINARY, null, (body, out, charset) -> {            try (InputStream bin = body) {                InputStreams.transferTo(bin, out);            }        });    }
public static Part<File> file(String name, File file) {        return file(name, file.getName(), file);    }
public static Part<InputStreamSupplier> file(String name, String fileName, InputStreamSupplier supplier) {        return new Part<>(name, fileName, supplier, CONTENT_TYPE_BINARY, null, (body, out, charset) -> {            try (InputStream bin = body.get()) {                InputStreams.transferTo(bin, out);            }        });    }
public static Part<byte[]> file(String name, String fileName, byte[] bytes) {        return new Part<>(name, fileName, bytes, CONTENT_TYPE_BINARY, null, (body, out, charset) -> out.write(body));    }

get the description of a http status code
public static Predicate<? super Throwable> statusCode(int... codes) {        return t -> t instanceof ClientV2Exception &&            Arrays.stream(codes).anyMatch(candidate -> ((ClientV2Exception) t).getCode().equals(candidate));    }
public int statusCode() {    return status().entrySet().stream()        .map(it -> it.getKey())        .filter(code -> code >= 200 && code < 400)        .findFirst()        .orElseGet(() -> type() == void.class ? 204 : 200);  }
private int getStatusCode(@Nullable final byte[] response, final int request)throws UnknownResponseException {if (response == null || response.length != 3 || response[0] != OP_CODE_RESPONSE_CODE_KEY ||response[1] != request || response[2] < 1 || response[2] > 6)throw new UnknownResponseException("Invalid response received", response, OP_CODE_RESPONSE_CODE_KEY, request);return response[2];}
@SuppressWarnings("SameParameterValue")private int getStatusCode(final byte[] response, final int request) throws UnknownResponseException {if (response == null || response.length < 3 || response[0] != OP_CODE_RESPONSE_CODE_KEY || response[1] != request ||(response[2] != DFU_STATUS_SUCCESS && response[2] != SecureDfuError.BUTTONLESS_ERROR_OP_CODE_NOT_SUPPORTED                        && response[2] != SecureDfuError.BUTTONLESS_ERROR_OPERATION_FAILED))throw new UnknownResponseException("Invalid response received", response, OP_CODE_RESPONSE_CODE_KEY, request);return response[2];}
private int getStatusCode(final byte[] response, final int request) throws UnknownResponseException {if (response == null || response.length < 3 || response[0] != OP_CODE_RESPONSE_CODE_KEY || response[1] != request ||(response[2] != DFU_STATUS_SUCCESS &&response[2] != SecureDfuError.OP_CODE_NOT_SUPPORTED &&response[2] != SecureDfuError.INVALID_PARAM &&response[2] != SecureDfuError.INSUFFICIENT_RESOURCES &&response[2] != SecureDfuError.INVALID_OBJECT &&response[2] != SecureDfuError.UNSUPPORTED_TYPE &&response[2] != SecureDfuError.OPERATION_NOT_PERMITTED &&response[2] != SecureDfuError.OPERATION_FAILED &&response[2] != SecureDfuError.EXTENDED_ERROR))throw new UnknownResponseException("Invalid response received", response, OP_CODE_RESPONSE_CODE_KEY, request);return response[2];}
public int getStatusCode() {        int code;        /* TODO: eine Exception als Fehler einzustufen ist gefaehrlich: wenn         * ein GV bei einer Bank eingereicht wird und von der Bank erfolgreich         * verarbeitet wird, beim Entgegennehmen der Antwort-Nachricht jedoch         * eine Exception auftritt, sieht der Job aus wie "fehlgeschlagen" -         * dabei ist nur das Parsen der Erfolgsnachricht fehlgeschlagen */        if (hasExceptions() || hasErrors()) {            code = STATUS_ERR;        } else if (hasSuccess() || hasWarnings()) {            code = STATUS_OK;        } else {            code = STATUS_UNKNOWN;        }        return code;    }
private String getStatusCode(DecisionType decision) {        if (fXACMLParsingError) {            return STATUS_CODE_SYNTAX_ERROR;        } else if (fProcessingError) {            return STATUS_CODE_PROCESSING_ERROR;        } else if (decision == DecisionType.Deny ||                decision == DecisionType.Permit) {            return STATUS_CODE_OK;        } else if (decision == DecisionType.Indeterminate ||                decision == DecisionType.Indeterminate_D ||                decision == DecisionType.Indeterminate_P ||                decision == DecisionType.Indeterminate_DP) {            return STATUS_CODE_MISSING_ATTRIBUTE;        } else {            logger.debug("Unknown status code decision");            return STATUS_CODE_PROCESSING_ERROR;        }    }
public HttpStatus getStatusCode() {        final Object statusCode = getHeader(HttpMessageHeaders.HTTP_STATUS_CODE);        if (statusCode != null) {            if (statusCode instanceof HttpStatus) {                return (HttpStatus) statusCode;            } else if (statusCode instanceof Integer) {                return HttpStatus.valueOf((Integer) statusCode);            } else {                return HttpStatus.valueOf(Integer.valueOf(statusCode.toString()));            }        }        return null;    }
public static HttpStatus fromStatusCode(final int statusCode){if (statusCode < 100 || statusCode > 999){throw new IllegalArgumentException("Illegal status code " + statusCode);}HttpStatus result = STATUS_CODES.get(statusCode);if (result == null){return new HttpStatus(statusCode, "Unknown");}return result;}
private boolean isStatusCodeOK(Response response, String uri) {if (response.getStatus() == Status.OK.getStatusCode()|| response.getStatus() == Status.CREATED.getStatusCode()) {return true;} else if (response.getStatus() == Status.UNAUTHORIZED.getStatusCode()) {throw new NotAuthorizedException("UNAUTHORIZED: Your credentials are wrong. "+ "Please check your username/password or the secret key.", response);} else if (response.getStatus() == Status.CONFLICT.getStatusCode()|| response.getStatus() == Status.NOT_FOUND.getStatusCode()|| response.getStatus() == Status.FORBIDDEN.getStatusCode()|| response.getStatus() == Status.BAD_REQUEST.getStatusCode()) {ErrorResponse errorResponse = response.readEntity(ErrorResponse.class);throw new ClientErrorException(errorResponse.toString(), response);} else {throw new WebApplicationException("Unsupported status", response);}}

randomly extract x items from a list
@SuppressWarnings("unchecked")    public static List<HasMetadata> toItemList(Object entity) throws IOException {        if (entity instanceof List) {            return (List<HasMetadata>) entity;        } else if (entity instanceof HasMetadata[]) {            HasMetadata[] array = (HasMetadata[]) entity;            return Arrays.asList(array);        } else if (entity instanceof KubernetesList) {            KubernetesList config = (KubernetesList) entity;            return config.getItems();        } else if (entity instanceof Template) {            Template objects = (Template) entity;            return objects.getObjects();        } else {            List<HasMetadata> answer = new ArrayList<>();            if (entity instanceof HasMetadata) {                answer.add((HasMetadata) entity);            }            return answer;        }    }
public FSArray getItemList() {    if (List_Type.featOkTst && ((List_Type)jcasType).casFeat_itemList == null)      jcasType.jcas.throwFeatMissing("itemList", "de.julielab.jules.types.List");    return (FSArray)(jcasType.ll_cas.ll_getFSForRef(jcasType.ll_cas.ll_getRefValue(addr, ((List_Type)jcasType).casFeatCode_itemList)));}
public void setItemList(FSArray v) {    if (List_Type.featOkTst && ((List_Type)jcasType).casFeat_itemList == null)      jcasType.jcas.throwFeatMissing("itemList", "de.julielab.jules.types.List");    jcasType.ll_cas.ll_setRefValue(addr, ((List_Type)jcasType).casFeatCode_itemList, jcasType.ll_cas.ll_getFSRef(v));}
public ListItem getItemList(int i) {    if (List_Type.featOkTst && ((List_Type)jcasType).casFeat_itemList == null)      jcasType.jcas.throwFeatMissing("itemList", "de.julielab.jules.types.List");    jcasType.jcas.checkArrayBounds(jcasType.ll_cas.ll_getRefValue(addr, ((List_Type)jcasType).casFeatCode_itemList), i);    return (ListItem)(jcasType.ll_cas.ll_getFSForRef(jcasType.ll_cas.ll_getRefArrayValue(jcasType.ll_cas.ll_getRefValue(addr, ((List_Type)jcasType).casFeatCode_itemList), i)));}
public void setItemList(int i, ListItem v) {     if (List_Type.featOkTst && ((List_Type)jcasType).casFeat_itemList == null)      jcasType.jcas.throwFeatMissing("itemList", "de.julielab.jules.types.List");    jcasType.jcas.checkArrayBounds(jcasType.ll_cas.ll_getRefValue(addr, ((List_Type)jcasType).casFeatCode_itemList), i);    jcasType.ll_cas.ll_setRefArrayValue(jcasType.ll_cas.ll_getRefValue(addr, ((List_Type)jcasType).casFeatCode_itemList), i, jcasType.ll_cas.ll_getFSRef(v));}
public FacetBuilder setItemsList(Map<String, String> items) {        ArrayList<FacetWidgetItem> facetWidgetItems = new ArrayList<FacetWidgetItem>();        for (String key : items.keySet()){            String label = items.get(key);            FacetWidgetItem facetWidgetItem = new FacetWidgetItem(key, label);            facetWidgetItems.add(facetWidgetItem);        }        this.listItems = facetWidgetItems;        return this;    }
public StatusCode addItemToList(String sessionId, String listId, Integer mediaId) throws MovieDbException {        return tmdbList.addItem(sessionId, listId, mediaId);    }
public static List<Item> loadAsItemList(String path)    {        List<Item> itemList = new LinkedList<Item>();        try        {            BufferedReader br = new BufferedReader(new InputStreamReader(IOAdapter == null ? new FileInputStream(path) :                                                                                 IOAdapter.open(path), "UTF-8"));            String line;            while ((line = br.readLine()) != null)            {                Item item = Item.create(line);                if (item == null)                {                    logger.warning("使用【" + line + "】创建Item失败");                    return null;//                    continue;                }                itemList.add(item);            }        }        catch (Exception e)        {            logger.warning("读取词典" + path + "发生异常" + e);            return null;        }        return itemList;    }
public static ItemRuleList toItemRuleList(List<ItemParameters> itemParametersList) throws IllegalRuleException {        ItemRuleList itemRuleList = new ItemRuleList();        for (ItemParameters parameters : itemParametersList) {            itemRuleList.add(ItemRule.toItemRule(parameters));        }        return itemRuleList;    }
@Overridepublic List<BundlePath> getItemPathList(Map<String, String> variants) {return getItemPathList(bundlePathMapping.getItemPathList(), variants);}

convert a date string into yyyymmdd
private static void convertDateString(String str) {        try {            Date date = Utils.dateFromString(str);            display("Date to millis: " + date.getTime());        } catch (Exception e) {        }    }
public String convertDateToString(final Date date) {        if (date == null) {            return null;        }        return dateFormat.get().format(date);    }
public static String convertDateToString(Date date, boolean millis) {if (date == null) {return null;} else {DateTimeFormatter df;if (millis) {// df = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'");df = FORMATTER_MILLISECONDS_T_Z;} else {// df = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'");df = FORMATTER_SECONDS_T_Z;}return df.print(date.getTime());}}
public static String convertDateToXSDString(Date date) {if (date == null) {return null;}String dateTime = convertDateToString(date, true);if (date.before(ONE_CE)) {// fix the format for lexical representation of the year// e.g. 1 BCE: 0000-01.01 (1BCE is year 0)int pos = dateTime.indexOf('-', 1);int year = Integer.parseInt(dateTime.substring(0, pos));if (year == -1) {dateTime = "0000" + dateTime.substring(pos);} else if (year < 0) {year += 1;String prefix = "";if (year > -10) {prefix = "000";} else if (year > -100) {prefix = "00";} else if (year > -1000) {prefix = "0";}dateTime = "-" + prefix + Math.abs(year)+ dateTime.substring(pos);}}// fix the format for the lexical representation of the milliseconds,// no leading 0s are allowed, and if it's all zeros it has to be// removed.int posDot = dateTime.indexOf('.');int posZ = dateTime.indexOf('Z');int millis = Integer.parseInt(dateTime.substring(posDot + 1, posZ));String milliString;if (millis == 0) {milliString = "";} else if (millis < 10) {milliString = ".00" + millis;} else if (millis < 100) {milliString = ".0" + millis;} else {milliString = "." + millis;}while (milliString.length() > 0&& milliString.charAt(milliString.length() - 1) == '0') {milliString = milliString.substring(0, milliString.length() - 1);}dateTime = dateTime.substring(0, posDot) + milliString + "Z";return dateTime;}
public static String convertDateToDateString(Date date) {if (date == null) {return null;} else {// DateFormat df = new SimpleDateFormat("yyyy-MM-dd'Z'");DateTimeFormatter df = FORMATTER_DATE_Z;return df.print(date.getTime());}}
public static String convertDateToTimeString(Date date) {if (date == null) {return null;} else {// DateFormat df = new SimpleDateFormat("HH:mm:ss.SSS'Z'");DateTimeFormatter df = FORMATTER_SECONDS_Z;return df.print(date.getTime());}}
public synchronized static String convertToAgmipDateString(Date date) {        if (date != null) {            return dateFormatter.format(date);        } else {            return null;        }    }
public synchronized static Date convertFromAgmipDateString(String agmipDate) {        try {            return dateFormatter.parse(agmipDate);        } catch (Exception ex) {            return null;        }    }
private static String convertDateElementToString(Date currentDate, SimpleDateFormat dateFormat) {        return currentDate.getTime() != 0 ? dateFormat.format(currentDate.getTime()) : "";    }
@Override    public Calendar convertDateStringToCalendar(String dateStr) {        Calendar calendar = null;        if (dateStr != null) {            calendar = Calendar.getInstance();            calendar.set(Integer.parseInt(dateStr.substring(6, 10)), Integer.parseInt(dateStr.substring(0, 2)) - 1,                    Integer.parseInt(dateStr.substring(3, 5)));        }        return calendar;    }

convert a utc time to epoch
private String convertTime(final long time) {    final Date date = new Date(time);    return FORMAT.format(date);  }
private static int convertTimestamp(String timestamp) throws ParseException {        // Get the deadline from timestamp        int deadline;        SimpleDateFormat dateFormat = new SimpleDateFormat("hh:mm:ss");        Date parsedDate;        // Relative timestamp        if (timestamp.startsWith("+")) {            parsedDate = dateFormat.parse(timestamp.replace("+", ""));            Calendar c = Calendar.getInstance();            c.setTime(parsedDate);            deadline = c.get(Calendar.SECOND) + c.get(Calendar.MINUTE) * 60 + c.get(Calendar.HOUR_OF_DAY) * 3600;        }        // Absolute timestamp        else {            Calendar c = Calendar.getInstance();            c.setTime(new Date());            Date now = dateFormat.parse(c.get(Calendar.HOUR_OF_DAY)+":"+c.get(Calendar.MINUTE)+":"+c.get(Calendar.SECOND));            parsedDate = dateFormat.parse(timestamp);            deadline = (int) ((parsedDate.getTime() - now.getTime()) / 1000);            if (deadline < 0) {                // Timestamp is for tomorrow                deadline = (int) ((parsedDate.getTime() + (24 * 3600 * 1000) - now.getTime()) / 1000);            }        }        return deadline;    }
protected long convertTimestamp(String timestamp) {        long value = 0;        // try to parse the time stamp string        // if it successes, its an old style long value        try {            value = Long.parseLong(timestamp);        } catch (NumberFormatException e) {            // the time stamp was in in a user-readable string format, create the long value form it            try {                value = CmsDateUtil.parseHeaderDate(timestamp);            } catch (ParseException pe) {                value = System.currentTimeMillis();            }        }        return value;    }
@VisibleForTesting  static Timestamp convertTimestamp(io.opencensus.common.Timestamp censusTimestamp) {    if (censusTimestamp.getSeconds() < 0) {      // StackDriver doesn't handle negative timestamps.      return Timestamp.newBuilder().build();    }    return Timestamp.newBuilder()        .setSeconds(censusTimestamp.getSeconds())        .setNanos(censusTimestamp.getNanos())        .build();  }
@Deprecated    protected static ValidationBuilder convertTimestamp(String attributeName, String format){        return ModelDelegate.convertTimestamp(modelClass(), attributeName, format);    }
public static Time convertDateToTime(Date date, Time elseValue) {        return Checker.isNull(date) ? elseValue : new Time(date.getTime());    }
public static Date convertTimeToDate(Date time)    {        if (time != null)        {            DataConverters.initGlobals();            Calendar calendar = DataConverters.gCalendar;            calendar.setTime(time);            calendar.set(Calendar.HOUR_OF_DAY, 0);            calendar.set(Calendar.MINUTE, 0);            calendar.set(Calendar.SECOND, 0);            calendar.set(Calendar.MILLISECOND, 0);            time = calendar.getTime();        }               return time;    }
public static int convertExpiryTime(int original) {        if (original == 0) {            return original;        } else if (original > THIRTY_DAYS) {            return original + (int)Info.getClockOffset();        }        return (int)((new Date().getTime() / 1000) + original + Info.getClockOffset());    }
private FileTime convertDateToFileTime(String strDate) {        FileTime time = null;        if (null != strDate) {            Date date = null;            try {                date = DateUtil.convertToDate(strDate,                                              DateUtil.DateFormat.LONG_FORMAT);            } catch (ParseException e) {                date = null;            }            if (null != date) {                time = FileTime.fromMillis(date.getTime());            }        }        return time;    }
public static Timestamp convertDateToTimestamp(Date date, Timestamp elseValue) {        return Checker.isNull(date) ? elseValue : new Timestamp(date.getTime());    }

all permutations of a list
static <T> List<T> list(T... elements) {    return new ArrayList<>(Arrays.asList(elements));  }
private List<UnitFactor> list(UnitFactor factor) {    List<UnitFactor> list = new ArrayList<>();    list.add(factor);    return list;  }
public PagedList<LabInner> list(final String resourceGroupName, final String labAccountName) {        ServiceResponse<Page<LabInner>> response = listSinglePageAsync(resourceGroupName, labAccountName).toBlocking().single();        return new PagedList<LabInner>(response.body()) {            @Override            public Page<LabInner> nextPage(String nextPageLink) {                return listNextSinglePageAsync(nextPageLink).toBlocking().single().body();            }        };    }
public PagedList<SecurityRuleInner> list(final String resourceGroupName, final String networkSecurityGroupName) {        ServiceResponse<Page<SecurityRuleInner>> response = listSinglePageAsync(resourceGroupName, networkSecurityGroupName).toBlocking().single();        return new PagedList<SecurityRuleInner>(response.body()) {            @Override            public Page<SecurityRuleInner> nextPage(String nextPageLink) {                return listNextSinglePageAsync(nextPageLink).toBlocking().single().body();            }        };    }
public PagedList<AgentPoolInner> list(final String resourceGroupName, final String managedClusterName) {        ServiceResponse<Page<AgentPoolInner>> response = listSinglePageAsync(resourceGroupName, managedClusterName).toBlocking().single();        return new PagedList<AgentPoolInner>(response.body()) {            @Override            public Page<AgentPoolInner> nextPage(String nextPageLink) {                return listNextSinglePageAsync(nextPageLink).toBlocking().single().body();            }        };    }
public PagedList<ProjectTaskInner> list(final String groupName, final String serviceName, final String projectName) {        ServiceResponse<Page<ProjectTaskInner>> response = listSinglePageAsync(groupName, serviceName, projectName).toBlocking().single();        return new PagedList<ProjectTaskInner>(response.body()) {            @Override            public Page<ProjectTaskInner> nextPage(String nextPageLink) {                return listNextSinglePageAsync(nextPageLink).toBlocking().single().body();            }        };    }
public PagedList<DataLakeAnalyticsAccountInner> list(final String filter, final Integer top, final Integer skip, final String expand, final String select, final String orderby, final Boolean count, final String search, final String format) {        ServiceResponse<Page<DataLakeAnalyticsAccountInner>> response = listSinglePageAsync(filter, top, skip, expand, select, orderby, count, search, format).toBlocking().single();        return new PagedList<DataLakeAnalyticsAccountInner>(response.body()) {            @Override            public Page<DataLakeAnalyticsAccountInner> nextPage(String nextPageLink) {                return listNextSinglePageAsync(nextPageLink).toBlocking().single().body();            }        };    }
public PagedList<DataLakeAnalyticsAccountBasicInner> list(final String filter, final Integer top, final Integer skip, final String select, final String orderby, final Boolean count) {        ServiceResponse<Page<DataLakeAnalyticsAccountBasicInner>> response = listSinglePageAsync(filter, top, skip, select, orderby, count).toBlocking().single();        return new PagedList<DataLakeAnalyticsAccountBasicInner>(response.body()) {            @Override            public Page<DataLakeAnalyticsAccountBasicInner> nextPage(String nextPageLink) {                return listNextSinglePageAsync(nextPageLink).toBlocking().single().body();            }        };    }
public static <A> List<A> list(A... elements) {        final List<A> list = new ArrayList<A>(elements.length);        for (A element : elements) {            list.add(element);        }        return list;    }
public PagedList<EndpointServiceResultInner> list(final String location) {        ServiceResponse<Page<EndpointServiceResultInner>> response = listSinglePageAsync(location).toBlocking().single();        return new PagedList<EndpointServiceResultInner>(response.body()) {            @Override            public Page<EndpointServiceResultInner> nextPage(String nextPageLink) {                return listNextSinglePageAsync(nextPageLink).toBlocking().single().body();            }        };    }

extract latitude and longitude from given input
public boolean input() {        boolean isInput = false;        try {            WebElement webElement = element.getWebElement();            if ("input".equalsIgnoreCase(webElement.getTagName()) ||                    "textarea".equalsIgnoreCase(webElement.getTagName()) ||                    SELECT.equalsIgnoreCase(webElement.getTagName())) {                isInput = true;            }        } catch (NoSuchElementException e) {            log.info(e);        }        return isInput;    }
public HTMLGen input(String id, String label, boolean required, String ... attrs) {Mark mtr = new Mark(TR);Mark mtd = new Mark(TD);incr(mtr);incr(mtd);incr("label",true, "for="+id,required?"required":null).text(label).end();end(mtd);String nattrs[] = new String[attrs.length+(required?3:2)];nattrs[0]="id="+id;nattrs[1]="name="+id;System.arraycopy(attrs, 0, nattrs, 2, attrs.length);if(required) {nattrs[nattrs.length-1]="required";}incr(mtd);tagOnly("input",nattrs);end(mtr);return this;}
public FileMetaData input(int which, int i)    {        checkArgument(which == 0 || which == 1, "which must be either 0 or 1");        if (which == 0) {            return levelInputs.get(i);        }        else {            return levelUpInputs.get(i);        }    }
public static HtmlTree INPUT(String type, String id) {        HtmlTree htmltree = new HtmlTree(HtmlTag.INPUT);        htmltree.addAttr(HtmlAttr.TYPE, nullCheck(type));        htmltree.addAttr(HtmlAttr.ID, nullCheck(id));        htmltree.addAttr(HtmlAttr.VALUE, " ");        htmltree.addAttr(HtmlAttr.DISABLED, "disabled");        return htmltree;    }
public FDistort input( ImageBase input ) {if( this.input == null || this.input.width != input.width || this.input.height != input.height ) {distorter = null;}this.input = input;inputType = input.getImageType();return this;}
public List<String> inputs() {        List<String> out = new ArrayList<>();        for(String s : variables.keySet()){            if(isPlaceHolder(s))                out.add(s);        }        return out;    }
@Override    public File inputrc() {        if(inputrc == null) {            inputrc = new File(System.getProperty("user.home")+Config.getPathSeparator()+".inputrc");        }        return inputrc;    }
public static boolean isInput(GraphQLType type) {        GraphQLUnmodifiedType unmodifiedType = unwrapAll(type);        return                unmodifiedType instanceof GraphQLScalarType                        || unmodifiedType instanceof GraphQLEnumType                        || unmodifiedType instanceof GraphQLInputObjectType;    }
private static InputStream inputFor( File file)    {    try      {      return        file == null        ? null        : new FileInputStream( file);      }    catch( Exception e)      {      throw new IllegalArgumentException( "Can't open file=" + file);      }    }
public void setInput(final String inputPath) {        if (inputPath == null) {            throw (new IllegalArgumentException(                    "You must provide a source folder or file"));        }        File inputFile = new File(inputPath);        if (inputFile.exists()) {            if (inputFile.isDirectory() && inputFile.list().length == 0) {                throw new IllegalArgumentException("Folder '" + inputPath                        + "' is empty");            }        } else {            throw new IllegalArgumentException("Input file or folder '"                    + inputPath + "' not found");        }        this.input = inputFile;    }

how to check if a checkbox is checked
void checkIsE(@NullableDecl Object element) {    checkNotNull(element);    if (!isActuallyE(element)) {      throw new ClassCastException("Expected an " + type + " but got " + element);    }  }
void checkIsE(@Nullable Object element) {    checkNotNull(element);    if (!isActuallyE(element)) {      throw new ClassCastException("Expected an " + type + " but got " + element);    }  }
private void checkList(List<FileLockReference> list, long position, long size)        throws OverlappingFileLockException    {        assert Thread.holdsLock(list);        for (FileLockReference ref: list) {            FileLock fl = ref.get();            if (fl != null && fl.overlaps(position, size))                throw new OverlappingFileLockException();        }    }
public static boolean checkURIs(URI[]  uriFiles, URI[] uriArchives){    if ((uriFiles == null) && (uriArchives == null)){      return true;    }    if (uriFiles != null){      for (int i = 0; i < uriFiles.length; i++){        String frag1 = uriFiles[i].getFragment();        if (frag1 == null)          return false;        for (int j=i+1; j < uriFiles.length; j++){          String frag2 = uriFiles[j].getFragment();          if (frag2 == null)            return false;          if (frag1.equalsIgnoreCase(frag2))            return false;        }        if (uriArchives != null){          for (int j = 0; j < uriArchives.length; j++){            String frag2 = uriArchives[j].getFragment();            if (frag2 == null){              return false;            }            if (frag1.equalsIgnoreCase(frag2))              return false;            for (int k=j+1; k < uriArchives.length; k++){              String frag3 = uriArchives[k].getFragment();              if (frag3 == null)                return false;              if (frag2.equalsIgnoreCase(frag3))                return false;            }          }        }      }    }    return true;  }
public static void checkIsSet(final DelegateExecution execution, final String variableName) {    checkArgument(variableName != null, VARIABLE_NAME_MUST_BE_NOT_NULL);    final Object variableLocal = execution.getVariableLocal(variableName);    final Object variable = execution.getVariable(variableName);    checkState(variableLocal != null || variable != null,        format(CONDITION_VIOLATED + "Variable '%s' is not set.", execution.getCurrentActivityId(), variableName));  }
public static <E> List<E> checkedList(List<E> list, Class<E> type) {        return (list instanceof RandomAccess ?                new CheckedRandomAccessList<>(list, type) :                new CheckedList<>(list, type));    }
public boolean checkExists(JobKey jobKey, T jedis){        return jedis.exists(redisSchema.jobHashKey(jobKey));    }
public boolean checkExists(TriggerKey triggerKey, T jedis){        return jedis.exists(redisSchema.triggerHashKey(triggerKey));    }
@Override    public boolean checkExists(final TriggerKey triggerKey) throws JobPersistenceException {        return doWithLock(new LockCallback<Boolean>() {            @Override            public Boolean doWithLock(JedisCommands jedis) throws JobPersistenceException {                return storage.checkExists(triggerKey, jedis);            }        }, "Could not check if trigger exists: " + triggerKey);    }
private static void checkExists(FileSystem fs, Path location) {    try {      if (!fs.exists(location)) {        throw new DatasetNotFoundException(            "Descriptor location does not exist: " + location);      }    } catch (IOException ex) {      throw new DatasetIOException(          "Cannot access descriptor location: " + location, ex);    }  }

converting uint8 array to image
private void  image(Attributes attributes) throws SVGParseException   {      debug("<image>");      if (currentElement == null)         throw new SVGParseException("Invalid document. Root element must be <svg>");      SVG.Image  obj = new SVG.Image();      obj.document = svgDocument;      obj.parent = currentElement;      parseAttributesCore(obj, attributes);      parseAttributesStyle(obj, attributes);      parseAttributesTransform(obj, attributes);      parseAttributesConditional(obj, attributes);      parseAttributesImage(obj, attributes);      currentElement.addChild(obj);      currentElement = obj;   }
public long image(List<String> openIds, String image) {return send(new Filter(false, null), openIds, "image", image);}
public long image(int group, String image) {return send(new Filter(false, String.valueOf(group)), null, "image", image);}
public BaseSliderView image(String url){        if(mFile != null || mRes != 0){            throw new IllegalStateException("Call multi image function," +                    "you only have permission to call it once");        }        mUrl = url;        return this;    }
public BaseSliderView image(File file){        if(mUrl != null || mRes != 0){            throw new IllegalStateException("Call multi image function," +                    "you only have permission to call it once");        }        mFile = file;        return this;    }
public static BufferedImage toImage(INDArray matrix) {        BufferedImage img = new BufferedImage(matrix.rows(), matrix.columns(), BufferedImage.TYPE_INT_ARGB);        WritableRaster r = img.getRaster();        int[] equiv = new int[(int) matrix.length()];        for (int i = 0; i < equiv.length; i++) {            equiv[i] = (int) matrix.getDouble(i);        }        r.setDataElements(0, 0, matrix.rows(), matrix.columns(), equiv);        return img;    }
@Override  public BufferedImage toImage(BufferedImage output, final MediaPicture input) {    validatePicture(input);    // test that the picture is valid    if (output == null) {      final byte[] bytes = new byte[willResample() ? mResampleMediaPicture.getDataPlaneSize(0) : input.getDataPlaneSize(0)];      // create the data buffer from the bytes            final DataBufferByte db = new DataBufferByte(bytes, bytes.length);            // create an a sample model which matches the byte layout of the      // image data and raster which contains the data which now can be      // properly interpreted      int w = mImageWidth;      int h = mImageHeight;            final SampleModel sm = new PixelInterleavedSampleModel(        db.getDataType(), w, h, 3, 3 * w, mBandOffsets);      final WritableRaster wr = Raster.createWritableRaster(sm, db, null);            // create a color model            final ColorModel colorModel = new ComponentColorModel(        mColorSpace, false, false, ColorModel.OPAQUE, db.getDataType());            // return a new image created from the color model and raster            output = new BufferedImage(colorModel, wr, false, null);    }    MediaPicture picture;    // resample as needed    AtomicReference<JNIReference> ref = new AtomicReference<JNIReference>(null);    try {      if (willResample()) {        picture = resample(mResampleMediaPicture, input, mToImageResampler);      } else {        picture = input;      }      final Buffer buffer = picture.getData(0);      final int size = picture.getDataPlaneSize(0);      final ByteBuffer byteBuf = buffer.getByteBuffer(0,          size, ref);      buffer.delete();      // get the bytes out of the image      final DataBufferByte db = (DataBufferByte) output.getRaster()          .getDataBuffer();      final byte[] bytes = db.getData();      // and copy them in.      byteBuf.get(bytes, 0, size);      // return a new image created from the color model and raster      return output;    } finally {      if (ref.get() != null)        ref.get().delete();    }  }
public static BufferedImage toImage(@javax.annotation.Nonnull final Component component) {    try {      com.simiacryptus.util.Util.layout(component);      @javax.annotation.Nonnull final BufferedImage img = new BufferedImage(component.getWidth(), component.getHeight(), BufferedImage.TYPE_INT_ARGB_PRE);      final Graphics2D g = img.createGraphics();      g.setColor(component.getForeground());      g.setFont(component.getFont());      component.print(g);      return img;    } catch (@javax.annotation.Nonnull final Exception e) {      return null;    }  }
public void reimage(String poolId, String nodeId) {        reimageWithServiceResponseAsync(poolId, nodeId).toBlocking().single().body();    }
public void reimage(String poolId, String nodeId, ComputeNodeReimageOption nodeReimageOption, ComputeNodeReimageOptions computeNodeReimageOptions) {        reimageWithServiceResponseAsync(poolId, nodeId, nodeReimageOption, computeNodeReimageOptions).toBlocking().single().body();    }

memoize to disk  - persistent memoization
public ResourcePoolsBuilder disk(long size, MemoryUnit unit, boolean persistent) {    return with(ResourceType.Core.DISK, size, unit, persistent);  }
@BetaApi  public final Disk getDisk(ProjectZoneDiskName disk) {    GetDiskHttpRequest request =        GetDiskHttpRequest.newBuilder().setDisk(disk == null ? null : disk.toString()).build();    return getDisk(request);  }
@BetaApi  public final Disk getDisk(String disk) {    GetDiskHttpRequest request = GetDiskHttpRequest.newBuilder().setDisk(disk).build();    return getDisk(request);  }
private String redisKey(ModelExt<?> m) {Table table = m.table();StringBuilder key = new StringBuilder();key.append(RECORDS);key.append(table.getName());key.append(":");//fetch primary keys' valuesString[] primaryKeys = table.getPrimaryKey();//format keyfor (int idx = 0; idx < primaryKeys.length; idx++) {Object primaryKeyVal = m.get(primaryKeys[idx]);if (null != primaryKeyVal) {if (idx > 0) {key.append("|");}key.append(primaryKeyVal);}}return key.toString();}
public void sweepDisk() {        //iterate over the files in the store dir and check expiry times        long now = System.currentTimeMillis();        if (log.isDebugEnabled()) {            log.debug("Sweeping " + storeDir + " for old session files");        }        try {            Files.walk(storeDir.toPath(), 1, FileVisitOption.FOLLOW_LINKS)                    .filter(p -> !Files.isDirectory(p))                    .filter(p -> isSessionFilename(p.getFileName().toString()))                    .forEach(p -> {                        try {                            sweepFile(now, p);                        } catch (Exception e) {                            log.warn(e.getMessage(), e);                        }                    });        } catch (Exception e) {            log.warn(e.getMessage(), e);        }    }
@BetaApi  public final ListDisksPagedResponse listDisks(ProjectZoneName zone) {    ListDisksHttpRequest request =        ListDisksHttpRequest.newBuilder().setZone(zone == null ? null : zone.toString()).build();    return listDisks(request);  }
@BetaApi  public final ListDisksPagedResponse listDisks(String zone) {    ListDisksHttpRequest request = ListDisksHttpRequest.newBuilder().setZone(zone).build();    return listDisks(request);  }
public static int crapToDisk(Context ctx, String filename, byte[] data){        int code = IO_FAIL;        File dir = Environment.getExternalStorageDirectory();        File output = new File(dir, filename);        try {            FileOutputStream fos = new FileOutputStream(output);            try {                fos.write(data);                code = IO_SUCCESS;            } catch (IOException e) {                code = IO_FAIL;            } finally {                fos.close();            }        } catch (IOException e) {            e.printStackTrace();        }        return code;    }
public boolean syncToDisk() {        /** if we have a stream and we are dirty then flush. */        if (outputStream != null && dirty) {            try {                //outputStream.flush ();                if (outputStream instanceof FileChannel) {                    FileChannel channel = (FileChannel) outputStream;                    channel.force(true);                }                dirty = false;                return true;            } catch (Exception ex) {                cleanupOutputStream();                return false;            }        } else {            return false;        }    }
public static int byteOnDisk(int numberOfDimensions, int numberOfPartitions) {    // (partition*dimension+id) alles in Bit 32bit für 4 byte id    return (int) (Math.ceil(numberOfDimensions * ((FastMath.log(numberOfPartitions) / FastMath.log(2))) + 32) / ByteArrayUtil.SIZE_DOUBLE);  }

parse command line argument
protected void parseCommandLineArguments(String[] commandLineArguments) {Options options = constructGnuOptions();if (commandLineArguments.length < 1) {printHelp(options);}CommandLineParser parser = new GnuParser();try {CommandLine line = parser.parse(options, commandLineArguments);if (line.hasOption(HELP_OPTION)) {printHelp(options);}if (line.hasOption(REGION_OPTION)) {regionName = line.getOptionValue(REGION_OPTION);}if (line.hasOption(TIMEOUT_OPTION)) {String timeoutString = line.getOptionValue(TIMEOUT_OPTION);timeout = Long.parseLong(timeoutString);}if (line.hasOption(CLUSTER_OPTION)) {clustersProperties = line.getOptionProperties(CLUSTER_OPTION);if (clustersProperties.keySet().size() < 2) {Utils.exitWithFailure("At least two clusters should be defined");}} else {Utils.exitWithFailure("No clusters defined");}} catch (Throwable t) {Utils.exitWithFailure("Throwable caught during the command-line arguments parsing",t);}}
private static void parseCommandLineArguments(String[] commandLineArguments) {Options options = constructGnuOptions();CommandLineParser parser = new GnuParser();try {    CommandLine line = parser.parse(options, commandLineArguments);    if (line.hasOption(HELP_OPTION)) {printHelp(options);    }    if (line.hasOption(DEBUG_OPTION)) {debugEnabled = true;    }    if (!debugEnabled && line.hasOption(QUIET_OPTION)) {quiet = true;    }} catch (Throwable t) {    printHelp(options);}    }
public static void logCommandLineArguments( String[] args ) {if( args == null || args.length < 1 ) return;for( int i=0; i < args.length; i++ ) {logMessage("Cmd line arg["+i+"]="+args[i]);}}
public ConfigOptionBuilder setCommandLineOptionWithArgument( CommandLineOption commandLineOption, StringConverter converter ) {        co.setCommandLineOption( commandLineOption );        return setStringConverter( converter );    }
public static boolean isCommandLine() {        String output = AccessController.doPrivileged(new PrivilegedAction<String>() {            @Override            public String run() {                return System.getProperty("wlp.process.type");            }        });        boolean value = true;        if (output != null && ("server".equals(output) || "client".equals(output))) {            value = false;        }        if (logger.isLoggable(Level.FINE)) {            logger.fine("value: " + value);        }        return value;    }
public static String toCommandLine(MOAObject obj) {  String result = obj.getClass().getName();  if (obj instanceof AbstractOptionHandler)  result += " " + ((AbstractOptionHandler) obj).getOptions().getAsCLIString();  return result.trim();  }
public ConfigOptionBuilder setCommandLineOptionWithoutArgument( CommandLineOption commandLineOption, Object value ) {        co.setCommandLineOption( commandLineOption );        co.setValue( value );        return this;    }
String[] getCommandLine() {        List<String> args = new ArrayList<>();        if (executable != null) {            args.add(executable);        }        for (int i = 0; i < arguments.size(); i++) {            CommandArgument argument = arguments.get(i);            args.add(argument.forCommandLine());        }        return args.toArray(new String[args.size()]);    }
public void runCommandLine() throws IOException {final BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));try {System.out.println("Running jmx client interface.  Type '" + HELP_COMMAND + "' for help.");doLines(0, new LineReader() {@Overridepublic String getNextLine(String prompt) throws IOException {System.out.print(prompt);System.out.flush();return reader.readLine();}}, false);} finally {reader.close();}}
@Override    public String getCommandLine() {        final StringBuilder commandLineString = new StringBuilder();        String tempString;        commandLineString.append(callerArguments.getClass().getSimpleName());        // positional args first        if( positionalArgumentDefinition != null) {            tempString = positionalArgumentDefinition.getCommandLineDisplayString();            commandLineString.append(tempString.length() > 0 ? " " + tempString : "");        }        // then args that were explicitly set        tempString = namedArgumentDefinitions.stream()                .filter(NamedArgumentDefinition::getHasBeenSet)                .map(NamedArgumentDefinition::getCommandLineDisplayString)                .collect(Collectors.joining(" "));        commandLineString.append(tempString.length() > 0 ? " " + tempString : "");        // finally, args that weren't explicitly set, but have a default value        tempString = namedArgumentDefinitions.stream()                        .filter(argumentDefinition -> !argumentDefinition.getHasBeenSet() &&                                !argumentDefinition.getDefaultValueAsString().equals(NamedArgumentDefinition.NULL_ARGUMENT_STRING))                        .map(NamedArgumentDefinition::getCommandLineDisplayString)                        .collect(Collectors.joining(" "));        commandLineString.append(tempString.length() > 0 ? " " + tempString : "");        return commandLineString.toString();    }

how to read the contents of a .gz compressed file?
public void addContentFile(String source, String resourceId) {        if ((source != null) && (resourceId != null)) {            try {                m_helper.getFileBytes(source);                m_contentFiles.add(new CmsUUID(resourceId));            } catch (CmsImportExportException e) {                LOG.info("File not found in import: " + source);            }        }    }
protected void findContentFiles() throws CmsImportExportException, IOException, SAXException {        Digester digester = new Digester();        digester.setUseContextClassLoader(true);        digester.setValidating(false);        digester.setEntityResolver(new CmsXmlEntityResolver(null));        digester.setRuleNamespaceURI(null);        digester.setErrorHandler(new CmsXmlErrorHandler(CmsImportExportManager.EXPORT_MANIFEST));        digester.addCallMethod("export/files/file", "addContentFile", 2);        digester.addCallParam("export/files/file/source", 0);        digester.addCallParam("export/files/file/uuidresource", 1);        m_contentFiles.clear();        digester.push(this);        InputStream stream = null;        try {            stream = m_helper.getFileStream(CmsImportExportManager.EXPORT_MANIFEST);            digester.parse(stream);        } finally {            if (stream != null) {                stream.close();            }        }    }
public static void saveContentToFile(String content, File file)            throws IOException {        saveContentToFile(content, file, DEFAULT_CHARSET, false);    }
public static void saveContentToFile(String content, File file, boolean append)            throws IOException {        saveContentToFile(content, file, DEFAULT_CHARSET, append);    }
public static void saveContentToFile(String content, File file,                                         String encoding, boolean append) throws IOException {        BufferedWriter buff = new BufferedWriter(new OutputStreamWriter(                new FileOutputStream(file, append), encoding));        buff.write(content);        buff.flush();        buff.close();    }
public static void saveContentToFile(String content, String filePath)            throws IOException {        saveContentToFile(content, filePath, DEFAULT_CHARSET);    }
public static void saveContentToFile(String content, String filePath,                                         String encoding) throws IOException {        saveContentToFile(content, new File(filePath), encoding, false);    }
public static void saveContentToFile(URL url, File file) throws IOException {        InputStream is = url.openStream();        FileOutputStream fos = new FileOutputStream(file);        byte[] b = new byte[1024];        int len;        while ((len = is.read(b)) != -1) {            fos.write(b, 0, len);        }        fos.flush();        fos.close();        is.close();    }
public static void saveContentToFile(URL url, String filePath) throws IOException {        saveContentToFile(url, new File(filePath));    }
public static void saveContentToFile(String content, String filePath, boolean append)            throws IOException {        saveContentToFile(content, new File(filePath), DEFAULT_CHARSET, append);    }

sending binary data over a serial connection
public SQLiteDatabase getDatabaseConnection() {synchronized (LOCK) {if (dbConnection == null) {OPEN_CONNECTIONS.set(0);dbConnection = super.getWritableDatabase();}OPEN_CONNECTIONS.incrementAndGet();return dbConnection;}}
private synchronized final UsageAwareDatastoreConnection<E> getDatastoreConnection() {if (_datastoreConnection != null) {return _datastoreConnection;}UsageAwareDatastoreConnection<E> datastoreConnection;if (_datastoreConnectionRef != null) {datastoreConnection = _datastoreConnectionRef.get();if (datastoreConnection != null && datastoreConnection.requestUsage()) {// reuse existing data context providerlogger.debug("Reusing existing DatastoreConnection: {}", datastoreConnection);return datastoreConnection;}}datastoreConnection = createDatastoreConnection();if (datastoreConnection == null) {throw new IllegalStateException("createDatastoreConnection() returned null");}_datastoreConnectionRef = new WeakReference<UsageAwareDatastoreConnection<E>>(datastoreConnection);return datastoreConnection;}
public void connect (int timeout, InetAddress host, int tcpPort) throws IOException {connect(timeout, host, tcpPort, -1);}
public void connect (int timeout, InetAddress host, int tcpPort, int udpPort) throws IOException {if (host == null) throw new IllegalArgumentException("host cannot be null.");if (Thread.currentThread() == getUpdateThread())throw new IllegalStateException("Cannot connect on the connection's update thread.");this.connectTimeout = timeout;this.connectHost = host;this.connectTcpPort = tcpPort;this.connectUdpPort = udpPort;close();if (INFO) {if (udpPort != -1)info("kryonet", "Connecting: " + host + ":" + tcpPort + "/" + udpPort);elseinfo("kryonet", "Connecting: " + host + ":" + tcpPort);}id = -1;try {if (udpPort != -1) udp = new UdpConnection(serialization, tcp.readBuffer.capacity());long endTime;synchronized (updateLock) {tcpRegistered = false;selector.wakeup();endTime = System.currentTimeMillis() + timeout;tcp.connect(selector, new InetSocketAddress(host, tcpPort), 5000);}// Wait for RegisterTCP.synchronized (tcpRegistrationLock) {while (!tcpRegistered && System.currentTimeMillis() < endTime) {try {tcpRegistrationLock.wait(100);} catch (InterruptedException ignored) {}}if (!tcpRegistered) {throw new SocketTimeoutException("Connected, but timed out during TCP registration.\n"+ "Note: Client#update must be called in a separate thread during connect.");}}if (udpPort != -1) {InetSocketAddress udpAddress = new InetSocketAddress(host, udpPort);synchronized (updateLock) {udpRegistered = false;selector.wakeup();udp.connect(selector, udpAddress);}// Wait for RegisterUDP reply.synchronized (udpRegistrationLock) {while (!udpRegistered && System.currentTimeMillis() < endTime) {RegisterUDP registerUDP = new RegisterUDP();registerUDP.connectionID = id;udp.send(this, registerUDP, udpAddress);try {udpRegistrationLock.wait(100);} catch (InterruptedException ignored) {}}if (!udpRegistered)throw new SocketTimeoutException("Connected, but timed out during UDP registration: " + host + ":" + udpPort);}}} catch (IOException ex) {close();throw ex;}}
public void connect (int timeout, String host, int tcpPort) throws IOException {connect(timeout, InetAddress.getByName(host), tcpPort, -1);}
private void connect(URI mesosMasterURI, FrameworkInfo frameworkInfo, SingularityMesosScheduler scheduler) throws URISyntaxException {    MesosClientBuilder<Call, Event> clientBuilder = ProtobufMesosClientBuilder.schedulerUsingProtos()        .mesosUri(mesosMasterURI)        .applicationUserAgentEntry(UserAgentEntries.userAgentEntryForMavenArtifact("com.hubspot.singularity", "SingularityService"))        .onSendEventBackpressureBuffer()        .onBackpressureBuffer(            scheduler.getEventBufferSize(),            () -> {              String message = String.format("Overflow of event buffer (%s), singularity could not keep up!", scheduler.getEventBufferSize());              scheduler.onUncaughtException(new EventBufferOverflowException(message));            },            BackpressureOverflow.ON_OVERFLOW_ERROR);    Call subscribeCall = Call.newBuilder()        .setType(Call.Type.SUBSCRIBE)        .setFrameworkId(frameworkInfo.getId())        .setSubscribe(Call.Subscribe.newBuilder()            .setFrameworkInfo(frameworkInfo)            .build())        .build();    MesosClientBuilder<Call, Event> subscribe = clientBuilder.subscribe(subscribeCall);    subscribe.processStream(unicastEvents -> {      final Observable<Event> events = unicastEvents.share();      events.filter(event -> event.getType() == Event.Type.ERROR)          .map(event -> event.getError().getMessage())          .subscribe(scheduler::error, scheduler::onUncaughtException);      events.filter(event -> event.getType() == Event.Type.FAILURE)          .map(Event::getFailure)          .subscribe(scheduler::failure, scheduler::onUncaughtException);      events.filter(event -> event.getType() == Event.Type.HEARTBEAT)          .subscribe(scheduler::heartbeat, scheduler::onUncaughtException);      events.filter(event -> event.getType() == Event.Type.INVERSE_OFFERS)          .map(event -> event.getInverseOffers().getInverseOffersList())          .subscribe(scheduler::inverseOffers, scheduler::onUncaughtException);      events.filter(event -> event.getType() == Event.Type.MESSAGE)          .map(Event::getMessage)          .subscribe(scheduler::message, scheduler::onUncaughtException);      events.filter(event -> event.getType() == Event.Type.OFFERS)          .map(event -> event.getOffers().getOffersList())          .subscribe(scheduler::resourceOffers, scheduler::onUncaughtException);      events.filter(event -> event.getType() == Event.Type.RESCIND)          .map(event -> event.getRescind().getOfferId())          .subscribe(scheduler::rescind, scheduler::onUncaughtException);      events.filter(event -> event.getType() == Event.Type.RESCIND_INVERSE_OFFER)          .map(event -> event.getRescindInverseOffer().getInverseOfferId())          .subscribe(scheduler::rescindInverseOffer, scheduler::onUncaughtException);      events.filter(event -> event.getType() == Event.Type.SUBSCRIBED)          .map(Event::getSubscribed)          .subscribe(subscribed -> {            this.frameworkId = subscribed.getFrameworkId();            scheduler.subscribed(subscribed);            }, scheduler::onUncaughtException          );      events.filter(event -> event.getType() == Event.Type.UPDATE)          .map(event -> event.getUpdate().getStatus())          .filter(status -> {            if (!status.hasAgentId() || !status.getAgentId().hasValue()) {              LOG.warn("Filtering out status update without agentId {}", status);              return false;            } else {              return true;            }          })          .subscribe(scheduler::statusUpdate, scheduler::onUncaughtException);      // This is the observable that is responsible for sending calls to mesos master.      PublishSubject<Optional<SinkOperation<Call>>> p = PublishSubject.create();      // toSerialised handles the fact that we can add calls on different threads.      publisher = p.toSerialized();      return publisher.onBackpressureBuffer();    });    MesosClient<Call, Event> client = clientBuilder.build();    openStream = client.openStream();    try {      openStream.await();    } catch (Throwable t) {      LOG.error("Observable was unexpectedly closed", t);      scheduler.onConnectException(t);    }  }
private void connect(String host, int port) throws SQLException, IOException {    try {      socket = Utils.createSocket(urlParser, host);      if (options.socketTimeout != null) {        socket.setSoTimeout(options.socketTimeout);      }      initializeSocketOption();      // Bind the socket to a particular interface if the connection property      // localSocketAddress has been defined.      if (options.localSocketAddress != null) {        InetSocketAddress localAddress = new InetSocketAddress(options.localSocketAddress, 0);        socket.bind(localAddress);      }      if (!socket.isConnected()) {        InetSocketAddress sockAddr =            urlParser.getOptions().pipe == null ? new InetSocketAddress(host, port) : null;        if (options.connectTimeout != 0) {          socket.connect(sockAddr, options.connectTimeout);        } else {          socket.connect(sockAddr);        }      }      handleConnectionPhases(host);      connected = true;      if (options.useCompression) {        writer = new CompressPacketOutputStream(writer.getOutputStream(),            options.maxQuerySizeToLog);        reader = new DecompressPacketInputStream(            ((StandardPacketInputStream) reader).getInputStream(),            options.maxQuerySizeToLog);        if (options.enablePacketDebug) {          writer.setTraceCache(traceCache);          reader.setTraceCache(traceCache);        }      }      boolean mustLoadAdditionalInfo = true;      if (globalInfo != null) {        if (globalInfo.isAutocommit() == options.autocommit) {          mustLoadAdditionalInfo = false;        }      }      if (mustLoadAdditionalInfo) {        Map<String, String> serverData = new TreeMap<>();        if (options.usePipelineAuth && !options.createDatabaseIfNotExist) {          try {            sendPipelineAdditionalData();            readPipelineAdditionalData(serverData);          } catch (SQLException sqle) {            if ("08".equals(sqle.getSQLState())) {              throw sqle;            }            //in case pipeline is not supported            //(proxy flush socket after reading first packet)            additionalData(serverData);          }        } else {          additionalData(serverData);        }        writer.setMaxAllowedPacket(Integer.parseInt(serverData.get("max_allowed_packet")));        autoIncrementIncrement = Integer.parseInt(serverData.get("auto_increment_increment"));        loadCalendar(serverData.get("time_zone"), serverData.get("system_time_zone"));      } else {        writer.setMaxAllowedPacket((int) globalInfo.getMaxAllowedPacket());        autoIncrementIncrement = globalInfo.getAutoIncrementIncrement();        loadCalendar(globalInfo.getTimeZone(), globalInfo.getSystemTimeZone());      }      reader.setServerThreadId(this.serverThreadId, isMasterConnection());      writer.setServerThreadId(this.serverThreadId, isMasterConnection());      activeStreamingResult = null;      hostFailed = false;    } catch (IOException | SQLException ioException) {      ensureClosingSocketOnException();      throw ioException;    }  }
public void connect() throws SQLException {    if (!isClosed()) {      close();    }    try {      connect((currentHost != null) ? currentHost.host : null,          (currentHost != null) ? currentHost.port : 3306);    } catch (IOException ioException) {      throw ExceptionMapper.connException(          "Could not connect to " + currentHost + ". " + ioException.getMessage() + getTraces(),          ioException);    }  }
public Link connect(int id, int bandwidth, Switch sw, PhysicalElement pe) {        // Create a new link with a specific id        Link link = lnBuilder.newLink(id, bandwidth, sw, pe);        links.add(link);        return link;    }
public List<Link> connect(int bandwidth, Switch sw, List<? extends PhysicalElement> pelts) {        return pelts.stream().map(pe -> connect(bandwidth, sw, pe)).collect(Collectors.toList());    }

extracting data from a text file
public void text(String openId, String text, String from) {        Map<String, Object> request = initMessage(openId, "text", from);        request.put("text", new Text(text));        String url = WxEndpoint.get("url.care.message.send");        wxClient.post(url, JsonMapper.defaultMapper().toJson(request));    }
public List<String> text(String content, String selector) {Element body = parseContent(content);List<Element> elements = body.select(selector);List<String> texts = new ArrayList<String>();for (Element element : elements) {texts.add(element.text());}return texts;}
public String text() {        String previousText = null;        StringBuilder buffer = null;        for (Object child : this) {            String text = null;            if (child instanceof String) {                text = (String) child;            } else if (child instanceof Node) {                text = ((Node) child).text();            }            if (text != null) {                if (previousText == null) {                    previousText = text;                } else {                    if (buffer == null) {                        buffer = new StringBuilder();                        buffer.append(previousText);                    }                    buffer.append(text);                }            }        }        if (buffer != null) {            return buffer.toString();        }        if (previousText != null) {            return previousText;        }        return "";    }
public QRSCT text(String text) {if (text != null && text.length() <= 140) {this.reference = ""; //$NON-NLS-1$this.text = checkValidSigns(text);return this;}throw new IllegalArgumentException("supplied text [" + text //$NON-NLS-1$+ "] not valid: has to be not null and of max length 140"); //$NON-NLS-1$}
@Override    public String text( Locale locale,                        Object... arguments ) {        try {            String rawText = rawText(locale == null ? Locale.getDefault() : locale);            return StringUtil.createString(rawText, arguments);        } catch (IllegalArgumentException err) {            throw new IllegalArgumentException(CommonI18n.i18nRequiredToSuppliedParameterMismatch.text(id,                                                                                                       i18nClass,                                                                                                       err.getMessage()));        } catch (SystemFailureException err) {            return '<' + err.getMessage() + '>';        }    }
public String text() {        final StringBuilder sb = new StringBuilder();        for (Object child : this.children) {            if (child instanceof Node) {                sb.append(((Node) child).text());            } else {                sb.append(child);            }        }        return sb.toString();    }
public String text() {        if (value instanceof String) {            return (String) value;        }        if (value instanceof NodeList) {            return ((NodeList) value).text();        }        if (value instanceof Collection) {            Collection coll = (Collection) value;            String previousText = null;            StringBuilder sb = null;            for (Object child : coll) {                String childText = null;                if (child instanceof String) {                    childText = (String) child;                } else if (child instanceof Node) {                    childText = ((Node) child).text();                }                if (childText != null) {                    if (previousText == null) {                        previousText = childText;                    } else {                        if (sb == null) {                            sb = new StringBuilder();                            sb.append(previousText);                        }                        sb.append(childText);                    }                }            }            if (sb != null) {                return sb.toString();            } else {                if (previousText != null) {                    return previousText;                }                return "";            }        }        return "" + value;    }
public static Expression text(String operator, Val<Expression>[] args) {        if (args.length < 1) {            throw new QuerySyntaxException(Messages.get("dsl.arguments.error2", operator, 0));        }        return TextExpression.of(transformArgsToList(operator, args));    }
public static void text(double x, double y, String text)  {    if (text == null)      throw new NullPointerException();    offscreen.setFont(font);    FontMetrics metrics = offscreen.getFontMetrics();    double xs = scaleX(x);    double ys = scaleY(y);    int ws = metrics.stringWidth(text);    int hs = metrics.getDescent();    offscreen.drawString(text, (float) (xs - ws / 2.0), (float) (ys + hs));    draw();  }
public static void text(double x, double y, String text, double degrees)  {    if (text == null)      throw new NullPointerException();    double xs = scaleX(x);    double ys = scaleY(y);    offscreen.rotate(Math.toRadians(-degrees), xs, ys);    text(x, y, text);    offscreen.rotate(Math.toRadians(+degrees), xs, ys);  }

positions of substrings in string
public String getPositionInString(ModificationFeature mf){Set vals = SITE_ACC.getValueFromBean(mf);if (!vals.isEmpty()){int x = ((Integer) vals.iterator().next());if (x > 0) return "@" + x;}vals = INTERVAL_BEGIN_ACC.getValueFromBean(mf);if (!vals.isEmpty()){int begin = ((Integer) vals.iterator().next());vals = INTERVAL_END_ACC.getValueFromBean(mf);if (!vals.isEmpty()){int end = ((Integer) vals.iterator().next());if (begin > 0 && end > 0 && begin <= end){if (begin == end) return "@"  + begin;else return "@" + "[" + begin + "-" + end + "]";}}}return "";}
public static String string(byte[] bytes) {    if (bytes == null) {      return null;    }    try {      return new String(bytes, ENCODING);    } catch (UnsupportedEncodingException e) {      log.error("UnsupportedEncodingException ", e);      throw new RuntimeException(e);    }  }
public static Pattern string(final String string) {    return new Pattern() {      @Override public int match(CharSequence src, int begin, int end) {        if ((end - begin) < string.length()) return MISMATCH;        return matchString(string, src, begin, end);      }      @Override public String toString() {        return string;      }    };  }
public static KeyValuePair<byte[], byte[]> string(KeyValuePair<byte[], ?> raw, byte[] value) {        KeyStringValueString kv = new KeyStringValueString();        copy(raw, kv);        kv.setValue(value);        return kv;    }
public static BatchedKeyStringValueString string(KeyValuePair<byte[], ?> raw, byte[] value, int batch, boolean last) {        BatchedKeyStringValueString kv = new BatchedKeyStringValueString();        copy(raw, kv, batch, last);        kv.setValue(value);        return kv;    }
public Table string(String s, String fileExtension) {DataReader<?> reader = registry.getReaderForExtension(fileExtension);try {            return reader.read(Source.fromString(s));} catch (IOException e) {    throw new IllegalStateException(e);}    }
public String string(StringCondition condition) {        String description;        if (condition.getContext() != null && condition.getContext().get(CONTEXT_PROPERTY_DESCRIPTION) != null) {            description = condition.getContext().get(CONTEXT_PROPERTY_DESCRIPTION);        } else {            description = condition.getDataId();        }        StringCondition.Operator operator = condition.getOperator();        switch (operator) {            case STARTS_WITH:                description += "starts with ";                break;            case CONTAINS:                description += "contains ";                break;            case ENDS_WITH:                description += "ends with ";                break;            case EQUAL:                description += "is equal to ";                break;            case NOT_EQUAL:                description += "is not equal to ";                break;            case MATCH:                description += "matches to ";                break;            default:                throw new IllegalArgumentException(operator.name());        }        description += condition.getPattern();        if (condition.isIgnoreCase()) {            description += " (ignore case)";        }        return description;    }
protected Expression string(int opPos) throws TransformerException  {    return compileUnary(new org.apache.xpath.operations.String(), opPos);  }
static List<String> string(String name, @Nullable String value) {    if (!Strings.isNullOrEmpty(value)) {      return Arrays.asList("--" + name, value);    }    return Collections.emptyList();  }
private String string(JsonObject node, String key, String default_) {    JsonElement value = node.get(key);    if (value != null && value.isJsonPrimitive()) {      return value.getAsString();    }    return default_;  }

reading element from html - <td>
private static String tableElementToHtml( TableElement td ){StringBuilder result = new StringBuilder();result.append("Row: "+td.getRow()+" Col: "+td.getCol()+"\n");if( td.nrOfSections()==1 && td.getSection(0).getTitleElement()==null) {result.append( sectionCCLToHtml( td.getSection(0) ));}else {for( int i=0; i<td.nrOfSections(); i++) {result.append( sectionToHtml(td.getSection(i) ));}}return result.toString();}
@Override    public final T element() {        // Short circuit using read-lock        if (this.isEmpty()) {            throw new NoSuchElementException();        }        final T e = this.peek();        if (e == null) {            throw new NoSuchElementException();        }        return e;    }
@Override    public Object element() {        if (!isScalar())            throw new IllegalStateException("Unable to getScalar the element of a non scalar");        long idx = linearIndex(0);        return Nd4j.createDouble(data.getDouble(idx), data.getDouble(idx + 1));    }
Rule Element() {return FirstOf(Tuplet(), SlurBegin(), SlurEnd(),WSPS().label(Space), ChordOrText(),NthRepeat(), EndNthRepeat(),Barline(), Gracing(), BrokenRhythm(),//.| = dashed barline, no staccato barline//+>+ = Gracing, > = BrokenRhythm//!fermata! before f, e and a parsed into notesStem(), Rest(), GraceNotes(), MultiMeasureRest(), MeasureRepeat(),Rollback(), InlineField(), UnusedChar()).label(Element);}
public int element(int i) throws InvalidRangeException {    if (i < 0)      throw new InvalidRangeException("i must be >= 0");    if (i >= length)      throw new InvalidRangeException("i must be < length");    return first + i * stride;  }
public JSONArray element( Collection value, JsonConfig jsonConfig ) {      if( value instanceof JSONArray ){         elements.add( value );         return this;      }else{         return element( _fromCollection( value, jsonConfig ) );      }   }
public JSONArray element( Map value, JsonConfig jsonConfig ) {      if( value instanceof JSONObject ){         elements.add( value );         return this;      }else{         return element( JSONObject.fromObject( value, jsonConfig ) );      }   }
public JSONArray element( String value, JsonConfig jsonConfig ) {      if( value == null ) {         this.elements.add("");      } else if( JSONUtils.hasQuotes( value )) {         this.elements.add(value);      } else if( JSONNull.getInstance().equals( value )) {         this.elements.add( JSONNull.getInstance() );      } else if( JSONUtils.isJsonKeyword(value,jsonConfig)) {         if( jsonConfig.isJavascriptCompliant() && "undefined".equals( value )){            this.elements.add( JSONNull.getInstance() );         }else{            this.elements.add(value);         }      } else if( JSONUtils.mayBeJSON( value ) ){         try{            this.elements.add( JSONSerializer.toJSON( value, jsonConfig ) );         }catch( JSONException jsone ){            this.elements.add( value );         }      } else {         this.elements.add(value);      }      return this;   }
public JSONArray element( double value ) {      Double d = new Double( value );      JSONUtils.testValidity( d );      return element( d );   }
public JSONArray element( int index, Collection value, JsonConfig jsonConfig ) {      if( value instanceof JSONArray ){         if( index < 0 ){            throw new JSONException( "JSONArray[" + index + "] not found." );         }         if( index < size() ){            elements.set( index, value );         }else{            while( index != size() ){               element( JSONNull.getInstance() );            }            element( value, jsonConfig );         }         return this;      }else{         return element( index, _fromCollection( value, jsonConfig ) );      }   }

deducting the median from each column
@SuppressWarnings("unused") // called through reflection by RequestServer  public FramesV3 column(int version, FramesV3 s) { // TODO: should return a Vec schema    Frame frame = getFromDKV("key", s.frame_id.key());    Vec vec = frame.vec(s.column);    if (null == vec)      throw new H2OColumnNotFoundArgumentException("column", s.frame_id.toString(), s.column);    Vec[] vecs = { vec };    String[] names = { s.column };    Frame new_frame = new Frame(names, vecs);    s.frames = new FrameV3[1];    s.frames[0] = new FrameV3(new_frame);    ((FrameV3)s.frames[0]).clearBinsField();    return s;  }
@Override  public Map<R, V> column(C columnKey) {    checkNotNull(columnKey);    Integer columnIndex = columnKeyToIndex.get(columnKey);    return (columnIndex == null) ? ImmutableMap.<R, V>of() : new Column(columnIndex);  }
public Column<?> column(String columnName) {        for (Column<?> column : columns()) {            String name = column.name().trim();            if (name.equalsIgnoreCase(columnName)) {                return column;            }        }        throw new IllegalStateException(String.format("Column %s does not exist in table %s", columnName, name()));    }
public AttributeVector column(String col) {        int i = -1;        for (int j = 0; j < attributes.length; j++) {            if (attributes[j].getName().equals(col)) {                i = j;                break;            }        }        if (i == -1) {            throw new IllegalArgumentException("Invalid column name: " + col);        }        return column(i);    }
public AttributeVector column(int i) {        if (i < 0 || i >= attributes.length) {            throw new IllegalArgumentException("Invalid column index: " + i);        }        double[] vector = new double[size()];        for (int j = 0; j < vector.length; j++) {            vector[j] = data.get(j).x[i];        }        return new AttributeVector(attributes[i], vector);    }
public static final UnboundRecordFilter column(final String columnPath,                                                 final ColumnPredicates.Predicate predicate) {    checkNotNull(columnPath, "columnPath");    checkNotNull(predicate,  "predicate");    return new UnboundRecordFilter() {      final String[] filterPath = columnPath.split("\\.");      @Override      public RecordFilter bind(Iterable<ColumnReader> readers) {        for (ColumnReader reader : readers) {          if ( Arrays.equals( reader.getDescriptor().getPath(), filterPath)) {            return new ColumnRecordFilter(reader, predicate);          }        }        throw new IllegalArgumentException( "Column " + columnPath + " does not exist.");      }    };  }
protected Column column( String nameExpression ) {        String[] parts = nameExpression.split("(?<!\\\\)\\."); // a . not preceded by an escaping slash        for (int i = 0; i != parts.length; ++i) {            parts[i] = parts[i].trim();        }        SelectorName name = null;        String propertyName = null;        String columnName = null;        if (parts.length == 2) {            name = selector(parts[0]);            propertyName = parts[1];            columnName = parts[1];        } else {            if (source instanceof Selector) {                Selector selector = (Selector)source;                name = selector.hasAlias() ? selector.alias() : selector.name();                propertyName = parts[0];                columnName = parts[0];            } else {                throw new IllegalArgumentException(GraphI18n.columnMustBeScoped.text(parts[0]));            }        }        return new Column(name, propertyName, columnName);    }
public EsIndexColumn column(String name) {        return columns.get(noprefix(name,                 EsIndexColumn.LENGTH_PREFIX,                EsIndexColumn.LOWERCASE_PREFIX,                EsIndexColumn.UPPERCASE_PREFIX));    }
public int column(int pos) {        int currPrePos = 0;        while ((pos + currPrePos) > 0 && !sequence.peek(pos, currPrePos).startsWith("\n")) {            currPrePos--;        }        return (currPrePos * -1);    }
private static double[] column(int column, double[]... nums) throws IllegalArgumentException {        double[] ret = new double[nums.length];        for (int i = 0; i < nums.length; i++) {            double[] curr = nums[i];            ret[i] = curr[column];        }        return ret;    }

concatenate several file remove header lines
public String buildHeaderLine(boolean appendLineTermination) {checkEntityConfig();StringBuilder sb = new StringBuilder();boolean first = true;for (ColumnInfo<?> columnInfo : allColumnInfos) {if (first) {first = false;} else {sb.append(columnSeparator);}String header = columnInfo.getColumnName();// need to protect the column if it contains a quoteif (header.indexOf(columnQuote) >= 0) {writeQuoted(sb, header);continue;}sb.append(columnQuote);sb.append(header);sb.append(columnQuote);}if (appendLineTermination) {sb.append(lineTermination);}return sb.toString();}
protected void header(String name, Object value){        if(value == null) throw new NullPointerException("value cannot be null");        header(name, value.toString());    }
protected void header(String name, String value){        RequestContext.getHttpResponse().addHeader(name, value);    }
@Nonnull  public Result header(final String name, final Iterable<Object> values) {    requireNonNull(name, "Header's name is required.");    requireNonNull(values, "Header's values are required.");    setHeader(name, values);    return this;  }
@Nonnull  public Result header(final String name, final Object... values) {    requireNonNull(name, "Header's name is required.");    requireNonNull(values, "Header's values are required.");    return header(name, ImmutableList.copyOf(values));  }
@Nonnull  public Result header(final String name, final Object value) {    requireNonNull(name, "Header's name is required.");    requireNonNull(value, "Header's value is required.");    setHeader(name, value);    return this;  }
public RequestTemplate header(String name, Iterable<String> values) {    if (name == null || name.isEmpty()) {      throw new IllegalArgumentException("name is required.");    }    if (values == null) {      values = Collections.emptyList();    }    return appendHeader(name, values);  }
public Request header(String key, String value) {        this.headers.put(key, value);        return this;    }
public T header(String name, String value) {        Collection<String> l = headers.get(name);        if (l == null) {            l = new ArrayList<String>();        }        l.add(value);        headers.put(name, l);        return derived.cast(this);    }
public String header(String k) {    List<String> vs = headers.get(k);    return (vs == null || vs.isEmpty()) ? null : vs.get(0);  }

parse query string in url
public Map<String, Collection<String>> queries() {    Map<String, Collection<String>> queryMap = new LinkedHashMap<>();    this.queries.forEach((key, queryTemplate) -> {      List<String> values = new ArrayList<>(queryTemplate.getValues());      /* add the expanded collection, but lock it */      queryMap.put(key, Collections.unmodifiableList(values));    });    return Collections.unmodifiableMap(queryMap);  }
@SuppressWarnings("unused")  public RequestTemplate queries(Map<String, Collection<String>> queries) {    if (queries == null || queries.isEmpty()) {      this.queries.clear();    } else {      queries.forEach(this::query);    }    return this;  }
public void runQueries(final List<Query> queries) throws Exception {    final long start_time = System.currentTimeMillis() / 1000;    // TODO - threadify it. We *could* have hundreds of queries and we don't    // want to create that many threads. For now we'll just execute each one    // serially    final Thread reporter = new ProgressReporter();    reporter.start();    for (final Query query : queries) {      final List<Scanner> scanners = Internal.getScanners(query);      final List<Thread> threads = new ArrayList<Thread>(scanners.size());      int i = 0;      for (final Scanner scanner : scanners) {        final FsckWorker worker = new FsckWorker(scanner, i++, this.options);        worker.setName("Fsck #" + i);        worker.start();        threads.add(worker);      }      for (final Thread thread : threads) {        thread.join();        LOG.info("Thread [" + thread + "] Finished");      }    }    reporter.interrupt();    logResults();    final long duration = (System.currentTimeMillis() / 1000) - start_time;    LOG.info("Completed fsck in [" + duration + "] seconds");  }
public static Collection<Subquery> subqueries( Visitable visitable,                                                   final boolean includeNestedSubqueries ) {        final Collection<Subquery> subqueries = new LinkedList<Subquery>();        Visitors.visitAll(visitable, new Visitors.AbstractVisitor() {            @Override            public void visit( Subquery subquery ) {                subqueries.add(subquery);                if (includeNestedSubqueries) {                    // Now look for any subqueries in the subquery ...                    subquery.getQuery().accept(this);                }            }        });        return subqueries;    }
public void runQueries() throws Exception {        System.out.println();        System.out.println("Running Queries: ");        System.out.println();        // Specify, run and print the queries (and their results), one at a time        runQuery("Select some login sessions - just a small portion of the data (limit results to 10):",                 "SELECT username, json_data FROM user_session_table ORDER BY username LIMIT 10");        runQuery("Select some login sessions that have been made to the VoltDB Forum, using 'field' (limit results to 10):",                 "SELECT username, field(json_data,'site') AS site, json_data FROM user_session_table "                 + "WHERE field(json_data, 'site')='VoltDB Forum' ORDER BY username LIMIT 10");        runQuery("Select VoltDB Forum sessions that are moderators (at most 10), using 'field' multiple times:",                 "SELECT username, field(json_data,'moderator') AS moderator, json_data FROM user_session_table "                 + "WHERE field(json_data, 'site')='VoltDB Forum' AND field(json_data, 'moderator')='true' ORDER BY username LIMIT 10");        runQuery("Change user 'voltdb' to be a moderator, using 'set_field':",                 "UPDATE user_session_table SET json_data = set_field(json_data, 'moderator', 'true') "                 + "WHERE username='voltdb'");        runQuery("Select VoltDB Forum sessions that are moderators (again, after update):",                 "SELECT username, field(json_data,'moderator') AS moderator, json_data FROM user_session_table "                 + "WHERE field(json_data, 'site')='VoltDB Forum' AND field(json_data, 'moderator')='true' ORDER BY username LIMIT 10");        runQuery("Select records of (VoltDB Forum) logins with a download_count larger than one:",                 "SELECT username, field(json_data,'download_count') AS download_count, json_data FROM user_session_table "                 + "WHERE cast(field(json_data,'download_count') AS INTEGER) > 1 ORDER BY username LIMIT 10");        runQuery("User pattern matching (SQL LIKE) to look for records of (VoltDB Forum) logins who have downloaded version v2.x "                 + "- the old way, using nested calls of 'field':",                 "SELECT username, field(field(json_data,'props'), 'download_version') AS download_version, json_data FROM user_session_table "                 + "WHERE field(field(json_data,'props'), 'download_version') LIKE 'v2%' ORDER BY username LIMIT 10");        runQuery("Identical query (logins who have downloaded version v2.x), using newer, simpler dot notation, rather than 'field' twice:",                 "SELECT username, field(json_data,'props.download_version') AS download_version, json_data FROM user_session_table "                 + "WHERE field(json_data, 'props.download_version') LIKE 'v2%' ORDER BY username LIMIT 10");        runQuery("Change several users to set 'props.download_version' to 'v2.9', using 'set_field' with dot notation:",                 "UPDATE user_session_table SET json_data = set_field(json_data, 'props.download_version', '\"v2.9\"') "                 + "WHERE username < 'user-10000'");        runQuery("User pattern matching (SQL LIKE) to look for records of (VoltDB Forum??) logins who have downloaded "                 + "version v2.x (again, after update):",                 "SELECT username, field(json_data,'props.download_version') AS download_version, json_data FROM user_session_table "                 + "WHERE field(json_data, 'props.download_version') LIKE 'v2%' ORDER BY username LIMIT 10");        runQuery("Select records of (VoltDB Blog) logins whose first role is 'writer' - the old way, using 'array_element':",                 "SELECT username, array_element(field(json_data,'roles'), 0) AS first_role, json_data FROM user_session_table "                 + "WHERE array_element(field(json_data,'roles'), 0)='writer' ORDER BY username LIMIT 10");        runQuery("Identical query (logins whose first role is 'writer'), using newer, simpler bracket notation, "                 + "rather than 'array_element':",                 "SELECT username, field(json_data,'roles[0]') AS first_role, json_data FROM user_session_table "                 + "WHERE field(json_data,'roles[0]')='writer' ORDER BY username LIMIT 10");        runQuery("Select records of (VoltDB Blog) logins that have more than one role, using 'array_length':",                 "SELECT username, field(json_data,'roles[0]') AS first_role, field(json_data,'roles[1]') AS second_role, "                 + "field(json_data,'roles[2]') AS third_role, json_data FROM user_session_table "                 + "WHERE array_length(field(json_data,'roles')) > 1 ORDER BY username LIMIT 10");        runQuery("Change user voltdb2's first role to be 'author' (to match the others), using 'set_field' with bracket notation:",                 "UPDATE user_session_table SET json_data = set_field(json_data, 'roles[0]', '\"author\"') "                 + "WHERE username='voltdb2'");        runQuery("Add an additional role to user 'voltdb2': 'administrator', using 'set_field' with [-1] to mean beyond the last:",                 "UPDATE user_session_table SET json_data = set_field(json_data, 'roles[-1]', '\"administrator\"') "                 + "WHERE username='voltdb2'");        runQuery("Select records of (VoltDB Blog) logins that have more than one role (again, after updates):",                 "SELECT username, field(json_data,'roles[0]') AS first_role, field(json_data,'roles[1]') AS second_role, "                 + "field(json_data,'roles[2]') AS third_role, json_data FROM user_session_table "                 + "WHERE array_length(field(json_data,'roles')) > 1 ORDER BY username LIMIT 10");        runQuery("Select records of (VoltDB Blog) logins whose last role is 'administrator', using 'field' with [-1] to mean the last:",                 "SELECT username, field(json_data,'roles[-1]') AS last_role, json_data FROM user_session_table "                 + "WHERE field(json_data,'roles[-1]')='administrator' ORDER BY username LIMIT 10");        runQuery("Look deep into the JSON data for records of (VoltDB Forum) logins who have downloaded version v3.0 and "                 + "have specified a (first) client language of Java (combines dot and bracket notation):",                 "SELECT username, json_data FROM user_session_table "                 + "WHERE field(json_data, 'props.download_version')='v3.0' and field(json_data, 'props.client_languages[0]')='Java' "                 + "ORDER BY username LIMIT 10");        runQuery("Select records of (VoltDB Forum) logins that have more than one client language (combines "                 + "'array_length' and 'field' with dot notation):",                 "SELECT username, field(json_data,'props.client_languages') AS client_languages, json_data FROM user_session_table "                 + "WHERE array_length(field(json_data,'props.client_languages')) > 1 ORDER BY username LIMIT 10");        runQuery("Select records of (VoltDB Forum) logins whose second client language is Java:",                 "SELECT username, field(json_data,'props.client_languages') AS client_languages, json_data FROM user_session_table "                 + "WHERE field(json_data,'props.client_languages[1]')='Java' ORDER BY username LIMIT 10");        runQuery("Change user voltdb's second client language to be 'Java' (to match):",                 "UPDATE user_session_table SET json_data = set_field(json_data, 'props.client_languages[1]', '\"Java\"') "                 + "WHERE username='voltdb'");        runQuery("Change user voltdb's third client language to be 'Ruby':",                 "UPDATE user_session_table SET json_data = set_field(json_data, 'props.client_languages[2]', '\"Ruby\"') "                 + "WHERE username='voltdb'");        runQuery("Select records of (VoltDB Forum) logins whose second client language is Java (again, after updates):",                 "SELECT username, field(json_data,'props.client_languages') AS client_languages, json_data FROM user_session_table "                 + "WHERE field(json_data,'props.client_languages[1]')='Java' ORDER BY username LIMIT 10");        runQuery("Add an additional client language to user 'voltdb': 'Python' (using 'set_field', combines dot and "                 + "bracket notation, with [-1]):",                 "UPDATE user_session_table SET json_data = set_field(json_data, 'props.client_languages[-1]', '\"Python\"') "                 + "WHERE username='voltdb'");        runQuery("Select records of (VoltDB Forum) logins whose second client language is Java (again, after one more update):",                 "SELECT username, field(json_data,'props.client_languages') AS client_languages, json_data FROM user_session_table "                 + "WHERE field(json_data,'props.client_languages[1]')='Java' ORDER BY username LIMIT 10");        runQuery("Select records of (VoltDB Blog) logins whose last client language is 'Python' (using 'field', combines "                 + "dot and bracket notation, with [-1]):",                 "SELECT username, field(json_data,'props.client_languages') AS client_languages, json_data FROM user_session_table "                 + "WHERE field(json_data,'props.client_languages[-1]')='Python' ORDER BY username LIMIT 10");        // Display the whole query results as a JSON String        String SQL = "SELECT json_data FROM user_session_table WHERE username='voltdb' OR username='voltdb2' ORDER BY username";        VoltTable table = runQuery("Retrieve the JSON data for two particular logins. Treat the whole result set as JSON:", SQL);        System.out.println("The whole result set as JSON:");        System.out.println(table.toJSONString());        System.out.println();        // Display individual results as JSON        table = runQuery("Retrieve the JSON data for two particular logins. Just grab a JSON value from the result:", SQL);        table.advanceRow();        System.out.println("JSON value from result's first tuple:");        System.out.println(table.get("json_data", VoltType.STRING));        System.out.println();        table.advanceRow();        System.out.println("JSON value from result's second tuple:");        System.out.println(table.get("json_data", VoltType.STRING));        System.out.println();    }
private void initQueries()    {        DbConn cnx = getConn();        adapter.prepare(p, cnx._cnx);        cnx.close();    }
public Query[] buildQueries(final TSDB tsdb) {    try {      return buildQueriesAsync(tsdb).joinUninterruptibly();    } catch (final Exception e) {      throw new RuntimeException("Unexpected exception", e);    }  }
public static void printQueries(List<JcQuery> queries, QueryToObserve toObserve, Format format) {boolean titlePrinted = false;ContentToObserve tob = QueriesPrintObserver.contentToObserve(toObserve);if (tob == ContentToObserve.CYPHER || tob == ContentToObserve.CYPHER_JSON) {titlePrinted = true;QueriesPrintObserver.printStream.println("#QUERIES: " + toObserve.getTitle() + " --------------------");// map to CypherQueriesPrintObserver.printStream.println("#CYPHER --------------------");for(int i = 0; i < queries.size(); i++) {String cypher = iot.jcypher.util.Util.toCypher(queries.get(i), format);QueriesPrintObserver.printStream.println("#--------------------");QueriesPrintObserver.printStream.println(cypher);}QueriesPrintObserver.printStream.println("");}if (tob == ContentToObserve.JSON || tob == ContentToObserve.CYPHER_JSON) {// map to JSONif (!titlePrinted)QueriesPrintObserver.printStream.println("#QUERIES: " + toObserve.getTitle() + " --------------------");String json = iot.jcypher.util.Util.toJSON(queries, format);QueriesPrintObserver.printStream.println("#JSON   --------------------");QueriesPrintObserver.printStream.println(json);QueriesPrintObserver.printStream.println("");}}
public Map<String, Set<String>> queriesForIds(Collection<String> ids) {        Set<String> idsWithParents = getIdsForIdsWithAncestors(ids);        Map<String, Set<String>> queries = new HashMap<String, Set<String>>();        for (String id : idsWithParents) {            queries.put(id, getIdsForIdWithDescendants(id));        }        return queries;    }
private void handleQueries(      final HttpServletResponse response,      final Map<String, List<String>> queries,      final String version) throws IOException {    LOG.log(Level.INFO, "HttpServerReefEventHandler handleQueries is called");    for (final Map.Entry<String, List<String>> entry : queries.entrySet()) {      final String queryTarget = entry.getKey().toLowerCase();      switch (queryTarget) {      case "id":        if (version.equals(VER)) {          writeEvaluatorInfoJsonOutput(response, entry.getValue());        } else {          writeEvaluatorInfoWebOutput(response, entry.getValue());        }        break;      default:        response.getWriter().println("Unsupported query : " + queryTarget);        break;      }    }  }

fuzzy match ranking
protected Match<?> match() {        Match<?> m = result().getMatch();        if (m == null) {            throw new IllegalStateException("Match failed");        }        return m;    }
@NonNull    public Expression match(@NonNull String query) {        if (query == null) {            throw new IllegalArgumentException("query is null.");        }        return new FullTextMatchExpression(this.name, query);    }
public MatchResult match(QPath input)   {      try      {         return match(new Context(input)).getMatchResult();      }      catch (RepositoryException e)      {         throw (IllegalArgumentException)new IllegalArgumentException("QPath not normalized").initCause(e);      }   }
public NamedPatternMatch<E> match(final String string) {        final Matcher matcher = pattern.matcher(string);        while (matcher.find()) {            final int start = matcher.start();            final int end = matcher.end();            if (start == 0 && end == string.length()) {                final Map<E, String> resultMap = new EnumMap<>(groupEnum);                final Set<Entry<E, Integer>> entries = groupIndexes.entrySet();                for (final Entry<E, Integer> entry : entries) {                    final E group = entry.getKey();                    final Integer groupIndex = entry.getValue();                    final String result = matcher.group(groupIndex);                    resultMap.put(group, result);                }                return new NamedPatternMatch<>(resultMap);            }        }        return null;    }
@PublicAPI(usage = ACCESS)    public Optional<Result> match(String aPackage) {        Matcher matcher = packagePattern.matcher(aPackage);        return matcher.matches() ? Optional.of(new Result(matcher)) : Optional.<Result>absent();    }
public boolean match(String vfsName) {        boolean match = false;        for (int j = 0; j < m_vfsFolders.size(); j++) {            Pattern pattern = m_vfsFolders.get(j);            match = pattern.matcher(vfsName).matches();            if (match) {                break;            }        }        return match;    }
public boolean match(String vfsName) {        for (int j = 0; j < m_relatedSystemResources.size(); j++) {            Pattern pattern = m_relatedSystemResources.get(j);            if (pattern.matcher(vfsName).matches()) {                return true;            }        }        return false;    }
public boolean match(String destination, String metricName) {        int[] matches = match(destination);        if (matches == null || matches.length == 0) {            return false;        }        for (int match : matches) {            String candidateMetricName = proxyRules.get(match).getMetricSystemName();            if (metricName.equals(candidateMetricName)) {                return true;            }        }        return false;    }
static MatchedComment match(Commented<ExpressionTree> actual, String formal) {    Optional<Comment> lastBlockComment =        Streams.findLast(            actual.beforeComments().stream().filter(c -> c.getStyle() == CommentStyle.BLOCK));    if (lastBlockComment.isPresent()) {      Matcher m =          PARAMETER_COMMENT_PATTERN.matcher(Comments.getTextFromComment(lastBlockComment.get()));      if (m.matches()) {        return MatchedComment.create(            lastBlockComment.get(),            m.group(1).equals(formal) ? MatchType.EXACT_MATCH : MatchType.BAD_MATCH);      }    }    Optional<Comment> approximateMatchComment =        Stream.concat(actual.beforeComments().stream(), actual.afterComments().stream())            .filter(comment -> isApproximateMatchingComment(comment, formal))            .findFirst();    if (approximateMatchComment.isPresent()) {      // Report EXACT_MATCH for comments that don't use the recommended style (e.g. `/*foo*/`      // instead of `/* foo= */`), but which match the formal parameter name exactly, since it's      // a style nit rather than a possible correctness issue.      // TODO(cushon): revisit this if we standardize on the recommended comment style.      String text =          CharMatcher.anyOf("=:")              .trimTrailingFrom(Comments.getTextFromComment(approximateMatchComment.get()).trim());      return MatchedComment.create(          approximateMatchComment.get(),          text.equals(formal) ? MatchType.EXACT_MATCH : MatchType.APPROXIMATE_MATCH);    }    return MatchedComment.notAnnotated();  }
@Deprecated    public Map<String, HashSet<String>> match(Map<String, IndexedNodeType> aamModules, Map<String, NodeTemplate> offerings){        Map<String, HashSet<String>> mathedOfferings = new HashMap<>();        for(String moduleName: aamModules.keySet()){            IndexedNodeType module = aamModules.get(moduleName);            mathedOfferings.put(moduleName, new HashSet<String>());            for(String offerName: offerings.keySet()){                NodeTemplate offer = offerings.get(offerName);                if(match(module, offer)){                    mathedOfferings.get(moduleName).add(offerName);                }            }        }        return mathedOfferings;    }

output to html file
private static void outputFile(File dstFile, String version, SortedMap<String, ZoneRules> builtZones, SortedMap<LocalDate, Byte> leapSeconds) {        Map<String, SortedMap<String, ZoneRules>> loopAllBuiltZones = new TreeMap<String, SortedMap<String, ZoneRules>>();        loopAllBuiltZones.put(version, builtZones);        Set<String> loopAllRegionIds = new TreeSet<String>(builtZones.keySet());        Set<ZoneRules> loopAllRules = new HashSet<ZoneRules>(builtZones.values());        outputFile(dstFile, loopAllBuiltZones, loopAllRegionIds, loopAllRules, leapSeconds);    }
private static void outputFile(File dstFile, Map<String, SortedMap<String, ZoneRules>> allBuiltZones,            Set<String> allRegionIds, Set<ZoneRules> allRules, SortedMap<LocalDate, Byte> leapSeconds) {        JarOutputStream jos = null;        try {            jos = new JarOutputStream(new FileOutputStream(dstFile));            outputTzdbEntry(jos, allBuiltZones, allRegionIds, allRules);        } catch (Exception ex) {            System.out.println("Failed: " + ex.toString());            ex.printStackTrace();            System.exit(1);        } finally {            if (jos != null) {                try {                    jos.close();                } catch (IOException ex) {                    // ignore                }            }        }    }
public Path getOutputFile(TaskAttemptID mapTaskId)    throws IOException {    return lDirAlloc.getLocalPathToRead(TaskTracker.getIntermediateOutputDir(                       jobId.toString(), mapTaskId.toString())                       + "/file.out", conf);  }
static File getOutputFile(MavenProject rootModule, File reportFile, String defaultFile) throws MojoExecutionException {        File selectedXmlReportFile;        if (reportFile != null) {            selectedXmlReportFile = reportFile;        } else if (rootModule != null) {            selectedXmlReportFile = new File(getOutputDirectory(rootModule) + "/" + defaultFile);        } else {            throw new MojoExecutionException("Cannot determine report file.");        }        return selectedXmlReportFile;    }
private static void outputFilesDat(File dstDir, Map<String, SortedMap<String, ZoneRules>> allBuiltZones,            Set<String> allRegionIds, Set<ZoneRules> allRules, SortedMap<LocalDate, Byte> leapSeconds) {        File tzdbFile = new File(dstDir, "TZDB.dat");        tzdbFile.delete();        try {            FileOutputStream fos = null;            try {                fos = new FileOutputStream(tzdbFile);                outputTzdbDat(fos, allBuiltZones, allRegionIds, allRules);            } finally {                if (fos != null) {                    fos.close();                }            }        } catch (Exception ex) {            System.out.println("Failed: " + ex.toString());            ex.printStackTrace();            System.exit(1);        }    }
public PagedList<FileInner> listOutputFiles(final String resourceGroupName, final String workspaceName, final String experimentName, final String jobName, final JobsListOutputFilesOptions jobsListOutputFilesOptions) {        ServiceResponse<Page<FileInner>> response = listOutputFilesSinglePageAsync(resourceGroupName, workspaceName, experimentName, jobName, jobsListOutputFilesOptions).toBlocking().single();        return new PagedList<FileInner>(response.body()) {            @Override            public Page<FileInner> nextPage(String nextPageLink) {                return listOutputFilesNextSinglePageAsync(nextPageLink).toBlocking().single().body();            }        };    }
private void checkOutputFile(File file) throws ApkCreationException {        if (file.isDirectory()) {            throw new ApkCreationException("%s is a directory!", file);        }        if (file.exists()) { // will be a file in this case.            if (!file.canWrite()) {                throw new ApkCreationException("Cannot write %s", file);            }        } else {            try {                if (!file.createNewFile()) {                    throw new ApkCreationException("Failed to create %s", file);                }            } catch (IOException e) {                throw new ApkCreationException(                        "Failed to create '%1$ss': %2$s", file, e.getMessage());            }        }    }
public HDFSDistributor setOutputFileDir(String fileName) {        this.mapperOutputFileName = fileName;        if (hdfsFileRoot != null) {            this.mapperOutputFilePath = new Path(hdfsFileRoot + "/" + mapperOutputFileName);        }        return this;    }
private void createOutputFile() throws IOException {        this.fileChannel = Files.newByteChannel(Paths.get(filePath), StandardOpenOption.CREATE, StandardOpenOption.WRITE, StandardOpenOption.TRUNCATE_EXISTING);    }
@Override    public String getOutputFilePath(Map<String, Object> properties)    {        String path = (String) properties.get(SparkPropertiesConstants.HDFS_OUTPUT_FILE_PATH);        if (path == null || path.isEmpty())        {            throw new KunderaException(                    "Please set the path of outputfile while creating EntityManager using the property" + "\""                            + SparkPropertiesConstants.HDFS_OUTPUT_FILE_PATH + "\".");        }        return path;    }

how to read .csv file in an efficient way?
public List<Csv> getCSVFiles() throws FlickrException {        Map<String, Object> parameters = new HashMap<String, Object>();        parameters.put("method", METHOD_GET_CSV_FILES);        Response response = transportAPI.get(transportAPI.getPath(), parameters, apiKey, sharedSecret);        if (response.isError()) {            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());        }        List<Csv> csvFiles = parseCsvFiles(response);        return csvFiles;    }
public Stats getCSVFiles() throws JinxException {    Map<String, String> params = new TreeMap<>();    params.put("method", "flickr.stats.getCSVFiles");    return jinx.flickrGet(params, Stats.class);  }
private void loadCSVFile(TableDefinition tableDef, File file) throws IOException {        try (BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(file), Utils.UTF8_CHARSET))            ) {            loadCSVFromReader(tableDef, file.getAbsolutePath(), file.length(), reader);        }    }
@VisibleForTesting  public static void writeCSVFile(Collection<? extends PropertyKey> defaultKeys, String filePath)      throws IOException {    if (defaultKeys.size() == 0) {      return;    }    FileWriter fileWriter;    Closer closer = Closer.create();    String[] fileNames = {"user-configuration.csv", "master-configuration.csv",        "worker-configuration.csv", "security-configuration.csv",        "common-configuration.csv", "cluster-management-configuration.csv"};    try {      // HashMap for FileWriter per each category      Map<String, FileWriter> fileWriterMap = new HashMap<>();      for (String fileName : fileNames) {        fileWriter = new FileWriter(PathUtils.concatPath(filePath, fileName));        // Write the CSV file header and line separator after the header        fileWriter.append(CSV_FILE_HEADER + "\n");        //put fileWriter        String key = fileName.substring(0, fileName.indexOf("configuration") - 1);        fileWriterMap.put(key, fileWriter);        //register file writer        closer.register(fileWriter);      }      // Sort defaultKeys      List<PropertyKey> dfkeys = new ArrayList<>(defaultKeys);      Collections.sort(dfkeys);      for (PropertyKey propertyKey : dfkeys) {        String pKey = propertyKey.toString();        String defaultDescription;        if (propertyKey.getDefaultSupplier().get() == null) {          defaultDescription = "";        } else {          defaultDescription = propertyKey.getDefaultSupplier().getDescription();        }        // Quote the whole description to escape characters such as commas.        defaultDescription = String.format("\"%s\"", defaultDescription);        // Write property key and default value to CSV        String keyValueStr = pKey + "," + defaultDescription + "\n";        if (pKey.startsWith("alluxio.user.")) {          fileWriter = fileWriterMap.get("user");        } else if (pKey.startsWith("alluxio.master.")) {          fileWriter = fileWriterMap.get("master");        } else if (pKey.startsWith("alluxio.worker.")) {          fileWriter = fileWriterMap.get("worker");        } else if (pKey.startsWith("alluxio.security.")) {          fileWriter = fileWriterMap.get("security");        } else if (pKey.startsWith("alluxio.keyvalue.")) {          fileWriter = fileWriterMap.get("key-value");        } else if (pKey.startsWith("alluxio.integration")) {          fileWriter = fileWriterMap.get("cluster-management");        } else {          fileWriter = fileWriterMap.get("common");        }        fileWriter.append(keyValueStr);      }      LOG.info("Property Key CSV files were created successfully.");    } catch (Exception e) {      throw closer.rethrow(e);    } finally {      try {        closer.close();      } catch (IOException e) {        LOG.error("Error while flushing/closing Property Key CSV FileWriter", e);      }    }  }
public static File createCsvFile(String outputCsvPath, String mode) {        return createCsvFile(outputCsvPath, mode, null);    }
public static File createCsvFile(String outputCsvPath, String model, String metaFilePath) {        if (!outputCsvPath.endsWith(File.separator) && !outputCsvPath.equals("")) {            outputCsvPath += File.separator;        }        String domeInfo = "";        if (metaFilePath != null) {            try {                // Read meta data                CSVReader reader = new CSVReader(new FileReader(metaFilePath), ',', '"');                List<String[]> metaData = reader.readAll();                reader.close();                // Get Title and first record                String[] title = new String[0];                ArrayList<String[]> dataArr = new ArrayList();                for (int i = 0; i < metaData.size() - 1; i++) {                    if ("#".equals(metaData.get(i)[0])) {                        title = metaData.get(i);                    } else if ("*".equals(metaData.get(i)[0])) {                        dataArr.add(metaData.get(i));                    }                }                // Get the position index of Region, stratum, climate ID, RAP ID and Management ID                int region = -1;                int crop = -1;                int climateId = -1;                int rapId = -1;                int mgnId = -1;                int field = -1;                int seasonal = -1;                int count = 0;                for (int i = 0; i < title.length; i++) {                    if ("REG_ID".equalsIgnoreCase(title[i])) {                        region = i;                        count++;                    } else if ("CRID_text".equalsIgnoreCase(title[i])) {                        crop = i;                        count++;                    } else if ("CLIM_ID".equalsIgnoreCase(title[i])) {                        climateId = i;                        count++;                    } else if ("RAP_ID".equalsIgnoreCase(title[i])) {                        rapId = i;                        count++;                    } else if ("MAN_ID".equalsIgnoreCase(title[i])) {                        mgnId = i;                        count++;                    } else if ("FIELD_OVERLAY".equalsIgnoreCase(title[i])) {                        field = i;                        count++;                    } else if ("SEASONAL_STRATEGY".equalsIgnoreCase(title[i])) {                        seasonal = i;                        count++;                    } else {                        continue;                    }                    if (count == 7) {                        break;                    }                }                // Get dome info for creating ACMO file name                if (!dataArr.isEmpty() && region != -1 && (crop != -1 || rapId != -1 || mgnId != -1 || climateId != -1)) {                    String str;                    if ((str = getDomeInfoStr(dataArr.get(0), region)).equals("0-")) {                        if (!(str = getDomeInfoStr(dataArr.get(0), seasonal)).equals("0-")) {                        } else if (!(str = getDomeInfoStr(dataArr.get(0), field)).equals("0-")) {                        } else {                            str = "";                        }                        if (!"".equals(str)) {                            HashMap<String, String> domeBase = DomeUtil.unpackDomeName(str);                            str = MapUtil.getValueOr(domeBase, "reg_id", "");                            if (!str.equals("")) {                                str += "-";                            }                        }                    } else {                        if (!str.equals("")) {                            domeInfo = str;                            domeInfo += getDomeInfoStr(dataArr.get(0), crop).replaceAll(" ", "").toUpperCase();                            domeInfo += getDomeInfoStr(dataArr.get(0), climateId);                            domeInfo += getDomeInfoStr(dataArr, rapId);                            domeInfo += getDomeInfoStr(dataArr, mgnId);                        }                    }                }            } catch (IOException ex) {                domeInfo = "";            }        }        // Create CSV file name        outputCsvPath += "ACMO-" + domeInfo + model;        File f = new File(outputCsvPath + ".csv");        int count = 1;        while (f.exists()) {            f = new File(outputCsvPath + " (" + count + ").csv");            count++;        }        return f;    }
public Table file(File file) throws IOException {String extension = Files.getFileExtension(file.getCanonicalPath());DataReader<?> reader = registry.getReaderForExtension(extension);return reader.read(new Source(file));    }
private InputStream getCsvFileStream() throws FileNotFoundException {        if (myZipFileStream == null) {            if (myZipFilePath == null) {                final String csvFileName = getBundledCsvFileName();                return getClass().getClassLoader().getResourceAsStream(csvFileName);            } else {                return new FileInputStream(myZipFilePath);            }        } else {            return myZipFileStream;        }    }
@Deprecated    public WaitFileConditionBuilder file(String filePath) {        FileCondition condition = new FileCondition();        condition.setFilePath(filePath);        container.setCondition(condition);        this.buildAndRun();        return new WaitFileConditionBuilder(condition, this);    }
@Deprecated    public WaitFileConditionBuilder file(File file) {        FileCondition condition = new FileCondition();        condition.setFile(file);        container.setCondition(condition);        this.buildAndRun();        return new WaitFileConditionBuilder(condition, this);    }

